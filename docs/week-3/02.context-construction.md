# 02. 지식의 재구성: 검색 결과 기반 Context 구축

Week 3의 두 번째 단계로, 벡터 검색을 통해 찾아낸 원시 데이터를 AI가 이해하기 좋은 형태인 **컨텍스트(Context)** 로 재구성하는 과정을 학습합니다.

## 1. 개요

벡터 검색 결과(`BookSearchResponse` 리스트)는 Java 객체 덩어리일 뿐입니다. AI(LLM)는 이 객체를 직접 읽는 것이 아니라 텍스트를 읽습니다. 따라서 검색된 도서들의 제목, 저자, 소개글 등을 하나의 자연어 텍스트로 합쳐서 AI에게 전달해야 합니다. 이 '합쳐진 참고 자료'를 **컨텍스트(Context)** 라고 부릅니다.

## 2. 주요 개념

### 2.1. Context (컨텍스트/맥락)
AI가 답변을 생성할 때 참고하도록 사용자 질문과 함께 제공하는 배경 지식입니다.
- **특징**: AI의 기억력(Token Limit)에는 한계가 있으므로, 가장 관련성이 높은 정보 위주로 압축하여 제공해야 합니다.

### 2.2. 프롬프트 엔지니어링 (Prompt Engineering)
AI에게 질문을 할 때, 어떤 역할을 부여하고 어떤 제약 조건을 줄지 설계하는 기술입니다. RAG에서는 컨텍스트를 프롬프트 안에 자연스럽게 녹여내는 것이 핵심입니다.

## 3. 구현 가이드 (Step-by-Step)

### 3.1. 검색 결과 정제 및 추출
벡터 검색이나 하이브리드 검색을 통해 얻은 상위(Top-K) 도서 리스트에서 AI 답변 생성에 필요한 필드만 추출합니다.
- **필수 필드**: 도서 제목, 저자, 도서 소개(`book_content`)
- **선택 필드**: 출판일, 가격 등 (질문의 의도에 따라 포함)

### 3.2. 텍스트 포맷팅 (Serialization)
추출한 데이터를 AI가 구조를 파악하기 쉬운 텍스트 형식으로 변환합니다. 주로 Markdown 형식을 많이 사용합니다.
```text
[참고 도서 리스트]
1. 제목: 자바의 정석 / 저자: 남궁성
   내용: 자바의 기초부터 심화까지 다루는 입문서...
2. 제목: 스프링 인 액션 / 저자: 크레이그 월즈
   내용: 스프링 프레임워크의 실무 활용법을 안내하는...
```

### 3.3. 프롬프트 템플릿 작성
사용자의 질문과 위에서 만든 컨텍스트를 결합할 틀을 만듭니다. 단순한 답변뿐만 아니라, AI에게 페르소나를 부여하고 출력 형식을 지정하여 품질을 높일 수 있습니다.

**기본 템플릿 예시:**
```text
당신은 도서관의 전문 사서입니다. 
아래 제공된 [참고 도서 리스트]를 바탕으로 사용자의 질문에 친절하게 답해주세요.
리스트에 없는 책은 절대로 추천하지 마세요.

[참고 도서 리스트]
{context}

사용자 질문: {question}
답변:
```

**고급 템플릿 예시 (JSON 출력 및 정교한 필터링):**
사용자가 제공하는 질의(query)와 검색된 도서 간의 연관성을 수치화하고, 구조화된 응답을 받기 위한 프롬프트입니다.

```text
[규칙]
- 사용자가 제공하는 query와 가장 관련 있는 도서를 선별하세요.
- 각 도서에 대해 relevance 점수(0~100)를 부여하세요:
  - 90–100: query와 직접적으로 강하게 연관, 주제 적합성이 매우 높음
  - 70–89: query와 밀접하게 관련 있지만 일부 범위가 제한적임
  - 50–69: query와 간접적으로 관련, 배경 지식에 도움이 됨
  - 50 미만: 관련성이 낮으므로 출력에서 제외
- 추천 사유("why")에는 점수를 포함하지 말고, 순수하게 이유만 설명하세요.
- 최신 출간일과 query와의 직접적인 관련성을 함께 고려하세요.

[출력 형식]
- 출력은 반드시 순수 JSON만 포함하세요.
- 마크다운 코드 블록(```json ... ```)이나 추가 설명 텍스트는 절대 포함하지 마세요.
- 언어는 반드시 한국어를 사용하세요.

[JSON STRUCTURE]
 [
    {
      "id": 123,
      "relevance": 95,
      "why": "추천 사유"
    }
 ]

- 결과는 relevance 기준 내림차순으로 정렬하세요.
- 입력 데이터에 없는 필드는 추측하지 마세요.

query: {question}

도서 데이터:
{context}
```

> **주의**: Spring AI의 `PromptTemplate`은 내부적으로 `StringTemplate` 엔진을 사용합니다. JSON 구조 내의 특수 문자나 한국어가 포함된 경우 렌더링 오류가 발생할 수 있으므로, 복잡한 템플릿의 경우 Java의 `String.replace()`를 사용하여 수동으로 변수를 치환하는 방식이 더 안정적일 수 있습니다.

### 3.4. AI 응답 데이터 구조화 및 역직렬화 (Java DTO 연동)
AI가 생성한 JSON 응답을 Java에서 안전하게 다루기 위해 DTO(Data Transfer Object)로 변환(역직렬화)하는 과정이 필요합니다.

**추천 응답 DTO 예시:**
```java
@Getter
@Setter
@NoArgsConstructor
public class BookAiRecommendationResponse {
    private Long id;        // 도서 ID
    private int relevance;  // 연관성 점수 (0-100)
    private String why;     // 추천 사유
    private Double similarity; // 벡터 유사도 (추가)
    private Double rrfScore;   // 하이브리드 검색 RRF 점수 (추가)
}
```

**서비스에서의 역직렬화 로직:**
`Jackson ObjectMapper`를 사용하여 AI가 반환한 JSON 문자열을 DTO 리스트로 변환합니다. 이때 마크다운 코드 블록(` ```json `)이 포함될 수 있으므로 전처리가 필요할 수 있습니다.
```java
String rawResponse = bookAiService.askAboutBooks(renderedPrompt);
// JSON 응답 정제
String jsonPart = rawResponse.replaceAll("```json", "").replaceAll("```", "").trim();
List<BookAiRecommendationResponse> recommendations = 
    objectMapper.readValue(jsonPart, new TypeReference<List<BookAiRecommendationResponse>>() {});
```

## 4. 학습 포인트

*   **Context 품질의 중요성**: 쓰레기가 들어가면 쓰레기가 나옵니다(GIGO). 검색 결과가 나쁘면 AI는 엉뚱한 참고서를 보고 오답을 내놓게 됩니다.
*   **데이터의 구조화**: 비정형 텍스트를 AI가 이해하기 쉬운 구조(Markdown, JSON 등)로 전달했을 때의 응답 품질 차이를 경험합니다.

## 5. 심화 학습 (Study Topics)

### 5.1. 요약의 미학
도서 소개글이 너무 길면 AI가 읽다가 지치거나(토큰 비용 상승), 중요한 내용을 놓칠 수 있습니다. 필요한 부분만 잘라내거나(Chunking), 핵심만 추리는 전처리가 필요할 수 있습니다.

### 5.2. 사서의 페르소나 (Role-play)
AI에게 "너는 사서야"라고 역할을 부여하는 것과 아무 말도 안 하는 것의 답변 말투와 정확도는 크게 다릅니다. AI에게 명확한 '자아'를 부여해 보세요.

## 6. 참고 링크

*   [Prompt Engineering Guide (DAIR.AI)](https://www.promptingguide.ai/kr)
*   [OpenAI Prompt Engineering Best Practices](https://platform.openai.com/docs/guides/prompt-engineering)
