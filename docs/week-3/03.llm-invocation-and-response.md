# 03. LLM 호출과 응답: AI로부터 답변 받기

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- Week 3의 01, 02 문서 내용 (RAG 기초, 컨텍스트 구축)
- HTTP API 통신 기초
- Jackson JSON 라이브러리 기초
- Spring Boot Service 계층 이해

---

## 1. 개요

이제 모든 준비가 끝났습니다! 검색으로 얻은 컨텍스트와 사용자 질문을 AI 모델에 전달하면, AI는 이를 바탕으로 답변을 생성합니다.

**이 문서에서 배울 내용:**
- Chat Completion API가 무엇인지
- Temperature 파라미터의 역할
- Spring AI ChatModel 사용법
- AI 응답 처리 및 에러 핸들링
- 추천 결과를 화면에 표시하기

> **중요: LLM 호출의 핵심**
>
> 준비가 완료된 재료들:
> - 질문: "초보자를 위한 자바 책"
> - 컨텍스트: 10권의 도서 정보
>
> AI 모델에 전달:
> - 프롬프트 생성 → AI 호출 → 응답 수신
> - 시간: 약 1~3초
> - 결과: 추천 도서 리스트 + 추천 이유

---

## 2. 핵심 개념 이해

### 2.1. Chat Completion API

AI 모델과 대화하듯이 요청을 보내고 응답을 받는 API입니다.

**비유로 이해하기:**
```
[일반적인 API]
요청: "도서 목록 주세요"
응답: [{"id": 1, "title": "자바의 정석"}, ...]
→ 데이터만 주고받음

[Chat Completion API]
요청: "초보자를 위한 자바 책 추천해줘"
      (참고 자료: 도서 10권 정보)
응답: "네, 초보자분께는 자바의 정석을 추천해드립니다.
       이 책은..."
→ 대화하듯 자연스러운 텍스트 응답
```

### 2.2. Role (역할)

메시지의 성격을 정의합니다.

| Role | 설명 | 예시 |
|------|------|------|
| System | AI의 역할과 행동 규칙 | "당신은 도서관 사서입니다" |
| User | 사용자의 질문이나 요청 | "자바 책 추천해줘" |
| Assistant | AI의 응답 | "네, 추천할 책은..." |

**메시지 구조 예시:**
```
[
  {role: "system", content: "당신은 도서관 사서입니다"},
  {role: "user", content: "자바 책 추천해줘"},
  {role: "assistant", content: "네, 추천할 책은..."}
]
```

### 2.3. Temperature (온도)

AI 응답의 창의성을 조절하는 파라미터입니다.

**비유로 이해하기:**
```
[Temperature = 0.0 (낮음)]
AI: "자바의 정석을 추천합니다"
→ 매번 똑같은 답변
→ 일관성 중요

[Temperature = 0.7 (중간)]
AI: "자바의 정석을 추천합니다" 또는 "이것이 자바다도 좋아요"
→ 약간씩 다른 답변
→ 창의성과 일관성의 균형

[Temperature = 1.0 (높음)]
AI: "자바의 정석, 이것이 자바다, 열혈 Java 프로그래밍..."
→ 매번 다른 답변
→ 창의성 중요
```

**도서 추천에 적합한 설정:**
```
Temperature = 0.3
→ 일관된 추천
→ 정확한 정보 전달
→ 전문적인 어조
```

### 2.4. Tokens (토큰)

AI가 텍스트를 처리하는 기본 단위입니다.

**비유로 이해하기:**
```
[토큰이란?]
AI에게는 글자가 아니라 "토큰"이라는 단위로 보여요

예시:
"안녕하세요" → 3토큰 (안녕/하/세요)
"Hello" → 2토큰 (Hell/o)
"자바의 정석" → 5토큰 (자/바/의/정/석)

[비용 계산]
입력 토큰: 1,000토큰 × $0.00001 = $0.01
출력 토큰: 500토큰 × $0.00002 = $0.01
총비용: $0.02
```

---

## 3. 구현 가이드 (Step-by-Step)

### STEP 1: 의존성 설정

Google Gemini와 OpenAI(임베딩용) 의존성을 추가합니다.

**pom.xml**
```xml
<dependencies>
    <!-- Google Gemini -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-starter-model-google-genai</artifactId>
    </dependency>

    <!-- OpenAI (임베딩) -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-openai</artifactId>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-bom</artifactId>
            <version>1.0.1</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### STEP 2: AI 모델 설정

**application.properties**
```properties
# ===============================
# Google Gemini 설정
# ===============================
spring.ai.genai.api-key=${GEMINI_API_KEY}
spring.ai.genai.chat.options.model=gemini-2.0-flash
spring.ai.genai.chat.options.temperature=0.3

# ===============================
# Ollama 설정 (선택)
# ===============================
spring.ai.ollama.base-url=http://ollama.java21.net
spring.ai.ollama.chat.options.model=llama3-korean-blossom
spring.ai.ollama.chat.options.temperature=0.3

# 사용할 모델 선택 (gemini 또는 ollama)
spring.ai.selected-model=gemini
```

### STEP 3: AI 서비스 구현

**BookAiService.java**
```java
package com.nhnacademy.library.core.book.service.ai;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.stereotype.Service;

/**
 * AI 모델 호출 서비스
 *
 * Gemini 또는 Ollama 모델을 호출합니다.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class BookAiService {

    private final ChatModel chatModel;

    /**
     * AI에게 질문하고 답변 받기
     *
     * @param prompt 프롬프트
     * @return AI 응답
     */
    public String askAboutBooks(String prompt) {
        log.info("AI 호출 시작...");
        log.debug("프롬프트: {}", prompt);

        try {
            // AI 모델 호출
            String response = chatModel.call(prompt);

            log.info("AI 호출 완료");
            log.debug("응답: {}", response);

            return response;

        } catch (Exception e) {
            log.error("AI 호출 실패", e);
            throw new RuntimeException("AI 호출 중 오류가 발생했습니다.", e);
        }
    }
}
```

### STEP 4: RAG 서비스 완성

전체 RAG 파이프라인을 구현합니다.

**BookRagService.java**
```java
package com.nhnacademy.library.core.book.service.rag;

import com.nhnacademy.library.core.book.dto.BookAiRecommendationResponse;
import com.nhnacademy.library.core.book.dto.BookSearchResponse;
import com.nhnacademy.library.core.book.service.ai.BookAiService;
import com.nhnacademy.library.core.book.service.search.BookSearchService;
import com.nhnacademy.library.core.book.util.JsonParser;
import com.nhnacademy.library.core.book.util.PromptTemplate;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * RAG 기반 도서 추천 서비스
 *
 * 전체 파이프라인을 조율합니다.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class BookRagService {

    private final BookSearchService bookSearchService;
    private final BookAiService bookAiService;

    /**
     * RAG 기반 도서 추천
     *
     * @param question 사용자 질문
     * @return 추천 결과 리스트
     */
    public List<BookAiRecommendationResponse> recommendBooks(String question) {
        log.info("=== RAG 추천 시작 ===");
        log.info("질문: {}", question);

        // 1. 검색 (Retrieval)
        List<BookSearchResponse> books = searchBooks(question);
        log.info("검색된 도서: {}권", books.size());

        // 2. 컨텍스트 구축
        String context = buildContext(books);
        log.debug("컨텍스트 길이: {} 자", context.length());

        // 3. 프롬프트 생성
        String prompt = PromptTemplate.createJsonPrompt(question, context);

        // 4. AI 호출 (Generation)
        String rawResponse = bookAiService.askAboutBooks(prompt);
        log.debug("AI 응답 길이: {} 자", rawResponse.length());

        // 5. 역직렬화
        List<BookAiRecommendationResponse> recommendations =
                JsonParser.parseRecommendations(rawResponse);

        log.info("추천된 도서: {}권", recommendations.size());
        log.info("=== RAG 추천 완료 ===");

        return recommendations;
    }

    /**
     * 도서 검색
     */
    private List<BookSearchResponse> searchBooks(String question) {
        return bookSearchService.searchBooks(
                SearchType.HYBRID,
                question,
                0,
                10  // Top-K = 10
        );
    }

    /**
     * 컨텍스트 구축
     */
    private String buildContext(List<BookSearchResponse> books) {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < books.size(); i++) {
            BookSearchResponse book = books.get(i);

            sb.append("### 도서 ").append(i + 1).append("\n");
            sb.append("- ID: ").append(book.id()).append("\n");
            sb.append("- 제목: ").append(book.title()).append("\n");
            sb.append("- 저자: ").append(book.authorName()).append("\n");

            if (book.bookContent() != null) {
                String content = book.bookContent();
                if (content.length() > 300) {
                    content = content.substring(0, 300) + "...";
                }
                sb.append("- 내용: ").append(content).append("\n");
            }

            sb.append("\n");
        }

        return sb.toString();
    }
}
```

### STEP 5: Controller 구현

**BookRagController.java**
```java
package com.nhnacademy.library.front.web;

import com.nhnacademy.library.core.book.dto.BookAiRecommendationResponse;
import com.nhnacademy.library.core.book.service.rag.BookRagService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.List;

/**
 * RAG 도서 추천 컨트롤러
 */
@Controller
@RequiredArgsConstructor
public class BookRagController {

    private final BookRagService bookRagService;

    /**
     * AI 도서 추천
     */
    @GetMapping("/rag/recommend")
    public String recommendBooks(
            @RequestParam String question,
            Model model
    ) {
        try {
            // RAG 추천
            List<BookAiRecommendationResponse> recommendations =
                    bookRagService.recommendBooks(question);

            // 모델에 데이터 담기
            model.addAttribute("recommendations", recommendations);
            model.addAttribute("question", question);

            return "rag/result";

        } catch (Exception e) {
            model.addAttribute("error", "추천 중 오류가 발생했습니다.");
            model.addAttribute("errorMessage", e.getMessage());
            return "rag/error";
        }
    }
}
```

---

## 4. 전체 시스템 흐름

```
[사용자]                     [서버]                      [AI 모델]
    │                           │                            │
    │  1. 질문 입력               │                            │
    │  "초보자를 위한 자바 책"    │                            │
    ├──────────────────────────>│                            │
    │                           │                            │
    │                           │  2. 하이브리드 검색           │
    │                           ├──────────────────────────>│
    │                           │  (DB + 임베딩)               │
    │                           │<──────────────────────────┤
    │                           │  10권 검색됨                 │
    │                           │                            │
    │                           │  3. 컨텍스트 구축            │
    │                           │  "도서 1, 도서 2, ..."      │
    │                           │                            │
    │                           │  4. 프롬프트 생성            │
    │                           │  질문 + 컨텍스트             │
    │                           │                            │
    │                           │  5. AI 호출                 │
    │                           ├──────────────────────────>│
    │                           │  "다음 책들을 추천해줘..."   │
    │                           │                            │
    │                           │  6. AI 답변                 │
    │                           │<──────────────────────────┤
    │                           │  [{"id":1, "relevance":95}]│
    │                           │                            │
    │  7. 결과 표시               │                            │
    │<──────────────────────────┤                            │
    │  AI 추천 도서               │                            │
    │  1. 자바의 정석             │                            │
    │     추천 이유: 초보자에게... │                            │
    │     일치율: 95%             │                            │
```

---

## 5. 에러 핸들링

### 5.1. AI 호출 실패

**원인:**
- API 키 만료
- 네트워크 오류
- 토큰 한계 초과

**처리 방법:**
```java
try {
    String response = chatModel.call(prompt);
    return response;
} catch (ApiException e) {
    log.error("API 호출 실패: {}", e.getMessage());
    throw new RuntimeException("AI 서비스 연결에 실패했습니다.");
} catch (RateLimitException e) {
    log.error("속도 제한 초과: {}", e.getMessage());
    throw new RuntimeException("너무 많은 요청을 보냈습니다. 잠시 후 다시 시도해주세요.");
}
```

### 5.2. JSON 파싱 실패

**원인:**
- AI가 유효하지 않은 JSON 반환
- 예상과 다른 형식의 응답

**처리 방법:**
```java
try {
    return objectMapper.readValue(json, type);
} catch (JsonProcessingException e) {
    log.error("JSON 파싱 실패: {}", json);
    throw new RuntimeException("AI 응답을 처리할 수 없습니다.");
}
```

### 5.3. 검색 결과 없음

**처리 방법:**
```java
if (books.isEmpty()) {
    log.warn("검색 결과가 없습니다.");
    throw new IllegalArgumentException(
            "관련 도서를 찾을 수 없습니다. 다른 검색어를 시도해주세요."
    );
}
```

---

## 6. 실습 미션

### 미션 1: Temperature 테스트

```java
@Test
void testTemperature() {
    String prompt = "자바 책 한 권 추천해줘";

    // Temperature 0.0
    String response1 = chatModel.call(prompt);

    // Temperature 0.0 (다시 호출)
    String response2 = chatModel.call(prompt);

    // 두 응답 비교
    System.out.println("응답 1: " + response1);
    System.out.println("응답 2: " + response2);

    // 낮은 온도면 비슷한 응답이 나와야 함
    assertEquals(response1, response2);
}
```

### 미션 2: 전체 RAG 파이프라인 테스트

```java
@Test
void testRagPipeline() {
    String question = "초보자를 위한 자바 책";

    // 1. RAG 추천
    List<BookAiRecommendationResponse> recommendations =
            bookRagService.recommendBooks(question);

    // 2. 결과 확인
    assertNotNull(recommendations);
    assertFalse(recommendations.isEmpty());

    // 3. 각 추천의 필드 확인
    recommendations.forEach(rec -> {
        assertTrue(rec.relevance() >= 0 && rec.relevance() <= 100);
        assertTrue(rec.why() != null && !rec.why().isBlank());
    });

    // 4. 정렬 확인 (relevance 내림차순)
    for (int i = 0; i < recommendations.size() - 1; i++) {
        assertTrue(recommendations.get(i).relevance() >=
                   recommendations.get(i + 1).relevance());
    }
}
```

### 미션 3: 에러 핸들링 테스트

```java
@Test
void testErrorHandling() {
    // 빈 질문
    assertThrows(IllegalArgumentException.class, () -> {
        bookRagService.recommendBooks("");
    });

    // 너무 긴 질문 (1000자 이상)
    String longQuestion = "a".repeat(1000);
    assertThrows(IllegalArgumentException.class, () -> {
        bookRagService.recommendBooks(longQuestion);
    });
}
```

---

## 7. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

- [ ] Chat Completion API가 무엇인지 안다
- [ ] Role(System, User, Assistant)을 이해한다
- [ ] Temperature 파라미터의 역할을 안다
- [ ] 토큰과 비용의 관계를 이해한다
- [ ] Spring AI ChatModel을 사용할 수 있다
- [ ] AI 응답을 처리할 수 있다
- [ ] 에러 핸들링을 할 수 있다
- [ ] 전체 RAG 파이프라인을 구현할 수 있다

---

## 8. Week 3 정리

이번 주차에 배운 내용을 복습해 보세요:

### 1단계: RAG 이해
- 환각 현상 문제
- 검색 증강 생성 개념
- RAG의 장점

### 2단계: 컨텍스트 구축
- 검색 결과를 텍스트로 변환
- 프롬프트 엔지니어링
- 토큰 제한 관리

### 3단계: LLM 호출
- ChatModel 사용법
- Temperature 설정
- 응답 처리 및 에러 핸들링

---

## 9. 다음 단계

다음 주차에서는 **성능 최적화**를 배웁니다:
- API 비용 최적화
- Top-K 최적화
- 결과 캐싱
- 배치 처리

[다음: Week 4 - 성능 최적화 →](../week-4/01.performance-and-cost.md)
