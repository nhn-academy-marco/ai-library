# 03. 검색 UI: Thymeleaf와 Tabler 기반 화면 구축

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- HTML/CSS 기초 (태그, 클래스, 속성)
- Spring MVC 기초 (@Controller, @GetMapping)
- Week 1의 01, 02 문서 내용 (데이터 적재, 검색 구현)

---

## 1. 개요

사용자가 웹 브라우저에서 도서를 검색할 수 있는 화면(UI)을 만듭니다.

**이 문서에서 배울 내용:**
- 템플릿 엔진(Template Engine)이 무엇인지
- Thymeleaf로 서버에서 HTML을 만드는 방법
- Tabler와 Bootstrap으로 UI를 만드는 방법
- Controller와 View가 데이터를 주고받는 방법
- 레이아웃(Layout)과 프래그먼트(Fragment)로 코드 재사용하기

> **중요: 왜 UI가 중요할까요?**
>
> 아무리 좋은 검색 기능이 있어도, 사용자가 쓸 수 있는 화면이 없다면 소용이 없습니다.
>
> - 백엔드: 검색 로직 처리 (뇌)
> - 프론트엔드: 사용자에게 보여주는 화면 (얼굴)
>
> 두 다 잘해야 좋은 서비스가 됩니다!

> **💡 참고: 실제 운영 중인 도서관 사이트**
>
> 실제 동작하는 도서 검색 사이트를 참고하세요: **[library.java21.net](https://library.java21.net)**
>
> **해당 사이트의 UI 구조:**
> - 검색 방식 선택 (ISBN, 키워드)
> - 검색어 입력창과 검색 버튼
> - AI 검색 중 "로딩" 메시지 표시
> - 검색 결과 카드 (표지, 제목, 저자, 출판사, ISBN)
> - 페이징 네비게이션
>
> **이 문서의 범위:**
> - **기능 구현**: 검색 폼, 결과 표시, 페이징
> - **범위 외**: 디자인/스타일링은 별도 작업 필요 (CSS, 레이아웃 등은 각자 구현)

---

## 2. 핵심 개념 이해

### 2.1. 템플릿 엔진(Template Engine)이란?

**템플릿 엔진**은 HTML 틀에 데이터를 채워서 완성된 HTML을 만드는 도구입니다.

**비유로 이해하기:**
```
빵집 틀을 상상해 보세요.

[빵 틀] + [반죽] = [완성된 빵]

웹에서도 똑같습니다:

[HTML 틀] + [데이터] = [완성된 웹 페이지]
```

**템플릿 엔진의 장점:**
- HTML을 자바로 직접 만들 필요가 없습니다
- 디자이너와 개발자가 분업해서 작업할 수 있습니다
- 코드가 간결하고 유지보수하기 쉽습니다

### 2.2. Thymeleaf란?

**Thymeleaf**는 Spring에서 가장 많이 사용하는 템플릿 엔진입니다.

**특징:**
- HTML 파일을 그대로 사용할 수 있습니다
- 브라우저에서 바로 열어도 디자인을 확인할 수 있습니다
- Spring과 자연스럽게 연동됩니다

**기본 사용법:**
```html
<!-- Thymeleaf 속성은 th:로 시작합니다 -->
<div th:text="${book.title}">제목 여기</div>
```

**작동 원리:**
1. 서버에서 실행될 때: `${book.title}` 값으로 대체
2. 브라우저에서 바로 열 때: "제목 여기" 텍스트 표시

### 2.3. MVC 패턴이란?

**MVC**는 Model-View-Controller의 약자로, 코드를 역할별로 분리하는 설계 방식입니다.

**비유로 이해하기:**
```
식당을 상상해 보세요.

[손님] --주문--> [종업원] --주문서--> [주방]
                   ↑                    |
                   |                    ↓
                [메뉴판]            [요리]

이 과정에서:
- 손님: 사용자 (브라우저)
- 종업원: Controller (주문 받기)
- 주방: Service (요리)
- 메뉴판: View (화면)
```

**웹에서의 MVC:**
- **Model**: 데이터 (검색 결과 도서 목록)
- **View**: 화면 (HTML)
- **Controller**: 중계 (데이터를 가져와서 화면에 전달)

### 2.4. Bootstrap이란?

**Bootstrap**은 트위터가 만든 CSS 프레임워크입니다.

**특징:**
- 예쁜 버튼, 폼, 카드 등을 클래스만으로 만들 수 있습니다
- 모바일 반응형을 자동으로 지원합니다
- 복잡한 CSS를 몰라도 괜찮습니다

**예시:**
```html
<!-- Bootstrap 없이 -->
<button style="background: blue; color: white; padding: 10px 20px;
                border: none; border-radius: 5px; ...">
    클릭
</button>

<!-- Bootstrap 있이 -->
<button class="btn btn-primary">클릭</button>
```

### 2.5. Tabler란?

**Tabler**는 Bootstrap 기반의 관리자 대시보드 템플릿입니다.

**특징:**
- 전문적인 UI 컴포넌트를 제공합니다
- 다크 모드를 지원합니다
- 백엔드 개발자가 사용하기 쉽습니다

---

## 3. 전체 시스템 흐름

### 3.1. 사용자 요청 처리 흐름

```
[브라우저]                      [서버]
  사용자                         백엔드
    │                              │
    │  1. 검색 페이지 요청           │
    ├─────────────────────────────>│
    │  GET /                       │
    │                              │
    │                              │  2. Controller 호출
    │                              ├───────────────>
    │                              │                 │
    │                              │           [Service]
    │                              │                 │
    │                              │  3. 데이터 조회  │
    │                              │<───────────────┤
    │                              │                 │
    │  4. HTML 응답                │
    │<─────────────────────────────┤
    │  <HTML> 완성된 페이지          │
```

### 3.2. Controller의 역할

```java
@Controller  // "이 클래스가 화면을 담당합니다"
public class BookSearchController {

    @GetMapping("/")  // "http://localhost:8080/" 요청이 오면 실행
    public String index(
        @ModelAttribute BookSearchRequest request,  // 사용자 입력
        Pageable pageable,                         // 페이지 정보
        Model model                                 // 모델 (화면에 전달할 데이터)
    ) {
        // 1. 서비스 호출
        BookSearchResult result = bookSearchService.searchBooks(pageable, request);

        // 2. 모델에 데이터 담기
        model.addAttribute("books", result.getBooks());
        model.addAttribute("page", result.getPage());

        // 3. 뷰 이름 반환 (HTML 파일 이름)
        return "index";  // → templates/index.html을 찾음
    }
}
```

---

## 4. 구현 가이드 (Step-by-Step)

### STEP 1: Controller 만들기

사용자의 요청을 처리하고 데이터를 화면에 전달합니다.

**BookSearchController.java**
```java
package com.nhnacademy.library.front.web;

import com.nhnacademy.library.core.book.dto.BookSearchRequest;
import com.nhnacademy.library.core.book.dto.BookSearchResult;
import com.nhnacademy.library.core.book.service.search.BookSearchService;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Page;
import org.springframework.data.web.PageableDefault;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;

/**
 * 도서 검색 컨트롤러
 *
 * 사용자의 검색 요청을 처리하고 결과를 화면에 전달합니다.
 */
@Controller
@RequiredArgsConstructor
public class BookSearchController {

    private final BookSearchService bookSearchService;

    /**
     * 메인 페이지 및 검색 처리
     *
     * @param request 검색 조건 (키워드, ISBN 등)
     * @param pageable 페이징 정보 (페이지 번호, 크기)
     * @param model 모델 (데이터를 담을 상자)
     * @return 뷰 이름
     */
    @GetMapping("/")
    public String index(
            @ModelAttribute BookSearchRequest request,
            @PageableDefault(size = 24) Pageable pageable,  // 기본 24개씩
            Model model
    ) {
        // 서비스 호출
        BookSearchResult result = bookSearchService.searchBooks(pageable, request);

        // 모델에 데이터 담기
        model.addAttribute("books", result.getBooks().getContent());
        model.addAttribute("page", result.getBooks());
        model.addAttribute("request", request);

        // 뷰 반환
        return "index/index";  // templates/index/index.html
    }
}
```

> **📝 어노테이션 설명**
>
> - `@Controller`: 이 클래스가 웹 요청을 처리함
> - `@GetMapping`: HTTP GET 요청을 처리함
> - `@ModelAttribute`: 요청 파라미터를 객체에 담아줌
> - `Model`: 컨트롤러에서 뷰로 데이터를 전달하는 객체

---

### STEP 2: 레이아웃(Layout) 만들기

모든 페이지에 공통으로 들어갈 상단/하단을 정의합니다.

**templates/layouts/default.html**
```html
<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout">
<head>
    <meta charset="UTF-8">
    <title>AI 도서관</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
          rel="stylesheet">

    <!-- Tabler CSS -->
    <link href="https://cdn.jsdelivr.net/npm/@tabler/core@1.0.0-beta17/dist/css/tabler.min.css"
          rel="stylesheet">
</head>
<body>
    <!-- 공통 상단 (헤더) -->
    <header th:replace="~{fragments/header :: header}"></header>

    <!-- 메인 콘텐츠 영역 -->
    <main class="container my-4">
        <!-- 각 페이지의 내용이 들어갈 자리 -->
        <div layout:fragment="content"></div>
    </main>

    <!-- 공통 하단 (푸터) -->
    <footer th:replace="~{fragments/footer :: footer}"></footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
```

**설명:**
- `layout:fragment="content"`: 각 페이지의 내용이 여기에 들어갑니다
- `th:replace`: 다른 HTML 조각을 가져옵니다

---

### STEP 3: 프래그먼트(Fragment) 만들기

재사용 가능한 UI 조각을 따로 만듭니다.

**templates/fragments/header.html**
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
</head>
<body>

<!-- 헤더 프래그먼트 정의 -->
<th:block th:fragment="header">
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <!-- 로고 -->
            <a class="navbar-brand" href="/">
                AI 도서관
            </a>

            <!-- 메뉴 -->
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="/">도서 검색</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
</th:block>

</body>
</html>
```

---

### STEP 4: 검색 페이지 만들기

실제 검색 화면을 구현합니다. **[library.java21.net](https://library.java21.net)** 사이트를 참고하여 다음 요소들을 포함합니다:

1. **검색 방식 선택**: ISBN 또는 키워드 선택
2. **AI 로딩 메시지**: 검색 중일 때 표시
3. **검색 결과**: 표지, 제목, 저자, 출판사, ISBN 정보

**templates/index/index.html**
```html
<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>도서 검색</title>
    <!-- 필요시 CSS 추가 (디자인은 각자 구현) -->
    <style>
        /* 기본 스타일 예시 */
        .search-form { margin: 20px 0; }
        .book-list { margin-top: 30px; }
        .book-item { margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; }
        .loading { display: none; text-align: center; color: #666; }
    </style>
</head>
<body>

    <!-- 페이지 헤더 -->
    <header>
        <h1>AI 도서관</h1>
    </header>

    <!-- 검색 폼 -->
    <form th:action="@{/}" method="get" class="search-form">
        <!-- 검색 방식 선택 (ISBN 또는 키워드) -->
        <select name="searchType">
            <option value="keyword" th:selected="${request.searchType == null or request.searchType == 'keyword'}">키워드</option>
            <option value="isbn" th:selected="${request.searchType == 'isbn'}">ISBN</option>
        </select>

        <!-- 검색어 입력 -->
        <input type="text"
               name="keyword"
               placeholder="검색어를 입력하세요"
               th:value="${request.keyword}">

        <!-- 검색 버튼 -->
        <button type="submit">검색</button>
    </form>

    <!-- AI 로딩 메시지 (검색 중일 때 표시) -->
    <div id="loading" class="loading">
        AI가 최적의 도서를 찾고 답변을 생성 중입니다...<br>
        이 과정은 수 초가 걸릴 수 있습니다.
    </div>

    <!-- 검색 결과 요약 -->
    <div th:if="${page != null and page.totalElements > 0}">
        총 <span th:text="${page.totalElements}">0</span>권의 도서가 검색되었습니다.
        검색 소요 시간: <span th:text="${searchTime}">0.0</span>s
    </div>

    <!-- 검색 결과 목록 -->
    <div class="book-list">
        <!-- 결과가 없을 때 -->
        <div th:if="${books == null or books.empty}">
            <p>검색 결과가 없습니다.</p>
        </div>

        <!-- 도서 목록 반복 -->
        <div class="book-item" th:each="book : ${books}">
            <!-- 표지 이미지 (없을 경우 대체 텍스트) -->
            <img th:src="${book.imageUrl}" th:alt="${book.title}" style="max-width: 100px; float: left; margin-right: 15px;">

            <!-- 도서 정보 -->
            <h3 th:text="${book.title}">제목</h3>
            <p>
                <strong>저자:</strong> <span th:text="${book.authorName}">저자명</span><br>
                <strong>출판사:</strong> <span th:text="${book.publisherName}">출판사</span><br>
                <strong>출판일:</strong> <span th:text="${book.firstPublishDate}">날짜</span><br>
                <strong>ISBN:</strong> <span th:text="${book.isbn}">ISBN</span>
            </p>
            <div style="clear: both;"></div>
        </div>
    </div>

    <!-- 페이징 -->
    <div th:if="${page != null and page.totalPages > 1}">
        <nav>
            <ul class="pagination">
                <!-- 이전 페이지 -->
                <li th:class="${page.first ? 'disabled' : ''}">
                    <a th:href="@{/(page=${page.number - 1}, keyword=${request.keyword}, searchType=${request.searchType})}">
                        이전
                    </a>
                </li>

                <!-- 페이지 번호들 -->
                <li th:each="pageNum : ${#numbers.sequence(0, page.totalPages - 1)}"
                    th:class="${pageNum == page.number ? 'active' : ''}">
                    <a th:href="@{/(page=${pageNum}, keyword=${request.keyword}, searchType=${request.searchType})}"
                       th:text="${pageNum + 1}">1</a>
                </li>

                <!-- 다음 페이지 -->
                <li th:class="${page.last ? 'disabled' : ''}">
                    <a th:href="@{/(page=${page.number + 1}, keyword=${request.keyword}, searchType=${request.searchType})}">
                        다음
                    </a>
                </li>
            </ul>
        </nav>
    </div>

    <!-- 로딩 표시 스크립트 -->
    <script>
        // 폼 제출 시 로딩 메시지 표시
        document.querySelector('form').addEventListener('submit', function() {
            document.getElementById('loading').style.display = 'block';
        });
    </script>

</body>
</html>
```

> **💡 design은 각자 구현**
>
> 위 예시는 **최소한의 기능 구현**을 위한 HTML 구조입니다.
>
> **디자인/스타일링은 각자 구현**해야 합니다:
> - Bootstrap, Tailwind CSS 등 사용 가능
> - Tabler 템플릿 활용 가능
> - 커스텀 CSS로 자유롭게 디자인 가능
>
> **library.java21.net 참고 포인트:**
> - 검색 방식 선택 셀렉트박스
> - AI 로딩 메시지
> - 도서 정보 표시 형식 (표지 + 상세정보)
> - 페이징 네비게이션

**Thymeleaf 주요 속성 설명:**

| 속성 | 설명 | 예시 |
|------|------|------|
| `th:text` | 텍스트 내용 설정 | `<span th:text="${book.title}">` |
| `th:if` | 조건부 렌더링 | `<div th:if="${book != null}">` |
| `th:each` | 반복문 | `<div th:each="book : ${books}">` |
| `th:href` | 링크 URL 설정 | `<a th:href="@{/books/{id}(id=${book.id})}">` |
| `th:value` | 입력값 설정 | `<input th:value="${request.keyword}">` |
| `th:src` | 이미지 src 설정 | `<img th:src="${book.imageUrl}">` |

---

## 5. 전체 흐름 이해하기

### 5.1. 사용자가 검색할 때의 흐름

```
1. 사용자: 브라우저에 "http://localhost:8080/" 입력
   ↓
2. 브라우저: GET / 요청을 서버로 전송
   ↓
3. Controller: index() 메서드 실행
   - 요청 파라미터를 BookSearchRequest에 담기
   - Service 호출
   ↓
4. Service: Repository에서 데이터 조회
   - 검색 조건에 맞는 도서 목록 조회
   - 결과 반환
   ↓
5. Controller: 조회된 데이터를 Model에 담기
   - model.addAttribute("books", 도서목록)
   - "index/index" 뷰 이름 반환
   ↓
6. Thymeleaf: HTML 템플릿 처리
   - ${books}를 실제 도서 데이터로 치환
   - 완성된 HTML 생성
   ↓
7. 서버: 완성된 HTML을 브라우저에 응답
   ↓
8. 브라우저: HTML 화면 렌더링
   - 사용자에게 검색 결과 표시
```

### 5.2. 폼 바인딩(Form Binding) 과정

```
[HTML 입력창]          [자바 객체]
<input name="keyword">   BookSearchRequest
    ↓                        ↑
사용자: "자바" 입력    값: "자바"
    ↓                        ↓
---------요청----------->
keyword=자바
```

Spring이 자동으로:
1. 요청 파라미터 읽기: `keyword=자바`
2. 객체에 값 담기: `request.setKeyword("자바")`

---

## 6. 실습 미션

### 미션 1: 검색 방식 선택 기능 구현

library.java21.net처럼 검색 방식(ISBN/키워드)을 선택할 수 있게 해보세요.

**힌트:**
- `<select>` 요소와 `searchType` 파라미터 활용
- Controller에서 `searchType` 값에 따라 검색 로직 분기

```html
<select name="searchType">
    <option value="keyword">키워드</option>
    <option value="isbn">ISBN</option>
</select>
```

### 미션 2: AI 로딩 메시지 구현

검색 버튼을 눌렀을 때 "AI가 최적의 도서를 찾고 답변을 생성 중입니다..." 메시지가 표시되게 해보세요.

**힌트:**
- JavaScript로 폼 제출 이벤트 감지
- 로딩 중일 때만 메시지 표시 (`display: none` → `display: block`)

```javascript
document.querySelector('form').addEventListener('submit', function() {
    document.getElementById('loading').style.display = 'block';
});
```

### 미션 3: 검색 결과 정보 표시

library.java21.net처럼 검색 결과 요약 정보를 표시해보세요.

- 책 권수: "총 157,118권의 도서가 검색되었습니다."
- 검색 소요 시간: "검색 소요 시간: 0.045s"

```html
<div>
    총 <span th:text="${page.totalElements}">0</span>권의 도서가 검색되었습니다.<br>
    검색 소요 시간: <span th:text="${searchTime}">0.0</span>s
</div>
```

### 미션 4: 페이징 구현

페이지 번호를 클릭해서 해당 페이지로 이동할 수 있게 해보세요.

**library.java21.net 스타일:**
```
* prev  * 1  * 2  * 3  * 4  * 5  * next
```

**힌트:**
- `#numbers.sequence()`로 페이지 번호 목록 생성
- 현재 페이지는 `active` 클래스 적용

### 미션 5: (선택) 디자인 개선

각자 원하는 스타일로 UI를 꾸며보세요.

**선택 가능한 도구:**
- Bootstrap 5
- Tailwind CSS
- Tabler 템플릿
- 커스텀 CSS

> **⚠️ 주의: 디자인은 평가 항목이 아닙니다**
>
> 이 문서의 목표는 **기능 구현**입니다. 예쁜 디자인은 선택 사항입니다.

---

## 7. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

- [ ] 템플릿 엔진이 무엇인지 설명할 수 있다
- [ ] Thymeleaf 기본 속성을 사용할 수 있다
- [ ] MVC 패턴의 각 요소 역할을 안다
- [ ] Controller에서 뷰로 데이터를 전달할 수 있다
- [ ] 검색 폼을 만들고 폼 데이터를 전송할 수 있다
- [ ] Thymeleaf 반복문(`th:each`)으로 목록을 표시할 수 있다
- [ ] 페이징 처리를 구현할 수 있다
- [ ] library.java21.net 사이트의 UI 구조를 이해한다

---

## 8. 다음 단계

다음 문서에서는 **검색 성능 최적화**를 배웁니다:
- 인덱스(Index)로 검색 속도 높이기
- 전문 검색(Full Text Search) 도입하기
- GIN 인덱스 이해하기

[다음: 04. 성능 최적화 →](04.search-optimization-and-indexing.md)
