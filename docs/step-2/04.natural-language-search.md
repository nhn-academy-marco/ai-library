# 04. 자연어 검색: 의미 기반 벡터 검색 구현

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- Week 2의 01, 02, 03 문서 내용 (벡터 검색의 필요성, pgvector, 임베딩 생성)
- 코사인 유사도, L2 거리 기초 개념
- QueryDSL 기본 사용법
- Week 1의 검색 구현 경험

---

## 1. 개요

이제 '키워드'가 아닌 '의미'로 도서를 찾을 수 있습니다!

**예시:**
```
[키워드 검색]
사용자: "컴퓨터 구조"
결과: "컴퓨터 구조"라는 글자가 있는 책만 찾음

[의미 기반 검색]
사용자: "컴퓨터가 어떻게 작동하는지 알고 싶어"
결과: 컴퓨터 구조, 컴퓨터 아키텍처, 시스템 프로그래밍...
      → 의미가 비슷한 책들을 찾음 ✅
```

**이 문서에서 배울 내용:**
- 벡터 검색이 실제로 어떻게 작동하는지
- 코사인 유사도와 L2 거리의 차이
- PostgreSQL pgvector 연산자 사용법
- 사용자 검색어를 벡터로 변환하여 검색하기
- 유사도 점수로 결과 정렬하기

> **중요: 의미 기반 검색의 장점**
>
> 키워드 검색:
> - "사과" → "사과"라는 글자가 있는 책만 찾음 ❌
>
> 벡터 검색:
> - "빨간 과일" → 사과, 딸기, 체리 등을 찾을 수 있음 ✅
> - "건강에 좋은 과일" → 사과, 배, 포도 등을 찾을 수 있음 ✅

---

## 2. 핵심 개념 이해

### 2.1. 벡터 검색 원리

**비유로 이해하기:**
```
도서관에서 "행복에 관한 책"을 찾는 상황을 상상해 보세요.

[키워드 검색]
"행복"이라는 단어가 제목에 있는 책을 찾아요
→ "행복한 철학", "행복의 발견"
→ "즐거움의 원리", "기쁨의 심리학"

[벡터 검색]
"행복"과 비슷한 의미를 가진 책을 찾아요
→ "행복한 철학" (가장 유사)
→ "즐거움의 원리" (비슷한 의미)
→ "기쁨의 심리학" (관련 있는 의미)
```

**벡터 검색 과정:**
```
1. 사용자 검색어: "컴퓨터 작동 원리"
      ↓
2. AI 모델로 벡터 변환
   [0.12, -0.5, 0.88, ...]
      ↓
3. DB의 모든 도서 벡터와 비교
   도서1: [0.13, -0.48, 0.90, ...] → 95% 유사
   도서2: [0.50, 0.30, -0.20, ...] → 20% 유사
   도서3: [0.10, -0.52, 0.85, ...] → 98% 유사
      ↓
4. 유사도 순서대로 결과 반환
   1위: 도서3 (98%)
   2위: 도서1 (95%)
   3위: 도서2 (20%)
```

### 2.2. 코사인 유사도 (Cosine Similarity)

두 벡터 사이의 **각도**를 측정합니다.

**비유로 이해하기:**
```
두 사람이 같은 방향을 바라보고 있는지 확인하는 것과 같아요.

[같은 방향]
사람A: ↑ (북쪽)
사람B: ↑ (북쪽)
→ 각도: 0도 → 유사도: 1.0 (100%)

[비슷한 방향]
사람A: ↑ (북쪽)
사람B: ↗ (북동쪽)
→ 각도: 45도 → 유사도: 0.7 (70%)

[반대 방향]
사람A: ↑ (북쪽)
사람B: ↓ (남쪽)
→ 각도: 180도 → 유사도: -1.0 (-100%)
```

**특징:**
- 값 범위: -1 ~ 1
- 1에 가까울수록 유사함
- 0이면 관계 없음
- -1이면 반대 의미

**문서 검색에 적합한 이유:**
```
문서 A: "자바는 프로그래밍 언어입니다"
문서 B: "자바로 프로그래밍을 합니다"
문서 C: "자바는 커피의 일종입니다"

A와 B는 프로그래밍 관련 → 유사도 높음
A와 C는 전혀 다른 주제 → 유사도 낮음
```

### 2.3. L2 거리 (Euclidean Distance)

두 벡터 사이의 **직선 거리**를 측정합니다.

**비유로 이해하기:**
```
지도상의 두 위치 사이의 거리를 재는 것과 같아요.

[가까운 거리]
서울역 ↔ 부산역: 400km
→ 거리: 400km → 유사함

[먼 거리]
서울역 ↔ 런던: 8,000km
→ 거리: 8,000km → 다름
```

**특징:**
- 값 범위: 0 ~ 무한대
- 0에 가까울수록 유사함
- 값이 클수록 다름

### 2.4. 코사인 유사도 vs L2 거리

| 특징 | 코사인 유사도 | L2 거리 |
|------|---------------|---------|
| 측정 대상 | 방향 (각도) | 거리 |
| 값 범위 | -1 ~ 1 | 0 ~ ∞ |
| 유사할 때 | 1에 가까움 | 0에 가까움 |
| 용도 | 텍스트 검색 | 이미지 검색 |
| 장점 | 길이 무시, 방향 중시 | 절대적 차이 고려 |

**비유로 이해하기:**
```
[코사인 유사도]
"나는 자바를 좋아해" (문장 1)
"저는 자바를 사랑해요" (문장 2)
→ 의미 방향이 같음 → 유사도 높음

[L2 거리]
키 180cm, 몸무게 70kg (사람 1)
키 182cm, 몸무게 72kg (사람 2)
→ 수치가 비슷함 → 거리 가까움 ✅
```

### 2.5. pgvector 연산자

PostgreSQL에서 벡터 검색을 위해 제공하는 특수 연산자입니다.

| 연산자 | 의미 | 설명 | 사용 예시 |
|--------|------|------|-----------|
| `<=>` | 코사인 거리 | 1 - 코사인 유사도 | 값이 작을수록 유사 |
| `<->` | L2 거리 | 유클리드 거리 | 값이 작을수록 유사 |
| `<#>` | 내적 | 두 벡터의 내적 | 값이 클수록 유사 |

**SQL 사용 예시:**
```sql
-- 코사인 유사도 검색 (가장 유사한 순)
SELECT title, 1 - (embedding <=> '[0.1, 0.2, ...]') as similarity
FROM books
WHERE embedding IS NOT NULL
ORDER BY embedding <=> '[0.1, 0.2, ...]'
LIMIT 10;

-- L2 거리 검색 (가장 가까운 순)
SELECT title, embedding <-> '[0.1, 0.2, ...]' as distance
FROM books
WHERE embedding IS NOT NULL
ORDER BY embedding <-> '[0.1, 0.2, ...]'
LIMIT 10;
```

---

## 3. 구현 가이드 (Step-by-Step)

### STEP 1: 커스텀 함수 등록

Hibernate가 pgvector 연산자를 인식할 수 있도록 등록합니다.

**PostgreSQLFunctionContributor.java**
```java
package com.nhnacademy.library.core.config;

import org.hibernate.boot.model.FunctionContributor;
import org.hibernate.boot.model.FunctionContributions;
import org.hibernate.type.StandardBasicTypes;

/**
 * PostgreSQL 커스텀 함수 등록
 *
 * 벡터 검색 관련 함수를 Hibernate에서 사용할 수 있도록 등록합니다.
 */
public class PostgreSQLFunctionContributor implements FunctionContributor {

    @Override
    public void contributeFunctions(FunctionContributions functionContributions) {
        // 코사인 유사도 함수 등록
        // 1 - (embedding <=> vector) : 코사인 거리를 유사도로 변환
        functionContributions.getFunctionRegistry()
                .registerPattern(
                        "vector_cosine_similarity",
                        "(1.0 - (embedding <=> cast(?1 as vector)))",
                        functionContributions.getTypeConfiguration()
                                .getBasicTypeRegistry()
                                .resolve(StandardBasicTypes.DOUBLE)
                );
    }
}
```

**SPI 등록 파일:** `src/main/resources/META-INF/services/org.hibernate.boot.model.FunctionContributor`
```
com.nhnacademy.library.core.config.PostgreSQLFunctionContributor
```

### STEP 2: 검색어 벡터화

사용자가 입력한 검색어를 AI 모델로 벡터로 변환합니다.

**BookSearchService.java**
```java
package com.nhnacademy.library.core.book.service.search;

import com.nhnacademy.library.core.book.dto.BookSearchRequest;
import com.nhnacademy.library.core.book.dto.BookSearchResponse;
import com.nhnacademy.library.core.book.repository.BookRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

/**
 * 도서 검색 서비스
 *
 * 키워드 검색과 벡터 검색을 모두 지원합니다.
 */
@Service
@RequiredArgsConstructor
public class BookSearchService {

    private final BookRepository bookRepository;
    private final EmbeddingModel embeddingModel;

    /**
     * 도서 검색
     *
     * 검색 타입에 따라 키워드 검색 또는 벡터 검색을 수행합니다.
     */
    public Page<BookSearchResponse> searchBooks(
            Pageable pageable,
            BookSearchRequest request
    ) {
        // 벡터 검색 모드인 경우
        if (request.searchType() == SearchType.VECTOR) {
            // 1. 검색어를 벡터로 변환
            float[] vector = embeddingModel.embed(request.keyword());

            // 2. 벡터를 요청에 설정
            BookSearchRequest vectorRequest = new BookSearchRequest(
                    request.keyword(),
                    request.isbn(),
                    SearchType.VECTOR,
                    vector
            );

            // 3. 벡터 검색 실행
            return bookRepository.vectorSearch(pageable, vectorRequest);
        }

        // 키워드 검색 실행
        return bookRepository.search(pageable, request);
    }
}
```

### STEP 3: 벡터 검색 쿼리 구현

QueryDSL로 벡터 검색 쿼리를 작성합니다.

**BookRepositoryImpl.java**
```java
package com.nhnacademy.library.core.book.repository;

import com.nhnacademy.library.core.book.dto.BookSearchRequest;
import com.nhnacademy.library.core.book.dto.BookSearchResponse;
import com.nhnacademy.library.core.book.entity.QBook;
import com.querydsl.core.types.Projections;
import com.querydsl.core.types.dsl.Expressions;
import com.querydsl.core.types.dsl.NumberTemplate;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * 도서 저장소 구현체
 *
 * 벡터 검색을 포함한 다양한 검색 기능을 제공합니다.
 */
@Repository
@RequiredArgsConstructor
public class BookRepositoryImpl implements BookRepositoryCustom {

    private final JPAQueryFactory queryFactory;
    private static final QBook book = QBook.book;

    /**
     * 벡터 검색
     *
     * 코사인 유사도를 기반으로 가장 유사한 도서를 찾습니다.
     */
    @Override
    public Page<BookSearchResponse> vectorSearch(
            Pageable pageable,
            BookSearchRequest request
    ) {
        // 1. 벡터를 문자열로 변환
        String vectorString = arrayToVectorString(request.vector());

        // 2. 코사인 유사도 계산 템플릿 생성
        NumberTemplate<Double> similarityTemplate = Expressions.numberTemplate(
                Double.class,
                "function('vector_cosine_similarity', {0})",
                vectorString
        );

        // 3. 검색 쿼리 실행
        List<BookSearchResponse> results = queryFactory
                .select(Projections.constructor(
                        BookSearchResponse.class,
                        book.id,
                        book.isbn,
                        book.title,
                        book.authorName,
                        book.publisherName,
                        book.imageUrl,
                        book.bookContent,
                        similarityTemplate.as("similarity")  // 유사도 점수 포함
                ))
                .from(book)
                .where(book.embedding.isNotNull())  // 임베딩이 있는 도서만
                .orderBy(similarityTemplate.desc())  // 유사도 높은 순 정렬
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .fetch();

        // 4. 전체 개수 조회
        long total = queryFactory
                .select(book.count())
                .from(book)
                .where(book.embedding.isNotNull())
                .fetchOne();

        // 5. 페이지로 반환
        return new PageImpl<>(results, pageable, total);
    }

    /**
     * float 배열을 PostgreSQL 벡터 문자열로 변환
     *
     * 예: [0.1f, 0.2f, 0.3f] → "[0.1, 0.2, 0.3]"
     */
    private String arrayToVectorString(float[] vector) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < vector.length; i++) {
            sb.append(vector[i]);
            if (i < vector.length - 1) {
                sb.append(", ");
            }
        }
        sb.append("]");
        return sb.toString();
    }
}
```

### STEP 4: 응답 DTO에 유사도 추가

검색 결과에 유사도 점수를 포함합니다.

**BookSearchResponse.java**
```java
package com.nhnacademy.library.core.book.dto;

import java.util.UUID;

/**
 * 도서 검색 응답 DTO
 *
 * 벡터 검색 시 유사도 점수를 포함합니다.
 */
public record BookSearchResponse(
        UUID id,
        String isbn,
        String title,
        String authorName,
        String publisherName,
        String imageUrl,
        String bookContent,
        Double similarity  // 벡터 검색 시 유사도 점수 (0 ~ 1)
) {
    /**
     * 유사도를 퍼센트로 변환
     *
     * @return "95%" 형식의 문자열
     */
    public String getSimilarityPercent() {
        if (similarity == null) {
            return null;
        }
        return String.format("%.1f%%", similarity * 100);
    }
}
```

### STEP 5: UI에 유사도 표시

검색 결과 화면에 유사도를 표시합니다.

**index.html (Thymeleaf)**
```html
<div class="col-md-3 mb-3" th:each="book : ${books}">
    <div class="card h-100">
        <!-- 도서 카드 내용 -->
        <img th:src="${book.imageUrl}" class="card-img-top">
        <div class="card-body">
            <h5 class="card-title" th:text="${book.title}">제목</h5>
            <p class="card-text" th:text="${book.authorName}">저자</p>

            <!-- 벡터 검색인 경우 유사도 표시 -->
            <div th:if="${book.similarity != null}">
                <small class="badge bg-primary">
                    유사도: <span th:text="${book.similarityPercent}">95%</span>
                </small>
            </div>
        </div>
    </div>
</div>
```

---

## 4. 전체 시스템 흐름

```
[사용자]                      [서버]                       [DB]
    │                           │                            │
    │  1. 검색어 입력             │                            │
    │  "컴퓨터 작동 원리"         │                            │
    ├──────────────────────────>│                            │
    │                           │                            │
    │                           │  2. 검색어 → 벡터 변환       │
    │                           ├─────────────────────────>│
    │                           │  "컴퓨터 작동 원리"          │
    │                           │  [AI 서버]                  │
    │                           │<─────────────────────────┤
    │                           │  [0.12, -0.5, 0.88, ...]   │
    │                           │                            │
    │                           │  3. 벡터 유사도 검색         │
    │                           ├─────────────────────────>│
    │                           │  embedding <=> [0.12, ...] │
    │                           │                            │
    │                           │  4. 유사도 계산              │
    │                           │  도서1: 95%                │
    │                           │  도서2: 20%                │
    │                           │  도서3: 98%                │
    │                           │                            │
    │                           │  5. 결과 반환               │
    │                           │<─────────────────────────┤
    │                           │  [도서3(98%), 도서1(95%)]  │
    │                           │                            │
    │  6. 결과 표시               │                            │
    │<──────────────────────────┤  1. 컴퓨터 아키텍처 (98%)   │
    │  1. 컴퓨터 아키텍처 (98%)   │  2. 컴퓨터 구조 (95%)       │
    │  2. 컴퓨터 구조 (95%)       │                            │
```

---

## 5. 실습 미션

### 미션 1: 코사인 유사도 계산

```java
@Test
void testCosineSimilarity() {
    float[] vector1 = {1.0f, 0.0f};  // 오른쪽
    float[] vector2 = {0.707f, 0.707f};  // 대각선 45도

    // 코사인 유사도 계산
    double similarity = calculateCosineSimilarity(vector1, vector2);

    // 예상: 0.707 (45도)
    System.out.println("유사도: " + similarity);
}

private double calculateCosineSimilarity(float[] v1, float[] v2) {
    double dotProduct = 0;
    double norm1 = 0;
    double norm2 = 0;

    for (int i = 0; i < v1.length; i++) {
        dotProduct += v1[i] * v2[i];
        norm1 += v1[i] * v1[i];
        norm2 += v2[i] * v2[i];
    }

    return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
}
```

### 미션 2: 벡터 변환 확인

```java
@Test
void testTextToVector() {
    String text = "자바 프로그래밍";

    // AI 모델로 벡터 변환
    float[] vector = embeddingModel.embed(text);

    // 차원 확인 (BGE-M3: 1024)
    System.out.println("차원 수: " + vector.length);
    System.out.println("첫 5개 값: " +
        Arrays.copyOf(vector, 5));
}
```

### 미션 3: 벡터 검색 결과 확인

```sql
-- PostgreSQL에서 직접 벡터 검색 테스트
SELECT
    title,
    1 - (embedding <=> '[0.1, 0.2, 0.3, ...]') as similarity
FROM books
WHERE embedding IS NOT NULL
ORDER BY embedding <=> '[0.1, 0.2, 0.3, ...]'
LIMIT 10;
```

---

## 6. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

- [ ] 벡터 검색이 작동하는 원리를 설명할 수 있다
- [ ] 코사인 유사도와 L2 거리의 차이를 안다
- [ ] pgvector 연산자(`<=>`, `<->`)를 이해한다
- [ ] 사용자 검색어를 벡터로 변환할 수 있다
- [ ] QueryDSL로 벡터 검색 쿼리를 작성할 수 있다
- [ ] 코사인 유사도를 계산할 수 있다
- [ ] 유사도 점수로 결과를 정렬할 수 있다
- [ ] 검색 결과에 유사도를 표시할 수 있다

---

## 7. 다음 단계

다음 문서에서는 **하이브리드 검색**을 배웁니다:
- 키워드 검색과 벡터 검색을 결합하는 방법
- 각 검색 결과에 가중치 부여하기
- 검색 품질 극대화 전략

[다음: 05. 하이브리드 검색 →](05.hybrid-search.md)
