# 03. 임베딩 생성: 텍스트를 벡터로 변환하기

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- Week 1의 배치 처리 이해 (CSV 적재 배치)
- Week 2의 01, 02 문서 내용 (벡터 검색의 필요성, pgvector 설정)
- HTTP API 기초 개념
- Java 문자열 처리 기초

---

## 1. 개요

도서 데이터베이스에 벡터를 저장할 컬럼을 만들었다면(02 문서), 이제 그 컬럼에 들어갈 **벡터(Embedding)**를 실제로 생성해야 합니다.

**이 문서에서 배울 내용:**
- 임베딩이 실제로 어떻게 생성되는지
- 텍스트 전처리가 왜 필요한지
- Spring AI로 외부 AI 모델을 호출하는 방법
- 대량 데이터의 임베딩을 효율적으로 생성하는 배치 처리

> **중요: 임베딩 생성의 중요성**
>
> 벡터 검색의 핵심은 "좋은 임베딩"입니다.
>
> - 전처리를 안 하면: `&nbsp;<b>자바</b>` → 임베딩 품질 저하
> - 전처리를 하면: `자바` → 깔끔한 임베딩
>
> 쓰레기가 들어가면 쓰레기가 나옵니다!

---

## 2. 핵심 개념 이해

### 2.1. 임베딩 생성 과정

**비유로 이해하기:**
```
인간 언어를 AI 언어로 번역하는 과정과 같아요.

[한국어]
"자바는 프로그래밍 언어입니다"
      ↓
[번역기: AI 모델]
"번역 중..."
      ↓
[AI 언어: 벡터]
[0.12, -0.5, 0.88, 0.23, ..., 0.45]
      ↑ 총 1024개의 숫자
```

**실제 API 호출 예시:**
```bash
# AI 서버에 텍스트 보내기
curl https://emb.java21.net/v1/embeddings \
  -H "Content-Type: application/json" \
  -d '{
    "model": "bge-m3",
    "input": "자바는 프로그래밍 언어입니다"
  }'

# 응답
{
  "data": [
    {
      "embedding": [0.12, -0.5, 0.88, ...]  ← 1024개의 숫자
    }
  ]
}
```

### 2.2. 임베딩 대상 데이터 선정

모든 정보를 무작정 임베딩하는 게 아니라, **검색에 중요한 정보**를 선별해야 합니다.

**비유로 이해하기:**
```
사람을 소개할 때 어떤 정보를 말할까요?

[필수 정보]
- 이름: "철수"
- 직업: "학생"
- 특징: "친절함"

[선택 정보]
- 좋아하는 음식: "피자"
- 취미: "독서"

도서도 마찬가지입니다:
- 제목, 저자, 내용 → 필수
- ISBN, 페이지 수 → 선택
```

**도서 임베딩에 사용할 필드:**
```
[제목] 자바의 정석
[저자] 남궁성
[내용] 자바의 기초부터 심화까지

→ 하나로 합쳐서 임베딩:
"[제목] 자바의 정석 [저자] 남궁성 [내용] 자바의 기초부터 심화까지"
```

### 2.3. 텍스트 전처리(Preprocessing)

AI 모델에 보내기 전에 텍스트를 깔끔하게 정리하는 과정입니다.

**비유로 이해하기:**
```
요리를 하기 전 재료를 손질하는 것과 같아요.

[손질 전]
감자 + 흙먼지 + 썩은 부분

[손질 후]
깨끗한 감자

요리(임베딩)에 들어가기 전에 반드시 손질(전처리)이 필요해요!
```

**전처리 단계:**

1. **HTML 엔티티 디코딩**
   ```
   `&nbsp;` → 공백
   `&amp;` → &
   `&lt;` → <
   ```

2. **HTML 태그 제거**
   ```
   `<p><b>자바</b>의 정석</p>`
   → ` 자바 의 정석 `
   ```

3. **특수문자 제거**
   ```
   `자바!! 프로그래밍@@`
   → `자바 프로그래밍`
   ```

4. **공백 정규화**
   ```
   `자바    프로그래밍`
   → `자바 프로그래밍`
   ```

5. **소문자 변환**
   ```
   `Java Programming`
   → `java programming`
   ```

### 2.4. 배치 처리(Batch Processing)

한 번에 하나씩 처리하지 않고, 여러 개를 한꺼번에 처리하는 방식입니다.

**비유로 이해하기:**
```
[하나씩 처리]
편지 100통을 보낼 때:
1통 보내고 → 기다리고 → 1통 보내고 → ...
→ 100번 기다림

[배치 처리]
편지 100통을 한꺼번에 우체부에 맡기기:
100통 묶음으로 전달
→ 1번만 기다림
```

**성능 비교:**
```
1개씩 100번 호출:
- 네트워크 지연: 100ms × 100 = 10,000ms (10초)

10개씩 10번 호출:
- 네트워크 지연: 100ms × 10 = 1,000ms (1초)
→ 10배 빠름!
```

---

## 3. 구현 가이드 (Step-by-Step)

### STEP 1: Spring AI 설정

Spring AI는 AI 서비스와 쉽게 연동할 수 있는 도구입니다.

**의존성 추가 (pom.xml):**
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-starter-model-openai</artifactId>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-bom</artifactId>
            <version>1.0.1</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

**API 설정 (application.properties):**
```properties
# 임베딩 API 설정
spring.ai.openai.base-url=https://emb.java21.net
spring.ai.openai.api-key=dummy
spring.ai.openai.embedding.options.model=bge-m3
```

**설정 클래스:**
```java
@Configuration
public class EmbeddingConfig {

    @Bean
    public EmbeddingModel embeddingModel() {
        return new OpenAiEmbeddingModel(
            new OpenAiApi("https://emb.java21.net", "dummy")
        );
    }
}
```

### STEP 2: 전처리 유틸리티 구현

텍스트를 깔끔하게 만드는 유틸리티 클래스를 만듭니다.

**TextPreprocessor.java**
```java
package com.nhnacademy.library.core.book.util;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringEscapeUtils;

/**
 * 텍스트 전처리 유틸리티
 *
 * AI 모델에 보내기 전 텍스트를 정제합니다.
 */
public class TextPreprocessor {

    private static final String HTML_TAG_PATTERN = "<[^>]*>";
    private static final String SPECIAL_CHAR_PATTERN = "[^가-힣a-zA-Z0-9\\s]";
    private static final String SPACE_PATTERN = "\\s+";

    /**
     * 텍스트 전처리
     *
     * 1. HTML 엔티티 디코딩
     * 2. HTML 태그 제거
     * 3. 특수문자 제거
     * 4. 공백 정규화
     * 5. 소문자 변환
     */
    public static String preprocess(String text) {
        // 1. null 체크
        if (!StringUtils.hasText(text)) {
            return "";
        }

        // 2. HTML 엔티티 디코딩
        String decoded = StringEscapeUtils.unescapeHtml4(text);

        // 3. HTML 태그 제거
        String cleaned = decoded.replaceAll(HTML_TAG_PATTERN, " ");

        // 4. 특수문자 제거
        cleaned = cleaned.replaceAll(SPECIAL_CHAR_PATTERN, "");

        // 5. 연속된 공백 통합
        cleaned = cleaned.replaceAll(SPACE_PATTERN, " ");

        // 6. 앞뒤 공백 제거 및 소문자 변환
        return cleaned.trim().toLowerCase();
    }
}
```

### STEP 3: 임베딩 서비스 구현

AI 모델을 호출하는 서비스를 만듭니다.

**EmbeddingService.java**
```java
package com.nhnacademy.library.core.book.service;

import lombok.RequiredArgsConstructor;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.ai.embedding.EmbeddingResponse;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 임베딩 생성 서비스
 *
 * AI 모델을 호출하여 텍스트를 벡터로 변환합니다.
 */
@Service
@RequiredArgsConstructor
public class EmbeddingService {

    private final EmbeddingModel embeddingModel;

    /**
     * 단일 텍스트 임베딩
     */
    public float[] getEmbedding(String text) {
        EmbeddingResponse response = embeddingModel.embedForResponse(List.of(text));
        return response.getResults().get(0).getOutput();
    }

    /**
     * 배치 임베딩 (여러 텍스트를 한 번에 처리)
     */
    public List<float[]> getEmbeddings(List<String> texts) {
        EmbeddingResponse response = embeddingModel.embedForResponse(texts);
        return response.getResults().stream()
                .map(result -> result.getOutput())
                .toList();
    }
}
```

### STEP 4: 도서 임베딩 서비스 구현

도서 데이터를 가져와서 임베딩을 생성하고 저장하는 서비스를 만듭니다.

**BookEmbeddingService.java**
```java
package com.nhnacademy.library.core.book.service;

import com.nhnacademy.library.core.book.entity.Book;
import com.nhnacademy.library.core.book.repository.BookRepository;
import com.nhnacademy.library.core.book.util.TextPreprocessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;

/**
 * 도서 임베딩 생성 서비스
 *
 * 도서 데이터를 조회하고 임베딩을 생성하여 저장합니다.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class BookEmbeddingService {

    private final BookRepository bookRepository;
    private final EmbeddingService embeddingService;

    /**
     * 임베딩이 없는 도서들의 임베딩 생성
     *
     * @param 처리한 도서 수
     */
    @Transactional
    public int generateEmbeddings() {
        // 1. 임베딩이 없는 도서 조회
        List<Book> books = bookRepository.findTop10ByEmbeddingIsNull();

        if (books.isEmpty()) {
            log.info("임베딩을 생성할 도서가 없습니다.");
            return 0;
        }

        log.info("임베딩 생성 시작: {}권", books.size());

        // 2. 전처리된 텍스트 준비
        List<Book> validBooks = new ArrayList<>();
        List<String> texts = new ArrayList<>();

        for (Book book : books) {
            String combinedText = createCombinedText(book);

            if (combinedText != null && !combinedText.isBlank()) {
                validBooks.add(book);
                texts.add(combinedText);
            }
        }

        if (texts.isEmpty()) {
            log.warn "유효한 텍스트가 없습니다.");
            return 0;
        }

        // 3. 배치 임베딩 생성
        List<float[]> embeddings = embeddingService.getEmbeddings(texts);

        // 4. 도서에 임베딩 저장
        for (int i = 0; i < validBooks.size(); i++) {
            Book book = validBooks.get(i);
            float[] embedding = embeddings.get(i);
            book.updateEmbedding(embedding);

            log.debug("임베딩 생성 완료: {} (차원: {})",
                    book.getTitle(), embedding.length);
        }

        log.info("임베딩 생성 완료: {}권", validBooks.size());
        return validBooks.size();
    }

    /**
     * 도서 정보를 하나의 텍스트로 결합
     *
     * 형식: [제목] {title} [저자] {author} [내용] {content}
     */
    private String createCombinedText(Book book) {
        StringBuilder sb = new StringBuilder();

        // 제목
        if (book.getTitle() != null) {
            String title = TextPreprocessor.preprocess(book.getTitle());
            sb.append("[제목] ").append(title).append(" ");
        }

        // 저자
        if (book.getAuthorName() != null) {
            String author = TextPreprocessor.preprocess(book.getAuthorName());
            sb.append("[저자] ").append(author).append(" ");
        }

        // 내용
        if (book.getBookContent() != null) {
            String content = TextPreprocessor.preprocess(book.getBookContent());
            sb.append("[내용] ").append(content);
        }

        return sb.toString();
    }
}
```

### STEP 5: 스케줄러 구현

주기적으로 임베딩을 생성하도록 스케줄러를 만듭니다.

**스케줄링 활성화:**
```java
@EnableScheduling  // 스케줄링 기능 활성화
@SpringBootApplication
public class NhnAcademyAiLibraryApplication {
    public static void main(String[] args) {
        SpringApplication.run(NhnAcademyAiLibraryApplication.class, args);
    }
}
```

**BookEmbeddingScheduler.java**
```java
package com.nhnacademy.library.batch.embedding.scheduler;

import com.nhnacademy.library.core.book.service.BookEmbeddingService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * 도서 임베딩 생성 스케줄러
 *
 * 주기적으로 임베딩이 없는 도서들의 임베딩을 생성합니다.
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class BookEmbeddingScheduler {

    private final BookEmbeddingService bookEmbeddingService;

    /**
     * 5초마다 임베딩 생성 실행
     */
    @Scheduled(fixedDelay = 5000)
    public void generateEmbeddings() {
        try {
            int count = bookEmbeddingService.generateEmbeddings();

            if (count > 0) {
                log.info("{}권의 도서 임베딩 생성 완료", count);
            }
        } catch (Exception e) {
            log.error("임베딩 생성 중 오류 발생", e);
        }
    }
}
```

---

## 4. 전체 시스템 흐름

```
[스케줄러]                    [서비스]                      [AI 서버]
    │                           │                             │
    │  1. 5초마다 실행           │                             │
    ├──────────────────────────>│                             │
    │                           │                             │
    │                           │  2. 임베딩 없는 도서 조회    │
    │                           ├─────────────┐               │
    │                           │             │               │
    │                           │        [DB]                │
    │                           │             │               │
    │                           │<─────────────┤               │
    │                           │  10권 조회됨                  │
    │                           │                             │
    │                           │  3. 텍스트 전처리            │
    │                           │  [제목] 자바...              │
    │                           │                             │
    │                           │  4. API 요청                │
    │                           ├────────────────────────────>│
    │                           │  ["텍스트1", "텍스트2", ...] │
    │                           │                             │
    │                           │  5. 임베딩 응답              │
    │                           │<────────────────────────────┤
    │                           │  [[0.1, 0.2, ...], ...]     │
    │                           │                             │
    │                           │  6. DB 저장                  │
    │                           ├─────────────┐               │
    │                           │             │               │
    │                           │        [DB]                │
    │                           │             │               │
    │                           │<─────────────┤               │
    │                           │  저장 완료                     │
    │<──────────────────────────┤  10권 완료                    │
    │  완료 로그 출력              │                             │
```

---

## 5. 실습 미션

### 미션 1: 전처리 테스트

```java
@Test
void testPreprocess() {
    String input = "<p>&nbsp;<b>자바</b>의 정석</p>";
    String output = TextPreprocessor.preprocess(input);

    // 예상: "자바의 정석"
    System.out.println(output);
}
```

### 미션 2: 임베딩 차원 확인

```java
@Test
void testEmbeddingDimension() {
    float[] embedding = embeddingService.getEmbedding("테스트");

    // 예상: 1024 (BGE-M3 모델)
    System.out.println("차원 수: " + embedding.length);
}
```

### 미션 3: 배치 처리 효과 비교

```java
// 1개씩 처리
long start = System.currentTimeMillis();
for (int i = 0; i < 10; i++) {
    embeddingService.getEmbedding("텍스트 " + i);
}
long singleTime = System.currentTimeMillis() - start;

// 배치 처리
List<String> texts = new ArrayList<>();
for (int i = 0; i < 10; i++) {
    texts.add("텍스트 " + i);
}
start = System.currentTimeMillis();
embeddingService.getEmbeddings(texts);
long batchTime = System.currentTimeMillis() - start;

System.out.println("1개씩: " + singleTime + "ms");
System.out.println("배치: " + batchTime + "ms");
```

---

## 6. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

- [ ] 임베딩이 생성되는 과정을 설명할 수 있다
- [ ] 전처리가 왜 필요한지 이해한다
- [ ] Spring AI로 AI 모델을 호출할 수 있다
- [ ] 배치 처리가 왜 효율적인지 안다
- [ ] TextPreprocessor를 구현할 수 있다
- [ ] EmbeddingService를 구현할 수 있다
- [ ] BookEmbeddingService를 구현할 수 있다
- [ ] 스케줄러로 주기적 실행을 설정할 수 있다

---

## 7. 다음 단계

다음 문서에서는 **자연어 검색**을 배웁니다:
- 사용자 질문을 벡터로 변환하는 방법
- 벡터 유사도 검색 구현하기
- 검색 결과 정렬 및 필터링

[다음: 04. 자연어 검색 →](04.natural-language-search.md)
