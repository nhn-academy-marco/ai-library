# 03. 지식 수치화: AI 임베딩(Embedding) 생성 Batch

Week 2의 세 번째 단계로, 도서 데이터를 AI가 이해할 수 있는 숫자의 나열(Vector)로 변환하는 **임베딩(Embedding)** 생성 프로세스를 학습합니다.

## 1. 개요

데이터베이스에 벡터를 담을 그릇(`embedding` 컬럼)을 만들었다면, 이제 그 그릇을 채울 내용을 만들어야 합니다. 이 과정은 도서의 텍스트 정보(제목, 내용 등)를 AI 모델에 전달하여 고차원 벡터로 변환받는 과정입니다. 대량의 도서를 처리해야 하므로, Week 1에서 배웠던 **Batch** 방식을 다시 활용하여 효율적으로 처리합니다.

## 2. 주요 개념

### 2.1. 임베딩(Embedding)
단어나 문장의 '의미'를 컴퓨터가 계산할 수 있는 좌표(Vector)로 변환하는 기술입니다.
- 단순히 글자 모양을 보는 것이 아니라, 그 안에 담긴 '뜻'을 수치화합니다.
- **예시**: "사과" → `[0.1, 0.2, ...]` / "배" → `[0.11, 0.19, ...]` (두 숫자가 비슷함)

### 2.2. 임베딩 모델 (Embedding Model)
텍스트를 입력받아 벡터를 출력해주는 AI 모델입니다.
- 주로 외부 API(OpenAI 등)나 로컬 라이브러리(Spring AI, LangChain4j 등)를 통해 사용합니다.
- 모델마다 출력되는 벡터의 크기(Dimension)가 다르므로, DB 설정과 일치시켜야 합니다.

### 2.3. 임베딩 대상 데이터 선정
도서의 모든 정보를 무작정 임베딩하기보다는, 사용자가 검색할 만한 **'의미 있는 정보'**를 선별하여 결합하는 것이 중요합니다. 실제 `Book` 엔티티의 구성을 고려하여 대상을 선정합니다.

- **주요 대상 필드**:
    - `title` (도서 제목): 검색의 핵심 정보입니다.
    - `subtitle` (부제목): 제목을 보완하는 상세 정보를 담고 있습니다.
    - `authorName` (저자명): 특정 저자의 작품을 찾을 때 중요합니다.
    - `publisherName` (출판사명): 출판사 기반 검색에 활용됩니다.
    - `bookContent` (도서 요약 설명): 도서의 핵심 내용을 담고 있어 '의미 기반 검색'에 가장 큰 영향을 미칩니다.
- **전략**: 단순히 한 컬럼만 사용하기보다 여러 정보를 하나의 문장으로 합쳐서 임베딩하면 검색 정확도가 높아집니다.
    - *예시*: `[제목] {title} [부제] {subtitle} [저자] {authorName} [내용] {bookContent}` 와 같이 하나의 텍스트로 결합하여 모델에 전달합니다.

### 2.4. 데이터 전처리 (Preprocessing)
AI 모델이 텍스트의 의미를 더 잘 이해할 수 있도록 데이터를 정제하는 과정입니다.

1.  **HTML 엔티티 디코딩**: `&nbsp;`, `&amp;`와 같은 HTML 엔티티를 실제 문자로 변환합니다.
2.  **HTML 태그 제거**: 정규표현식(`String.replaceAll("<[^>]*>", " ")`)을 활용하여 태그를 제거하고 공백으로 치환합니다.
3.  **노이즈 제거**: 한글, 영문, 숫자, 공백을 제외한 불필요한 특수문자들을 제거합니다.
4.  **텍스트 정규화**: 연속된 공백을 하나로 통합하고, 앞뒤 공백을 제거(trim)합니다.
5.  **소문자 변환**: 영문 데이터의 경우 소문자로 변환하여 일관성을 확보합니다.

#### 💡 전처리 전/후 비교 예시

| 단계 | 데이터 상태 |
| :--- | :--- |
| **원본 데이터** | `title`: `<p>&nbsp;<b>자바</b>의 정석</p>`, `authorName`: `남궁성 `, `bookContent`: `자바의 기초부터 @심화@까지!!  ` |
| **전처리 결과** | `title`: `자바의 정석`, `authorName`: `남궁성`, `bookContent`: `자바의 기초부터 심화까지` |
| **최종 포맷팅** | `[제목] 자바의 정석 [저자] 남궁성 [내용] 자바의 기초부터 심화까지` |

## 3. 구현 가이드 (Step-by-Step)

### 3.1. 외부 AI API 연동 설정
AI 모델을 호출하기 위한 API 키와 엔드포인트를 설정합니다. 본 실습에서는 별도의 인증 없이 사용할 수 있는 교육용 API 엔드포인트를 사용합니다.

*   **Endpoint**: `https://emb.java21.net/v1/embeddings`
*   **Model**: `bge-m3`

**API 호출 예시 (curl):**

*   **단일 텍스트 임베딩:**
```bash
curl https://emb.java21.net/v1/embeddings \
  -H "Content-Type: application/json" \
  -d '{
    "model": "bge-m3",
    "input": "안녕하세요"
  }'
```

*   **멀티 텍스트 임베딩 (Batch):**
```bash
curl https://emb.java21.net/v1/embeddings \
  -H "Content-Type: application/json" \
  -d '{
    "model": "bge-m3",
    "input": ["안녕하세요", "반갑습니다"]
  }'
```

**Java 기반 구성 예시 (EmbeddingClientConfig.java):**
Spring AI를 사용하면 별도의 HTTP 클라이언트 구현 없이도 설정만으로 API를 연동할 수 있습니다.

```java
@Configuration
public class EmbeddingConfig {
    @Bean
    public EmbeddingModel embeddingModel() {
        // application.properties 설정을 통해 자동으로 구성되지만, 
        // 필요한 경우 수동으로 OpenAiEmbeddingModel을 빈으로 등록할 수 있습니다.
        return new OpenAiEmbeddingModel(new OpenAiApi("https://emb.java21.net", "dummy"));
    }
}
```

**application.properties 설정 예시:**
```properties
# application.properties
spring.ai.openai.base-url=https://emb.java21.net
spring.ai.openai.api-key=dummy
spring.ai.openai.embedding.options.model=bge-m3
```

> **참고**: 교육용 API는 별도의 키가 필요 없으므로 `dummy`를 입력합니다. Spring AI의 OpenAI 스타터를 사용하면 호환되는 API 엔드포인트를 그대로 활용할 수 있습니다.

### 3.2. Spring AI를 이용한 임베딩 구현

직접 `curl`이나 HTTP 클라이언트를 사용하여 API를 호출할 수도 있지만, **Spring AI** 프레임워크를 사용하면 이를 객체 지향적으로 추상화하여 훨씬 간결하게 구현할 수 있습니다. `guidelines.md`에서 권장하는 **Service 계층**에 로직을 위치시켜 책임을 분리합니다.

본 실습에서는 임베딩 생성과 관련된 핵심 로직은 `core` 패키지에, 이를 호출하여 주기적으로 실행하는 스케줄링 로직은 `batch` 패키지에 분리하여 구현합니다.

#### 1) 의존성 추가 (pom.xml)
Spring AI를 사용하기 위해 필요한 의존성을 추가합니다. (이미 설정되어 있을 수 있습니다.)

```xml
<properties>
    <java.version>21</java.version>
</properties>

<dependencies>
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-starter-model-openai</artifactId>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-bom</artifactId>
            <version>1.0.1</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

> **참고**: Spring AI는 `1.0.1` 버전을 통해 안정적인 기능을 제공하고 있습니다. `spring-ai-bom`을 통해 관련 라이브러리의 버전을 일관되게 관리할 수 있습니다.

#### 2) 핵심 서비스 구현 (core 패키지)
임베딩 모델을 호출하고 데이터를 처리하는 핵심 로직을 `com.nhnacademy.library.core.book.service` 패키지에 구현합니다.

*   `EmbeddingService`: `EmbeddingModel`을 사용하여 텍스트를 벡터로 변환하는 기능을 담당합니다.
*   `BookEmbeddingService`: 도서 데이터를 조회하고, 전처리를 거쳐 임베딩을 생성 및 저장하는 비즈니스 로직을 담당합니다.

#### 3) 스케줄러 구현 (batch 패키지)
주기적으로 `core` 패키지의 서비스를 호출하여 작업을 수행하는 스케줄러를 `com.nhnacademy.library.batch.embedding.scheduler` 패키지에 구현합니다.

*   `BookEmbeddingScheduler`: `@Scheduled` 어노테이션을 사용하여 일정 시간마다 `BookEmbeddingService`를 호출합니다.

### 3.3. 배치 처리 로직 고도화

단순히 데이터를 읽어서 API를 호출하는 것을 넘어, **2.4절에서 배운 전처리 과정**을 포함한 안정적인 배치 처리 로직을 구현합니다. 학생 여러분은 다음 단계별 설명을 참고하여 실제 서비스에서 동작할 수 있는 견고한 배치 코드를 직접 완성해 보세요.

#### 1) 전처리 유틸리티 구현 단계
데이터의 품질이 검색 결과의 품질을 결정합니다. `TextPreprocessor` 유틸리티의 구현 과정을 확인해 보세요.

1.  **입력 검증**: 입력 텍스트가 `null`이거나 비어 있는지 확인(`StringUtils.hasText()`)하여 예외 상황을 방지합니다.
2.  **HTML 엔티티 디코딩**: `StringEscapeUtils.unescapeHtml4()`를 사용하여 `&nbsp;`, `&amp;` 등의 HTML 엔티티를 실제 문자로 변환합니다.
3.  **HTML 태그 정제**: 정규표현식(`HTML_TAG_PATTERN = "<[^>]*>"`)을 사용하여 텍스트에 포함된 HTML 태그들을 공백으로 치환합니다.
4.  **특수문자 제거**: 한글, 영문, 숫자, 공백을 제외한 불필요한 특수문자(`SPECIAL_CHARACTER_PATTERN = "[^가-힣a-zA-Z0-9\\s]"`)들을 제거합니다.
5.  **공백 정규화**: 문장 사이의 연속된 공백(`CONTINUOUS_SPACE_PATTERN = "\\s+"`)들을 하나로 합치고, 문장 앞뒤의 불필요한 공백을 제거(`trim()`)합니다.
6.  **일관성 확보**: 검색 효율과 일관성을 위해 `toLowerCase()`를 사용하여 모든 영문자를 소문자로 변환합니다.

#### 💡 실제 구현 예시 (TextPreprocessor.java)
```java
public class TextPreprocessor {
    private static final String HTML_TAG_PATTERN = "<[^>]*>";
    private static final String SPECIAL_CHARACTER_PATTERN = "[^가-힣a-zA-Z0-9\\s]";
    private static final String CONTINUOUS_SPACE_PATTERN = "\\s+";

    public static String preprocess(String text) {
        if (!StringUtils.hasText(text)) return "";
        
        String decoded = StringEscapeUtils.unescapeHtml4(text);
        String cleaned = decoded.replaceAll(HTML_TAG_PATTERN, " ");
        cleaned = cleaned.replaceAll(SPECIAL_CHARACTER_PATTERN, "");
        cleaned = cleaned.replaceAll(CONTINUOUS_SPACE_PATTERN, " ").trim();
        
        return cleaned.toLowerCase();
    }
}
```

> **Tip**: `guidelines.md`에 따라, 전처리에 사용되는 정규표현식 패턴들은 클래스 내부에 **상수(`private static final String`)**로 정의하여 관리하는 것이 유지보수에 유리합니다.

#### 2) 고도화된 배치 루프 구현 단계 (Scheduler 활용)

대량의 도서 데이터를 지속적으로 처리하기 위해 **Spring Scheduler**를 활용한 배치 처리 방식을 구현합니다. 다음 가이드를 참고하여 구현해 보세요.

1.  **스케줄링 활성화**: 메인 애플리케이션 클래스(`NhnAcademyAiLibraryApplication`)에 `@EnableScheduling` 어노테이션을 추가하여 스케줄링 기능을 활성화합니다.
2.  **대상 데이터 필터링**: `BookRepository`에 `embedding IS NULL` 조건을 활용하여 아직 임베딩이 생성되지 않은 도서들만 선택적으로 가져오는 메서드를 추가합니다. (예: `findTop10ByEmbeddingIsNull()`)
3.  **주기적 실행 설정**: `BookEmbeddingScheduler`에서 `@Scheduled(fixedDelay = 5000)`와 같은 설정을 통해 일정 주기마다 배치가 실행되도록 합니다.
4.  **개별 항목 처리 및 예외 격리**: 
    *   `BookEmbeddingService`에서 각 도서의 정보를 앞서 만든 전처리기로 정제하고 `[제목] {title} [부제] {subtitle} [저자] {authorName} [내용] {content}` 포맷으로 결합합니다.
    *   **로깅 및 예외 처리**: `@Slf4j`를 활용하여 처리 과정을 기록하고, 에러 발생 시 트랜잭션 롤백 및 로그를 남깁니다.
5.  **결과 반영**: 생성된 벡터를 엔티티에 업데이트하고 저장합니다. JPA의 **Dirty Checking** 기능을 활용하면 트랜잭션 종료 시 변경사항이 자동으로 반영됩니다.

#### 💡 실제 구현 예시 (BookEmbeddingService.java)
```java
@Service
@RequiredArgsConstructor
public class BookEmbeddingService {
    private final BookRepository bookRepository;
    private final EmbeddingService embeddingService;

    @Transactional
    public int processEmptyEmbeddings(int batchSize) {
        List<Book> books = bookRepository.findTop10ByEmbeddingIsNull();
        if (books.isEmpty()) return 0;

        List<String> combinedTexts = books.stream()
                .map(this::createCombinedText)
                .toList();

        List<float[]> embeddings = embeddingService.getEmbeddings(combinedTexts);

        for (int i = 0; i < books.size(); i++) {
            books.get(i).updateEmbedding(embeddings.get(i));
        }
        return books.size();
    }

    private String createCombinedText(Book book) {
        String title = TextPreprocessor.preprocess(book.getTitle());
        String content = TextPreprocessor.preprocess(book.getBookContent());
        return "[제목] " + title + " [내용] " + content;
    }
}
```

#### 3) 실습 과제 및 고도화 포인트
학생 여러분은 위 예시를 바탕으로 다음 기능을 추가로 고려해 보세요.
*   **성능 최적화**: 매 도서마다 API를 호출하는 대신, 여러 개의 텍스트를 한 번에 보내는 **Batch Embed** 방식을 적용해 보세요. (아래 3.4절 참고)
*   **데이터 선별**: `bookContent`가 너무 짧거나 없는 경우 임베딩을 생성하지 않거나 기본 문구를 사용하는 로직을 추가해 보세요.

### 3.4. (고도화) Batch Embedding 적용

네트워크 지연 시간을 줄이고 처리 효율을 높이기 위해 여러 개의 텍스트를 하나의 API 호출로 처리하는 방식을 권장합니다.

**EmbeddingService 구현 수정:**
```java
public List<float[]> getEmbeddings(List<String> texts) {
    return embeddingModel.embed(texts);
}
```

**BookEmbeddingService 일괄 처리 로직:**
```java
@Transactional
public int processEmptyEmbeddings(int batchSize) {
    List<Book> books = bookRepository.findTop10ByEmbeddingIsNull();
    
    List<Book> validBooks = new ArrayList<>();
    List<String> texts = new ArrayList<>();

    for (Book book : books) {
        String text = createCombinedText(book);
        if (StringUtils.hasText(text)) {
            validBooks.add(book);
            texts.add(text);
        }
    }

    if (texts.isEmpty()) return 0;

    // 한 번의 API 호출로 여러 개의 임베딩 생성
    List<float[]> embeddings = embeddingService.getEmbeddings(texts);

    for (int i = 0; i < validBooks.size(); i++) {
        validBooks.get(i).updateEmbedding(embeddings.get(i));
    }
    
    return validBooks.size();
}
```

## 4. 학습 포인트

*   **텍스트의 수치화**: 인간의 언어가 어떻게 AI를 위한 데이터로 변환되는지 원리를 이해합니다.
*   **API 비용과 속도**: 외부 AI 서비스를 대량으로 호출할 때 발생하는 비용 문제와 네트워크 지연을 줄이기 위한 배치 전략을 학습합니다.
*   **데이터 정제(Cleaning)**: AI 모델에 넣기 전, 텍스트에서 불필요한 특수문자나 공백을 제거하는 전처리 과정의 중요성을 이해합니다.

## 5. 심화 학습 (Study Topics)

AI의 번역기, 임베딩에 대해 쉽게 알아봅시다.

### 5.1. AI 전용 번역기 (Embedding)
영어를 한국어로 번역하듯, 임베딩은 **'인간의 언어'를 'AI의 언어(숫자)'로 번역**하는 과정입니다.
- **비유**: 전 세계 사람들이 각기 다른 언어로 "사랑해"라고 말해도, 그 '의미'는 하나인 것처럼, AI는 모든 단어를 공통된 '의미 지도' 위의 좌표로 변환합니다.

### 5.2. 지식의 압축
수만 글자의 도서 내용을 수천 개의 숫자로 압축하는 과정입니다.
- **비유**: 두꺼운 백과사전의 핵심 내용을 짧은 요약문으로 만드는 것과 비슷합니다. 요약문(벡터)만 보고도 그 책이 어떤 주제인지 AI는 판단할 수 있습니다.

## 6. 참고 링크

*   [BGE-M3 모델 상세 소개 (Week 2-2)](02.add-pgvector-column.md#6-실습-모델-소개-bge-m3)
*   [Spring AI Embedding API](https://docs.spring.io/spring-ai/reference/api/embeddings.html)
*   [LangChain4j Embedding Guide](https://docs.langchain4j.dev/tutorials/embeddings)
*   [OpenAI Embeddings Documentation](https://platform.openai.com/docs/guides/embeddings)
