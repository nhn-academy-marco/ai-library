# 05. 하이브리드 검색: 키워드와 벡터의 결합

검색 시스템의 진화 과정 중 가장 정교한 단계 중 하나인 **하이브리드 검색(Hybrid Search)** 을 학습합니다. 정확한 단어 매칭(키워드)과 문맥적 의미(벡터)를 결합하여 최상의 검색 결과를 제공하는 방법을 익힙니다.

## 1. 검색 방식 비교: 키워드 vs 벡터

| 비교 항목 | 키워드 검색 (Keyword Search) | 벡터 검색 (Vector Search) |
| :--- | :--- | :--- |
| **작동 원리** | 텍스트의 정확한 일치 여부 확인 (TF-IDF, BM25) | 문장의 의미적 유사도 계산 (Embedding) |
| **장점** | 이름, ISBN, 특정 전문 용어 검색에 매우 정확함 | 오타가 있거나 다른 단어를 사용해도 의미가 같으면 검색됨 |
| **단점** | 유의어 처리 불가, 오타에 취약, 문맥 파악 못함 | 고유 명사나 정확한 식별자(ISBN 등) 검색 시 정확도 떨어짐 |
| **주요 사례** | "홍길동", "97889..." 등 명확한 타겟 검색 | "마음이 위로가 되는 에세이" 등 추상적 요구 검색 |

## 2. 왜 하이브리드 검색인가?

현실의 사용자는 두 가지 방식을 섞어서 사용합니다.
- "한강의 채식주의자": '한강'(저자)과 '채식주의자'(제목)라는 **키워드**가 중요합니다.
- "한강 작가의 우울한 분위기 책": '한강'이라는 **키워드**와 '우울한 분위기'라는 **의미**가 결합되어야 합니다.

하이브리드 검색은 이 두 가지 점수를 적절히 조합하여 검색 품질을 극대화합니다.

## 3. 하이브리드 검색 알고리즘: RRF (Reciprocal Rank Fusion)

여러 검색 결과의 순위를 하나로 합치는 가장 대중적인 알고리즘은 **RRF** 입니다.

### 3.1. RRF 공식
$$RRFscore(d) = \sum_{r \in R} \frac{1}{k + r(d)}$$

- $R$: 각 검색 엔진(키워드, 벡터)의 결과 집합
- $r(d)$: 해당 검색 결과 내에서 문서 $d$의 순위(rank, 1부터 시작)
- $k$: 상수 (보통 60을 사용하며, 낮은 순위의 영향도를 조절함)

### 3.2. RRF 알고리즘의 핵심 원리
1.  **순위 기반 결합** : 검색 엔진마다 내뱉는 점수의 기준(유사도 점수 vs 검색 점수)이 다르기 때문에, 점수를 직접 합치면 왜곡이 발생합니다. RRF는 오직 **순위(Rank)**만을 사용하여 이 문제를 해결합니다.
2.  **상향 평준화**: 두 방식 모두에서 상위권에 오른 문서는 점수가 매우 높게 합산되어 최상단에 배치됩니다.
3.  **상수 $k$의 역할** : $k=60$은 검색 결과의 하위권(예: 100위권) 문서들이 너무 높은 점수를 받아 상위권으로 치고 올라오는 것을 방지하는 완충 작용을 합니다.

---

## 4. 구현 과정 및 코드 분석 (Java)

현재 프로젝트의 `BookSearchService.java`에 구현된 `hybridSearch` 메서드를 바탕으로 단계별 로직을 설명합니다.

### Step 1: 개별 검색 수행 (Top 100 추출)
키워드 검색과 벡터 검색을 각각 독립적으로 실행하여 충분한 후보군(각 100개)을 가져옵니다.
```java
// 1. 키워드 검색 결과 (Top 100)
Page<BookSearchResponse> keywordPage = bookRepository.search(PageRequest.of(0, 100), request);
// 2. 벡터 검색 결과 (Top 100)
Page<BookSearchResponse> vectorPage = bookRepository.vectorSearch(PageRequest.of(0, 100), request);
```

### Step 2: RRF 점수 계산 및 누적
두 검색 결과를 순회하며 문서 ID별로 RRF 점수를 계산하여 Map에 저장합니다. 이때 순위는 0번 인덱스부터 시작하므로 `i + 1`을 하여 1순위부터 계산합니다.
```java
Map<Long, Double> rrfScores = new HashMap<>();
int k = 60;

// 키워드 결과 순회 (점수 가산)
for (int i = 0; i < keywordResults.size(); i++) {
    BookSearchResponse b = keywordResults.get(i);
    rrfScores.put(b.getId(), rrfScores.getOrDefault(b.getId(), 0.0) + 1.0 / (k + i + 1));
}

// 벡터 결과 순회 (점수 가산)
for (int i = 0; i < vectorResults.size(); i++) {
    BookSearchResponse b = vectorResults.get(i);
    rrfScores.put(b.getId(), rrfScores.getOrDefault(b.getId(), 0.0) + 1.0 / (k + i + 1));
}
```

### Step 3: 데이터 병합 및 RRF 점수 부여
두 결과 집합을 하나로 합치면서, 벡터 검색 결과가 있다면 해당 도서의 '유사도 점수(Similarity)'를 유지하고, RRF 점수를 최종 결과에 포함시킵니다.
```java
if (!bookMap.containsKey(b.getId())) {
    bookMap.put(b.getId(), b);
} else {
    // 이미 키워드 결과에 있는 경우, 벡터 검색에서 계산된 유사도 점수를 업데이트
    BookSearchResponse existing = bookMap.get(b.getId());
    bookMap.put(b.getId(), new BookSearchResponse(..., b.getSimilarity()));
}

// 최종 결과 생성 시 rrfScore 할당
content.add(new BookSearchResponse(..., original.getSimilarity(), rrfScore));
```

### Step 4: 최종 정렬 및 페이징
계산된 RRF 점수를 기준으로 내림차순 정렬합니다. 이후 사용자가 요청한 페이지 번호와 사이즈에 맞춰 최종 리스트를 반환합니다. 이때, 계산된 RRF 점수를 `BookSearchResponse`의 `rrfScore` 필드에 담아 화면에 표시할 수 있도록 합니다.

```java
List<Long> sortedIds = rrfScores.entrySet().stream()
        .sorted((e1, e2) -> e2.getValue().compareTo(e1.getValue()))
        .map(Map.Entry::getKey)
        .toList();

// ... 페이징 처리 및 rrfScore 할당
for (int i = start; i < end; i++) {
    Long id = sortedIds.get(i);
    BookSearchResponse original = bookMap.get(id);
    Double rrfScore = rrfScores.get(id);
    
    content.add(new BookSearchResponse(..., original.getSimilarity(), rrfScore));
}
```

---

## 5. 학습 포인트
- **결합의 효과**: 키워드 검색에서는 10위였고 벡터 검색에서는 5위였던 책이, RRF를 통해 최종 1위로 올라오는 과정을 관찰해 보세요.
- **성능 최적화**: 현재는 두 검색을 순차적으로 수행하지만, `CompletableFuture` 등을 이용해 병렬로 호출하면 검색 속도를 더욱 개선할 수 있습니다.

## 6. 참고 자료 (References)

*   [Reciprocal Rank Fusion (RRF) - Elastic Docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/rrf.html)
*   [Hybrid Search Explained - Pinecone](https://www.pinecone.io/learn/hybrid-search/)
*   [Reciprocal Rank Fusion (original paper)](https://dl.acm.org/doi/pdf/10.1145/1571941.1572114)
*   [What is Hybrid Search? - Weaviate](https://weaviate.io/blog/hybrid-search-explained)
