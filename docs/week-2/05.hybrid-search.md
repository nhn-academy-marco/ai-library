# 05. 하이브리드 검색: 키워드와 벡터의 완벽한 결합

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- Week 2의 01-04 문서 내용 (벡터 검색의 필요성, pgvector, 임베딩, 자연어 검색)
- Week 1의 키워드 검색 경험
- 자바 Map, List 기본 개념
- 페이징 처리 이해

---

## 1. 개요

키워드 검색과 벡터 검색은 각각 장단점이 있습니다. 이 두 가지를 결합하면 더 좋은 검색 결과를 얻을 수 있습니다!

**이 문서에서 배울 내용:**
- 키워드 검색과 벡터 검색의 장단점
- 왜 하이브리드 검색이 필요한지
- RRF(Reciprocal Rank Fusion) 알고리즘 이해
- 두 검색 결과를 하나로 합치는 방법
- 실제 하이브리드 검색 구현하기

> **중요: 하이브리드 검색의 장점**
>
> 키워드 검색:
> - "자바" → "자바"라는 글자가 있는 책
>
> 벡터 검색:
> - "프로그래밍 언어" → 자바, 파이썬, C++...
>
> 하이브리드 검색:
> - "자바 프로그래밍" → 정확히 "자바"가 있고, 프로그래밍 관련 책까지!

---

## 2. 핵심 개념 이해

### 2.1. 키워드 검색 vs 벡터 검색

**비교표:**

| 비교 항목 | 키워드 검색 | 벡터 검색 |
|----------|------------|-----------|
| 작동 원리 | 글자 정확 일치 | 의미 유사도 |
| 장점 | 정확한 용어, 이름 검색에 뛰어남 | 오타, 동의어 처리 가능 |
| 단점 | 오타에 취약, 동의어 처리 불가 | 고유명사 검색에 약함 |
| 예시 | "홍길동", "ISBN" | "우울한 분위기의 책" |

**비유로 이해하기:**
```
[키워드 검색]
도서관에서 "홍길동"을 찾을 때
→ "홍길동전"을 찾음
→ "홍길동의 모험"을 찾음
→ "길동이의 이야기"를 못 찾음

[벡터 검색]
도서관 사서에게 "홍길동 같은 이야기"를 물어볼 때
→ "홍길동전"을 찾음
→ "춘향전"도 찾을 수 있음 (비슷한 고전 소설)
→ "심청전"도 찾을 수 있음
```

### 2.2. 왜 하이브리드 검색인가?

사용자는 키워드와 의미를 섞어서 검색합니다.

**실제 사용자 검색 예시:**
```
1. "한강의 채식주의자"
   → "한강" (저자명) → 키워드 검색 중요
   → "채식주의자" (제목) → 키워드 검색 중요

2. "한강 작가의 우울한 분위기 책"
   → "한강" (저자명) → 키워드 검색
   → "우울한 분위기" → 벡터 검색

3. "자바 프로그래밍 입문"
   → "자바" (정확한 용어) → 키워드 검색
   → "입문" (난이도 의미) → 벡터 검색
```

**하이브리드 검색의 장점:**
```
[검색: "자바 프로그래밍"]

키워드만:
1. "자바 프로그래밍" (정확 일치)
2. "자바 완정정복"
3. "파이썬 프로그래밍" (의미는 같지만 글자가 다름)

벡터만:
1. "자바 프로그래밍 언어"
2. "프로그래밍 입문"
3. "Java Programming"
4. "자전거 타기" (관련 없지만 유사할 수 있음)

하이브리드:
1. "자바 프로그래밍" (키워드 + 벡터 모두 높음)
2. "자바 완전정복" (키워드 높음)
3. "프로그래밍 언어의 이해" (벡터 높음)
4. "Java Programming" (벡터 높음)
→ 가장 좋은 결과를 상위에 노출!
```

### 2.3. RRF (Reciprocal Rank Fusion) 알고리즘

두 검색 결과의 순위를 합치는 가장 대중적인 알고리즘입니다.

**비유로 이해하기:**
```
학교에서 시험을 볼 때 상황을 생각해 보세요.

[국어 성적]
1등: 철수 (100점)
2등: 영희 (95점)
3등: 민수 (90점)

[수학 성적]
1등: 영희 (100점)
2등: 철수 (95점)
3등: 민수 (85점)

[종합 성적 (RRF)]
1위: 철수 (국어 1등 + 수학 2등)
2위: 영희 (국어 2등 + 수학 1등)
3위: 민수 (국어 3등 + 수학 3등)

두 과목 모두 잘하는 친구가 1등이 되는 것과 같아요!
```

**RRF 공식:**
```
RRF 점수 = 1 / (k + 순위)

k는 상수 (보통 60)

예시:
- 1위: 1 / (60 + 1) = 0.0164
- 2위: 1 / (60 + 2) = 0.0161
- 3위: 1 / (60 + 3) = 0.0159
...
- 100위: 1 / (60 + 100) = 0.0063

순위가 높을수록 점수가 큼 ✅
```

**RRF 계산 예시:**
```
[키워드 검색 결과]
1위: 도서 A
2위: 도서 B
3위: 도서 C

[벡터 검색 결과]
1위: 도서 C
2위: 도서 A
3위: 도서 D

[RRF 점수 계산]
도서 A: 1/(60+1) + 1/(60+2) = 0.0164 + 0.0161 = 0.0325
도서 B: 1/(60+2) = 0.0161
도서 C: 1/(60+3) + 1/(60+1) = 0.0159 + 0.0164 = 0.0323
도서 D: 1/(60+3) = 0.0159

[최종 순위]
1위: 도서 A (0.0325) - 두 검색 모두 상위권
2위: 도서 C (0.0323) - 두 검색 모두 상위권
3위: 도서 B (0.0161) - 키워드만 상위권
4위: 도서 D (0.0159) - 벡터만 상위권
```

**왜 점수가 아니라 순위를 쓸까요?**
```
[점수 합산의 문제]
키워드 검색 점수: 0 ~ 100
벡터 검색 점수: 0 ~ 1

점수를 그냥 더하면:
- 키워드 100점 + 벡터 0.5점 = 100.5점
- 키워드 50점 + 벡터 1.0점 = 51.0점
→ 키워드 점수가 너무 큰 영향 ❌

[순위 합산의 장점]
키워드 순위: 1 ~ 100
벡터 순위: 1 ~ 100

순위로 RRF 계산:
- 키워드 1위 + 벡터 2위 = 높은 RRF 점수
- 키워드 50위 + 벡터 1위 = 중간 RRF 점수
→ 두 검색의 균형 잡힌 결합
```

---

## 3. 구현 가이드 (Step-by-Step)

### STEP 1: RRF 서비스 구현

RRF 알고리즘으로 두 검색 결과를 병합하는 서비스를 만듭니다.

**구현 흐름:**
1. 키워드 검색 결과와 벡터 검색 결과를 각각 순회하며 RRF 점수 누적 계산
2. 도서 ID별로 점수를 Map에 저장 (`1 / (60 + 순위)`)
3. 두 검색 결과 모두 상위권에 있는 도서가 높은 점수 받음
4. 벡터 검색의 similarity 점수는 최종 결과에 보존
5. RRF 점수 기준 내림차순 정렬 후 반환

**구현 힌트:**
- `Map<Long, Double> rrfScores`로 도서별 점수 누적
- `Map<Long, BookSearchResponse> bookMap`으로 도서 정보 병합
- Stream API로 정렬 및 최종 DTO 생성

### STEP 2: 응답 DTO에 RRF 점수 추가

하이브리드 검색의 결과로 RRF 점수를 포함합니다.

**BookSearchResponse.java - 필드 구조**
```java
public class BookSearchResponse {
    private Long id;
    private String isbn;
    private String title;
    private String volumeTitle;        // 권명
    private String authorName;
    private String publisherName;
    private BigDecimal price;          // 가격
    private LocalDate editionPublishDate;  // 판별 발행일
    private String imageUrl;
    private String bookContent;
    private Double similarity;         // 벡터 검색 유사도 (0 ~ 1)
    private Double rrfScore;           // 하이브리드 검색 RRF 점수
}
```

**구현 가이드:**
- QueryDSL의 `@QueryProjection`을 활용하면 생성자 자동 생성 가능
- similarity는 벡터 검색 시만 값이 있음
- rrfScore는 하이브리드 검색 시만 계산됨

### STEP 3: UI에 검색 타입 선택

사용자가 검색 타입을 선택할 수 있는 UI를 추가합니다.

**index.html (Thymeleaf)**
```html
<!-- 검색 타입 선택 -->
<div class="mb-3">
    <div class="btn-group w-100" role="group">
        <input type="radio" class="btn-check" name="searchType"
               id="keyword" value="KEYWORD" checked>
        <label class="btn btn-outline-primary" for="keyword">
            키워드 검색
        </label>

        <input type="radio" class="btn-check" name="searchType"
               id="vector" value="VECTOR">
        <label class="btn btn-outline-success" for="vector">
            벡터 검색
        </label>

        <input type="radio" class="btn-check" name="searchType"
               id="hybrid" value="HYBRID">
        <label class="btn btn-outline-warning" for="hybrid">
            하이브리드 검색
        </label>
    </div>
</div>

<!-- 검색 결과 -->
<div class="col-md-3 mb-3" th:each="book : ${books}">
    <div class="card h-100">
        <img th:src="${book.imageUrl}" class="card-img-top">
        <div class="card-body">
            <h5 class="card-title" th:text="${book.title}">제목</h5>
            <p class="card-text" th:text="${book.authorName}">저자</p>

            <!-- 벡터 검색 유사도 -->
            <div th:if="${book.similarity != null}">
                <small class="badge bg-success">
                    유사도: <span th:text="${book.similarityPercent}">95%</span>
                </small>
            </div>

            <!-- 하이브리드 검색 RRF 점수 -->
            <div th:if="${book.rrfScore != null}">
                <small class="badge bg-warning text-dark">
                    종합 점수: <span th:text="${book.rrfScoreDisplay}">0.0325</span>
                </small>
            </div>
        </div>
    </div>
</div>
```

---

## 4. 전체 시스템 흐름

```
[사용자]
    │
    │  1. "자바 프로그래밍" 검색 (하이브리드)
    ↓
[서버]
    │
    ├─→ [키워드 검색]
    │   │  1. "자바" + "프로그래밍" LIKE 검색
    │   │  2. 결과: [A(1위), B(2위), C(3위), ...]
    │   │
    ├─→ [벡터 검색]
    │   │  1. "자바 프로그래밍" → 벡터 변환
    │   │  2. 유사도 검색
    │   │  3. 결과: [C(1위), A(2위), D(3위), ...]
    │   │
    └─→ [RRF 계산]
        │  A: 1/(60+1) + 1/(60+2) = 0.0325
        │  B: 1/(60+2) = 0.0161
        │  C: 1/(60+3) + 1/(60+1) = 0.0323
        │  D: 1/(60+3) = 0.0159
        │
        └─→ [최종 결과]
            1위: A (0.0325) - 두 검색 모두 상위
            2위: C (0.0323) - 두 검색 모두 상위
            3위: B (0.0161)
            4위: D (0.0159)
```

---

## 5. 성능 최적화

### 5.1. CompletableFuture를 활용한 병렬 처리

현재 키워드 검색과 벡터 검색이 순차적으로 실행됩니다. 이를 병렬로 실행하면 응답 시간을 단축할 수 있습니다.

**순차 실행 vs 병렬 실행:**
```
[순차 실행 - 현재 방식]
┌─────────────────────────────────┐
│ 키워드 검색 (100ms)              │
└─────────────────────────────────┘
                 ↓
┌─────────────────────────────────┐
│ 벡터 검색 (150ms)                │
└─────────────────────────────────┘
                 ↓
[RRF 병합]
총 소요 시간: 100ms + 150ms = 250ms

───────────────────────────────────

[병렬 실행 - 개선 방식]
┌─────────────────────────────────┐
│ 키워드 검색 (100ms)              │
├─────────────────────────────────┤
│ 벡터 검색 (150ms)                │
└─────────────────────────────────┘
                 ↓
        [둘 중 느린 검색 완료 시 대기]
                 ↓
[RRF 병합]
총 소요 시간: max(100ms, 150ms) = 150ms

성능 향상: 250ms → 150ms (40% 단축!)
```

### 5.2. CompletableFuture란?

Java 8부터 도입된 비동기 처리 API입니다.

**핵심 개념:**
- **CompletableFuture**: 미래에 완료될 결과를 담는 컨테이너
- **supplyAsync**: 별도의 스레드에서 비동기로 작업 실행
- **thenCombine**: 두 CompletableFuture가 모두 완료되면 결과를 조합

**비유로 이해하기:**
```
피자를 주문하는 상황을 상상해 보세요.

[순차 주문]
1. 피자 가게에 전화 → 10분 후 도착
2. 치킨 가게에 전화 → 10분 후 도착
총: 20분

[병렬 주문]
1. 피자 가게와 치킨 가게에 동시에 전화
2. 둘 중 빨리 도착한 곳 확인 → 10분 후
총: 10분 (빨른 배달만 기다리기)
```

### 5.3. thenCombine으로 결과 조합

**HybridSearchStrategy 적용 예시:**

```java
// 1. 키워드 검색과 벡터 검색을 병렬로 실행
CompletableFuture<List<BookSearchResponse>> keywordSearchFuture = CompletableFuture.supplyAsync(() -> {
    var keywordPage = bookRepository.search(PageRequest.of(0, DEFAULT_BATCH_SIZE), request);
    return (keywordPage != null && keywordPage.getContent() != null)
            ? keywordPage.getContent()
            : List.of();
}, taskExecutor);  // 비동기 실행

CompletableFuture<List<BookSearchResponse>> vectorSearchFuture = CompletableFuture.supplyAsync(() -> {
    var vectorPage = bookRepository.vectorSearch(PageRequest.of(0, DEFAULT_BATCH_SIZE), request);
    return (vectorPage != null && vectorPage.getContent() != null)
            ? vectorPage.getContent()
            : List.of();
}, taskExecutor);  // 비동기 실행

// 2. 두 검색이 모두 완료되면 RRF로 병합
CompletableFuture<List<BookSearchResponse>> fusedResultsFuture = keywordSearchFuture.thenCombineAsync(
        vectorSearchFuture,
        (keywordResults, vectorResults) -> {
            // 두 결과가 모두 도착했을 때 호출됨
            return rrfService.fuse(keywordResults, vectorResults);
        },
        taskExecutor  // RRF 병합도 비동기 실행
);

// 3. 최종 결과 가져오기 (필요시 대기)
List<BookSearchResponse> fusedResults = fusedResultsFuture.join();

// 4. 메모리 내 페이징 처리
int start = (int) pageable.getOffset();
int end = Math.min((start + pageable.getPageSize()), fusedResults.size());
List<BookSearchResponse> content = fusedResults.subList(start, end);

return BookSearchResult.builder()
        .books(new PageImpl<>(content, pageable, fusedResults.size()))
        .build();
```

**주요 메서드 설명:**

| 메서드 | 설명 |
|--------|------|
| `supplyAsync()` | 별도 스레드에서 작업 실행 후 CompletableFuture 반환 |
| `thenCombine()` | 두 CompletableFuture가 완료되면 두 결과를 조합 |
| `join()` | 결과가 나올 때까지 대기 (블로킹) |
| `taskExecutor` | 비동기 작업을 실행할 스레드 풀 |

**주의사항:**
- DB 연결 수가 늘어날 수 있으므로 커넥션 풀 사이즈 확인 필요
- 너무 많은 병렬 작업은 오히려려 성능 저하 가능
- `CompletableFuture.allOf()`을 사용하면 여러 작업을 동시 대기 가능

---

## 6. 실습 미션

### 미션 1: RRF 점수 직접 계산

```java
@Test
void testRRFCalculation() {
    // 키워드 검색 결과
    List<String> keywordResults = List.of("A", "B", "C");

    // 벡터 검색 결과
    List<String> vectorResults = List.of("C", "A", "D");

    // RRF 점수 계산
    Map<String, Double> rrfScores = new HashMap<>();
    int k = 60;

    for (int i = 0; i < keywordResults.size(); i++) {
        String book = keywordResults.get(i);
        double score = 1.0 / (k + i + 1);
        rrfScores.put(book, rrfScores.getOrDefault(book, 0.0) + score);
    }

    for (int i = 0; i < vectorResults.size(); i++) {
        String book = vectorResults.get(i);
        double score = 1.0 / (k + i + 1);
        rrfScores.put(book, rrfScores.getOrDefault(book, 0.0) + score);
    }

    // 결과 확인
    rrfScores.entrySet().stream()
            .sorted((e1, e2) -> e2.getValue().compareTo(e1.getValue()))
            .forEach(e -> System.out.println(
                    e.getKey() + ": " + e.getValue()
            ));
}
```

### 미션 2: 검색 타입 비교

```java
// 같은 검색어로 세 가지 검색 비교
String keyword = "자바 프로그래밍";

// 1. 키워드 검색
Page<BookSearchResponse> keywordResult =
    bookSearchService.searchBooks(pageable,
        new BookSearchRequest(keyword, SearchType.KEYWORD));

// 2. 벡터 검색
Page<BookSearchResponse> vectorResult =
    bookSearchService.searchBooks(pageable,
        new BookSearchRequest(keyword, SearchType.VECTOR));

// 3. 하이브리드 검색
Page<BookSearchResponse> hybridResult =
    bookSearchService.searchBooks(pageable,
        new BookSearchRequest(keyword, SearchType.HYBRID));

// 결과 비교
System.out.println("키워드: " + keywordResult.getContent().get(0).title());
System.out.println("벡터: " + vectorResult.getContent().get(0).title());
System.out.println("하이브리드: " + hybridResult.getContent().get(0).title());
```

---

## 7. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

- [ ] 키워드 검색과 벡터 검색의 장단점을 안다
- [ ] 왜 하이브리드 검색이 필요한지 설명할 수 있다
- [ ] RRF 알고리즘의 원리를 이해한다
- [ ] RRF 점수를 직접 계산할 수 있다
- [ ] 두 검색 결과를 하나로 병합할 수 있다
- [ ] 하이브리드 검색을 구현할 수 있다
- [ ] 병렬 처리로 성능을 개선할 수 있다

---

## 8. Week 2 정리

이번 주차에 배운 내용을 복습해 보세요:

### 1단계: 키워드 검색의 한계
- 동의어, 오타 처리 불가
- 의미 파악 못 함

### 2단계: 벡터 검색 도입
- pgvector로 벡터 컬럼 추가
- 1024차원 BGE-M3 모델 사용

### 3단계: 임베딩 생성
- 전처리로 텍스트 정제
- 배치 처리로 효율적 생성

### 4단계: 자연어 검색
- 코사인 유사도 계산
- 사용자 검색어를 벡터로 변환

### 5단계: 하이브리드 검색
- 키워드 + 벡터 결합
- RRF 알고리즘으로 순위 통합

---

## 9. 다음 단계

다음 주차에서는 **AI 기반 리뷰 요약**을 배웁니다:
- Spring AI로 ChatGPT 연동
- 리뷰 내용 자동 요약
- 이벤트 기반 아키텍처 심화

[다음: Week 3 - AI 리뷰 요약 →](../week-3/01.spring-ai-chatgpt-integration.md)
