# 03. 외부 API Function 구현: 도서관정보나루 연동 (Fallback 패턴)

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- **Level 1 완료**: 단일 Function 구현 경험
- Spring AI Function Calling 기초
- REST API 호출 경험
- JSON 파싱

---

## 1. 개요

Level 1에서는 내부 DB만 검색했습니다. 이제 **"내부 DB → 도서관정보나루 API" 순서로 검색**하는 Fallback 패턴을 구현해 보겠습니다.

**학습 로드맵:**
```
✓ Level 1 (완료):   단일 Function - 내부 도서 검색
→ Level 2 (이 문서): Fallback 패턴 - 내부 DB → 외부 API
  Level 3 (다음):    다중 Function 조합 & 오케스트레이션
```

**Level 2 학습 목표:**
- 외부 API 클라이언트 구현
- Fallback 패턴 구현 (내부 DB → 외부 API)
- 데이터 출처 추적
- 캐싱으로 API 호출 최적화

> **중요: Fallback 패턴**
>
> ```
> 1. 먼저 내부 DB 검색
> 2. 결과가 없으면 도서관정보나루 API 검색
> 3. 두 결과를 통합하여 반환
> ```

---

## 2. 도서관정보나루 API 이해

### 2.1. API 개요

**도서관정보나루**는 한국도서관협회에서 운영하는 전국 도서관 정보 통합 시스템입니다.

**제공 기능:**
- 전국 도서관 장서 검색
- 대출 가능 여부 확인
- 도서관 위치 정보

### 2.2. API 기본 정보

```
기본 URL: https://www.data4library.kr/api
인증: API 키 필요 (도서관정보나루 발급)
```

**주요 엔드포인트:**

| 엔드포인트 | 설명 | 파라미터 |
|----------|------|---------|
| `/bookSrch` | 도서 검색 | title, isbn, isbn13, author, publisher |
| `/loanItemSrch` | 대출 가능 도서 조회 | isbn13, region, libraryName |

### 2.3. API 응답 예시

```json
{
  "response": {
    "numFound": 125,
    "docs": [
      {
        "book": {
          "bookname": "자바의 정석",
          "authors": "남궁성 지음",
          "publisher": "도우출판",
          "isbn13": "9788960777331"
        },
        "loanInfo": {
          "loanAvailable": "Y",
          "loanCount": 152
        }
      }
    ]
  }
}
```

---

## 3. Level 2: Fallback 패턴 구현

### STEP 1: 의존성 확인

**application.properties** - API 설정 추가
```properties
# 도서관정보나루 API 설정
library.api.url=https://www.data4library.kr/api
library.api.key=${LIBRARY_API_KEY:your-api-key-here}
```

### STEP 2: 외부 API 클라이언트 구현

**LibraryInfoNaruApiClient.java**
```java
package com.nhnacademy.library.external.client;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.util.ArrayList;
import java.util.List;

/**
 * 도서관정보나루 API 클라이언트
 *
 * Level 2에서 추가:
 * - 외부 API 호출 기능
 * - 캐싱으로 API 비용 절감
 */
@Component
@Slf4j
public class LibraryInfoNaruApiClient {

    @Value("${library.api.url}")
    private String apiUrl;

    @Value("${library.api.key}")
    private String apiKey;

    private final RestTemplate restTemplate = new RestTemplate();
    private final ObjectMapper objectMapper = new ObjectMapper();

    /**
     * 제목으로 도서 검색
     */
    @Cacheable(value = "librarySearch", key = "#title")
    public List<LibraryBookInfo> searchBooksByTitle(String title) {
        log.info("[도서관정보나루] 도서 검색: title={}", title);

        try {
            String url = String.format("%s/bookSrch?title=%s&authKey=%s&format=json",
                apiUrl, title, apiKey);

            String response = restTemplate.getForObject(url, String.class);
            return parseBookSearchResponse(response);

        } catch (Exception e) {
            log.error("[도서관정보나루] API 호출 실패", e);
            return List.of();
        }
    }

    // 응답 파싱
    private List<LibraryBookInfo> parseBookSearchResponse(String response) {
        List<LibraryBookInfo> books = new ArrayList<>();
        try {
            JsonNode root = objectMapper.readTree(response);
            JsonNode docs = root.path("response").path("docs");

            for (JsonNode doc : docs) {
                JsonNode book = doc.path("book");
                JsonNode loanInfo = doc.path("loanInfo");

                books.add(LibraryBookInfo.builder()
                    .title(book.path("bookname").asText())
                    .authors(book.path("authors").asText())
                    .publisher(book.path("publisher").asText())
                    .isbn13(book.path("isbn13").asText())
                    .loanAvailable("Y".equals(loanInfo.path("loanAvailable").asText()))
                    .loanCount(loanInfo.path("loanCount").asInt())
                    .build());
            }
        } catch (Exception e) {
            log.error("응답 파싱 실패", e);
        }
        return books;
    }
}
```

**LibraryBookInfo.java** - DTO
```java
package com.nhnacademy.library.external.client;

import lombok.Builder;

@Builder
public record LibraryBookInfo(
    String title,
    String authors,
    String publisher,
    String isbn13,
    boolean loanAvailable,
    int loanCount
) {}
```

### STEP 3: Fallback Function 구현

이제 핵심인 Fallback 패턴을 구현합니다. Level 1의 `BookSearchFunction`을 확장합니다.

**BookSearchFunction.java** - Level 2로 업그레이드
```java
package com.nhnacademy.library.ai.function;

import com.nhnacademy.library.ai.function.dto.BookSearchRequest;
import com.nhnacademy.library.ai.function.dto.BookSearchResult;
import com.nhnacademy.library.core.book.dto.BookSearchResponse;
import com.nhnacademy.library.core.book.service.search.BookSearchService;
import com.nhnacademy.library.external.client.LibraryBookInfo;
import com.nhnacademy.library.external.client.LibraryInfoNaruApiClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Description;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Level 2: Fallback 패턴 검색 Function
 *
 * 내부 DB → 도서관정보나루 API 순서로 검색합니다.
 * Level 1의 단일 검색 기능을 확장합니다.
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class BookSearchFunction {

    private final BookSearchService bookSearchService;
    private final LibraryInfoNaruApiClient libraryApiClient;

    /**
     * 도서 검색 함수 (Fallback 패턴)
     *
     * 1. 먼저 내부 DB 검색
     * 2. 결과가 없거나 부족하면 도서관정보나루 API 검색
     * 3. 두 결과를 통합하여 반환
     */
    @Description("도서관 시스템에서 도서를 검색합니다. " +
            "먼저 내부 DB를 검색하고, 결과가 없으면 도서관정보나루 API에서 " +
            "전국 도서관의 장서를 검색하여 대출 가능 여부를 확인합니다.")
    public Function<BookSearchRequest, BookSearchResult> searchBooks() {
        return request -> {
            log.info("[Function] 도서 검색 시작: query={}", request.query());

            try {
                // 1단계: 내부 DB 검색
                List<BookSearchResult.BookItem> internalBooks = searchInternalDB(
                    request.query(),
                    request.limit()
                );

                log.info("[Function] 내부 DB 검색 결과: {}권", internalBooks.size());

                // 2단계: 내부 DB에 결과가 없으면 도서관정보나루 API 검색
                List<BookSearchResult.BookItem> libraryBooks = List.of();
                if (internalBooks.isEmpty()) {
                    log.info("[Function] 내부 DB에 결과 없음, 도서관정보나루 검색 시작");
                    libraryBooks = searchLibraryAPI(request.query(), request.limit());
                    log.info("[Function] 도서관정보나루 검색 결과: {}권", libraryBooks.size());
                }

                // 3단계: 결과 통합
                List<BookSearchResult.BookItem> allBooks = new ArrayList<>();
                allBooks.addAll(internalBooks);
                allBooks.addAll(libraryBooks);

                // 4단계: 중복 제거 (ISBN 기준)
                List<BookSearchResult.BookItem> uniqueBooks = deduplicateByIsbn(allBooks);

                // 5단계: 결과 제한
                List<BookSearchResult.BookItem> finalBooks = uniqueBooks.stream()
                    .limit(request.limit())
                    .toList();

                log.info("[Function] 최종 결과: {}권 (내부 DB: {}권, 도서관정보나루: {}권)",
                    finalBooks.size(),
                    internalBooks.size(),
                    libraryBooks.size());

                return BookSearchResult.builder()
                    .count(finalBooks.size())
                    .books(finalBooks)
                    .source(buildSourceDescription(internalBooks, libraryBooks))
                    .build();

            } catch (Exception e) {
                log.error("[Function] 검색 실패", e);
                return BookSearchResult.builder()
                    .count(0)
                    .books(List.of())
                    .source("검색 실패")
                    .build();
            }
        };
    }

    /**
     * 내부 DB 검색
     */
    private List<BookSearchResult.BookItem> searchInternalDB(String query, int limit) {
        try {
            var books = bookSearchService.searchBooks(
                com.nhnacademy.library.core.book.dto.BookSearchRequest.builder()
                    .query(query)
                    .searchType(com.nhnacademy.library.core.book.service.search.SearchType.HYBRID)
                    .limit(limit)
                    .build()
            );

            return books.stream()
                .map(this::toBookItemFromInternal)
                .toList();

        } catch (Exception e) {
            log.error("[Function] 내부 DB 검색 실패", e);
            return List.of();
        }
    }

    /**
     * 도서관정보나루 API 검색
     */
    private List<BookSearchResult.BookItem> searchLibraryAPI(String query, int limit) {
        try {
            List<LibraryBookInfo> libraryBooks = libraryApiClient.searchBooksByTitle(query);

            return libraryBooks.stream()
                .limit(limit)
                .map(this::toBookItemFromLibrary)
                .toList();

        } catch (Exception e) {
            log.error("[Function] 도서관정보나루 검색 실패", e);
            return List.of();
        }
    }

    /**
     * 내부 DB 결과 변환
     */
    private BookSearchResult.BookItem toBookItemFromInternal(BookSearchResponse book) {
        return BookSearchResult.BookItem.builder()
            .id(book.id())
            .title(book.title())
            .author(book.authorName())
            .publisher(book.publisherName())
            .source("내부 DB")
            .isbn(book.isbn())
            .loanAvailable(null)  // 내부 DB는 대출 정보 없음
            .build();
    }

    /**
     * 도서관정보나루 결과 변환
     */
    private BookSearchResult.BookItem toBookItemFromLibrary(LibraryBookInfo info) {
        return BookSearchResult.BookItem.builder()
            .title(info.title())
            .author(info.authors())
            .publisher(info.publisher())
            .isbn(info.isbn13())
            .source("도서관정보나루")
            .loanAvailable(info.loanAvailable())
            .build();
    }

    /**
     * ISBN 기반 중복 제거
     * 내부 DB 데이터를 우선합니다
     */
    private List<BookSearchResult.BookItem> deduplicateByIsbn(List<BookSearchResult.BookItem> books) {
        return books.stream()
            .collect(Collectors.toMap(
                book -> book.isbn() != null ? book.isbn() : book.title(), // 키: ISBN 또는 제목
                book -> book, // 값: BookItem
                (existing, replacement) -> {
                    // 내부 DB 우선 (source 필드로 판단)
                    return "내부 DB".equals(existing.source()) ? existing : replacement;
                }
            ))
            .values()
            .stream()
            .toList();
    }

    /**
     * 데이터 출처 설명 생성
     */
    private String buildSourceDescription(List<BookSearchResult.BookItem> internalBooks,
                                          List<BookSearchResult.BookItem> libraryBooks) {
        List<String> sources = new ArrayList<>();
        if (!internalBooks.isEmpty()) {
            sources.add("내부 DB");
        }
        if (!libraryBooks.isEmpty()) {
            sources.add("도서관정보나루");
        }
        return String.join(" + ", sources);
    }
}
```

### STEP 4: DTO 업데이트

**BookSearchResult.java** - source 필드 추가
```java
package com.nhnacademy.library.ai.function.dto;

import lombok.Builder;

import java.util.List;

/**
 * 도서 검색 결과 (Level 2 업데이트)
 */
@Builder
public record BookSearchResult(
    int count,
    String source,      // 데이터 출처 (Level 2新增)
    List<BookItem> books
) {
    @Builder
    public record BookItem(
        Long id,              // 내부 DB ID (도서관정보나루는 null)
        String title,
        String author,
        String publisher,
        String isbn,
        String source,        // 데이터 출처 (Level 2新增: "내부 DB" or "도서관정보나루")
        Boolean loanAvailable // 대출 가능 여부 (도서관정보나루만 제공, 내부 DB는 null)
    ) {}
}
```

### STEP 5: ChatClient 설정 확인

**AiConfig.java** - 여전히 하나의 함수만 등록
```java
package com.nhnacademy.library.core.config;

import com.nhnacademy.library.ai.function.BookSearchFunction;
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * AI 설정 - Level 2
 *
 * Fallback 패턴이 적용된 하나의 함수만 등록합니다.
 * 함수 내부에서 내부 DB와 외부 API를 모두 처리합니다.
 */
@Configuration
@RequiredArgsConstructor
public class AiConfig {

    private final ChatModel chatModel;
    private final BookSearchFunction bookSearchFunction;

    @Bean
    public ChatClient chatClient() {
        return ChatClient.builder(chatModel)
            // Fallback 패턴이 적용된 검색 함수
            .defaultFunctions(bookSearchFunction.searchBooks())
            .build();
    }
}
```

---

## 4. 실행 및 테스트

### 4.1. Fallback 흐름

```
사용자: "자바 책 찾아줘"
   ↓
[1단계] 내부 DB 검색
   ↓
   결과: 0권 (없음)
   ↓
[2단계] 도서관정보나루 검색 (Fallback)
   ↓
   결과: 125권
   ↓
[3단계] 통합 반환: 125권 (출처: 도서관정보나루)
```

### 4.2. 테스트 시나리오

**테스트 1: 내부 DB에 있는 도서**
```
GET /ai/search?query=등록된 도서명

AI 동작:
1. searchInternalDB() → 5권 발견
2. 내부 DB 결과만 반환 (API 호출 없음)
3. source: "내부 DB"

응답: "5권을 찾았습니다 (내부 DB)"
```

**테스트 2: 내부 DB에 없는 도서**
```
GET /ai/search?query=새로운 책

AI 동작:
1. searchInternalDB() → 0권
2. searchLibraryAPI() → 50권 (Fallback)
3. 도서관정보나루 결과 반환
4. source: "도서관정보나루"

응답: "50권을 찾았습니다 (도서관정보나루)"
```

**테스트 3: 두 곳 모두에 있는 도서**
```
GET /ai/search?query=인기 책

AI 동작:
1. searchInternalDB() → 3권
2. 내부 DB에 있으므로 도서관정보나루 검색 생략
3. 내부 DB 결과만 반환

응답: "3권을 찾았습니다 (내부 DB)"
```

---

## 5. Level 1과 Level 2 비교

| 항목 | Level 1 | Level 2 (Fallback) |
|-----|---------|-------------------|
| 검색 순서 | 내부 DB만 | 내부 DB → 도서관정보나루 |
| 함수 개수 | 1개 | 1개 (기능 확장) |
| 데이터 출처 추적 | ❌ | ✅ |
| 중복 제거 | ❌ | ✅ |
| 검색 범위 | 도서관 소장 장서 | 전국 도서관 장서 |
| API 호출 | 없음 | 내부 DB에 없을 때만 |

---

## 6. 실습 미션

### 미션 1: Fallback 조건 조정

```java
// TODO: Fallback 조건 변경

// 현재: 내부 DB 결과가 완전히 없을 때만 API 호출
if (internalBooks.isEmpty()) {
    libraryBooks = searchLibraryAPI(...);
}

// 개선해보기
// 1. 내부 DB 결과가 limit 미만이면 API 호출?
// 2. 특정 키워드가 있으면 무조건 API 호출?
// 3. 사용자가 "전국"을 명시하면 API 호출?
```

### 미션 2: 결과 우선순위 변경

```java
// TODO: 중복 제거 시 우선순위 로직 변경

// 현재: 내부 DB 우선
(existing, replacement) -> "내부 DB".equals(existing.source()) ? existing : replacement

// 개선해보기
// 1. 대출 가능 여부를 고려?
// 2. 정보가 더 완전한 책을 우선?
// 3. 최신 정보를 우선?
```

### 미션 3: 로그를 통한 Fallback 확인

```java
// TODO: 로그를 확인하여 Fallback 동작 확인하기

// 검색 후 로그 확인:
// [Function] 내부 DB 검색 결과: 0권
// [Function] 내부 DB에 결과 없음, 도서관정보나루 검색 시작
// [Function] 도서관정보나루 검색 결과: 50권
// [Function] 최종 결과: 50권 (내부 DB: 0권, 도서관정보나루: 50권)
```

---

## 7. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

- [ ] 외부 API 클라이언트를 구현할 수 있다
- [ ] Fallback 패턴을 구현할 수 있다
- [ ] 내부 DB와 외부 API의 검색 결과를 통합할 수 있다
- [ ] 데이터 출처를 추적할 수 있다
- [ ] 중복 제거 로직을 구현할 수 있다
- [ ] 캐싱으로 API 비용을 절감할 수 있다

---

## 8. 현재까지 구현한 것

✅ **완료:**
- 단일 Function 구현 (Level 1)
- 외부 API 클라이언트
- Fallback 패턴 (Level 2)
- 데이터 출처 추적
- 중복 제거
- 캐싱 적용

❓ **다음 단계:**
- 다중 함수 조합 (Level 3)
- 오케스트레이션 패턴
- 복잡한 시나리오 처리

---

## 9. 다음 단계

Level 2를 완료하셨습니다! 다음 단계에서는:

**Level 3: 다중 Function 오케스트레이션**
- 리뷰 조회 함수 추가
- 여러 함수 연속 호출
- 함수 간 데이터 전달
- 복잡한 사용자 요청 처리

[다음: 04. AI 오케스트레이션 →](04.ai-orchestration.md)
