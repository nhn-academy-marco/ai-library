# 리뷰 정보를 RAG 검색에 반영하기

## 개요

Step 4의 **04. 리뷰 요약 시스템**에서 구현한 리뷰 요약 기능을 Step 2의 **RAG 검색 시스템**과 연동하여, 사용자에게 더 똑똑한 도서 추천을 제공합니다.

**현재 상황:**
- ✅ 리뷰 데이터 수집 (BookReview)
- ✅ 리뷰 통계 계산 (BookReviewSummary)
- ✅ AI 리뷰 요약 생성 (reviewSummary)
- ❌ RAG 검색에 리뷰 정보 반영 (미구현)

**목표:**
```
사용자: "주식 투자 좋은 책 추천해"

현재 시스템:
→ LLM: "이 책들은 주식과 관련이 있습니다."

개선된 시스템:
→ LLM: "평점 4.8점(127개 리뷰)의 '주식 입문'은 초보자에게 강력 추천됩니다.
       리뷰어들이 '설명이 쉽고 실전 예제가 많다'고 평가했습니다."
```

---

## 학습 목표

- **현재 시스템 분석**: 리뷰 정보가 어디에 있는지 파악
- **데이터 흐름 이해**: 리뷰가 RAG의 LLM 프롬프트까지 도달하는 경로 이해
- **DTO 설계**: 검색 결과에 리뷰 정보 추가
- **쿼리 최적화**: N+1 문제 없이 리뷰 정보 조회
- **프롬프트 엔지니어링**: LLM에게 리뷰 정보를 효과적으로 전달

---

## 전체 아키텍처

### 현재 아키텍처 (리뷰 미반영)

```
┌─────────────────────────────────────────────────────────┐
│                  1. 검색 요청                          │
│         "주식 투자 좋은 책 추천해"                      │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│          2. 하이브리드 검색 (Vector + Keyword)           │
│  결과: [A: 75점, B: 70점, C: 65점, D: 60점]          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              3. LLM 추천 사유 생성                      │
│  전달 데이터: 도서 ID, 제목, 저자, 출판일, 내용         │
│                                                           │
│  프롬프트:                                                │
│  "ID: 101, 제목: 주식 입문, 저자: 김철수,                │
│   출판일: 2020-01-01, 내용: 주식의 기본 개념..."          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│               4. 사용자에게 결과 반환                    │
│  "주식과 관련된 도서들을 찾았습니다."                    │
└─────────────────────────────────────────────────────────┘

[문제]
리뷰 정보가 BookReviewSummary 테이블에 있는데,
LLM에게 전달되지 않음!
```

---

### 개선된 아키텍처 (리뷰 반영)

```
┌─────────────────────────────────────────────────────────┐
│                  1. 검색 요청                          │
│         "주식 투자 좋은 책 추천해"                      │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│          2. 하이브리드 검색 (Vector + Keyword)           │
│  결과: [A: 75점, B: 70점, C: 65점]                    │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│         3. 리뷰 정보 조인 (JOIN)                        │
│  BookSearchResponse + BookReviewSummary                │
│                                                           │
│  추가 데이터:                                              │
│  - averageRating: 4.8                                    │
│  - reviewCount: 127                                      │
│  - reviewSummary: "초보자에게 정말 좋습니다..."           │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              4. LLM 추천 사유 생성 (개선)               │
│  전달 데이터: 도서 정보 + 리뷰 정보                      │
│                                                           │
│  프롬프트:                                                │
│  "ID: 101, 제목: 주식 입문, 저자: 김철수,                │
│   평점: 4.8/5.0(127개),                                  │
│   리뷰 요약: '초보자에게 정말 좋습니다. 설명이 쉬워요.',  │
│   출판일: 2020-01-01, 내용: 주식의 기본 개념..."          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│               5. 사용자에게 결과 반환                    │
│  "평점 4.8점의 '주식 입문'은 초보자에게 강력 추천됩니다."  │
└─────────────────────────────────────────────────────────┘
```

---

## 핵심 개념 이해

### 1. 데이터 분석

**BookReviewSummary 테이블 (04.review-summarization.md에서 구현)**

| 필드명 | 타입 | 설명 | 예시 |
|--------|------|------|------|
| book_id | BIGINT | 도서 ID (PK) | 101 |
| review_count | BIGINT | 리뷰 개수 | 127 |
| average_rating | NUMERIC(3,2) | 평균 평점 | 4.80 |
| rating_1~5_count | INTEGER | 별점별 개수 | 2, 3, 5, 20, 97 |
| review_summary | TEXT | AI 생성 요약 | "초보자에게..." |
| last_reviewed_at | TIMESTAMP | 최종 리뷰 시간 | 2024-01-10 |

**현재 BookSearchResponse (리뷰 정보 없음)**

```
필드:
- id: 도서 ID
- title: 제목
- authorName: 저자명
- bookContent: 도서 내용
- similarity: 유사도
- rrfScore: RRF 점수

평점 없음
리뷰 요약 없음
```

---

### 2. 해결 전략

**Option 1: BookSearchResponse에 필드 추가 (추천)**

장점:
- 간단하고 직관적
- DTO 하나로 모든 정보 전달

단점:
- 항상 모든 필드 조회 (null 처리 필요)

**Option 2: 별도 DTO 조립**

장점:
- 필요할 때만 조립
- null 처리 깔끔

단점:
- 코드 복잡도 증가

**결정: Option 1 사용**

리뷰가 없는 도서도 많으므로 null 처리는 필수적이고,
코드 단순화가 더 중요함

---

### 3. 데이터 흐름

```
[DB 조회]
    │
    ├─ Book 테이블 → 도서 기본 정보
    └─ BookReviewSummary 테이블 → LEFT JOIN
                                      │
                                      ▼
                               [리뷰 정보 조립]
                                      │
                                      ▼
                               [BookSearchResponse]
                               (평점, 리뷰 수, 요약 포함)
                                      │
                                      ▼
                               [AiRecommendationService]
                               (LLM 프롬프트 생성)
                                      │
                                      ▼
                               [LLM API 호출]
                               (리뷰 정보 포함)
                                      │
                                      ▼
                               [추천 사유 생성]
```

---

## 구현 가이드

### Phase 1: BookSearchResponse에 리뷰 필드 추가

**목표:** 검색 결과 DTO에 리뷰 정보를 담을 필드 만들기

**추가할 필드:**

| 필드명 | 타입 | 설명 | null 가능 여부 |
|--------|------|------|---------------|
| averageRating | BigDecimal | 평균 평점 | O (리뷰 없을 수 있음) |
| reviewCount | Long | 리뷰 개수 | O |
| reviewSummary | String | 리뷰 요약 | O |

**구현 포인트:**
- 기존 생성자 유지 (하위 호환성)
- 새로운 생성자 추가 (리뷰 정보 포함)
- from() 메서드에서 리뷰 정보 조립

**학습 포인트:**
- DTO 확장 전략
- Optional 데이터 처리
- 하위 호환성 유지

---

### Phase 2: Repository에서 리뷰 정보 JOIN 조회

**목표:** 검색 시 리뷰 정보도 함께 조회하기

**문제: N+1 문제**

현재 방식 (N+1 문제 발생):
```
1. 도서 100권 조회 (1번 쿼리)
2. 각 도서마다 리뷰 조회 (100번 쿼리)
→ 총 101번 쿼리!
```

**해결: Query Projection 사용**

```
1. 도서와 리뷰를 LEFT JOIN (1번 쿼리)
→ BookResponse에 리뷰 정보도 함께 조회
```

**구현 포인트:**
- QueryDSL의 @QueryProjection 활용
- LEFT JOIN (리뷰가 없는 도서도 조회)
- DTO 변환 로직 수정

**학습 포인트:**
- N+1 문제 이해
- Query Projection으로 해결
- LEFT JOIN vs INNER JOIN 차이

---

### Phase 3: AiRecommendationService 프롬프트 수정

**목표:** LLM에게 리뷰 정보를 전달하도록 프롬프트 수정

**현재 구현된 코드 (AiRecommendationService.java:46-52):**
```java
StringBuilder context = new StringBuilder();
for (BookSearchResponse book : sortedBooks) {
    context.append(String.format(
        "ID: %d, 제목: %s, 저자: %s, 출판일: %s, 내용: %s\n",
        book.getId(),
        book.getTitle(),
        book.getAuthorName(),
        book.getEditionPublishDate() != null ? book.getEditionPublishDate().toString() : "알 수 없음",
        book.getBookContent() != null ? book.getBookContent() : "내용 없음"
    ));
}
```

**현재 생성되는 프롬프트 예시:**
```
도서 데이터:
ID: 101, 제목: 주식 입문, 저자: 김철수, 출판일: 2020-01-01, 내용: 주식의 기본 개념을 설명합니다...
ID: 102, 제목: 파이썬 코딩, 저자: 이영희, 출판일: 2021-03-15, 내용: 파이썬 기초부터...
```

**문제점:**
- 리뷰 정보(평점, 리뷰 수, 리뷰 요약)가 없음
- LLM이 사용자 피드백을 반영하지 못함

---

**개선된 코드 (리뷰 정보 추가):**
```java
@Slf4j
public class AiRecommendationService {

    private static final int MAX_REVIEW_SUMMARY_LENGTH = 100;

    public List<BookAiRecommendationResponse> recommend(String question, List<BookSearchResponse> books) {
        // ... 정렬 로직 ...

        StringBuilder context = new StringBuilder();
        for (BookSearchResponse book : sortedBooks) {
            // 평점 정보 구성
            String ratingInfo = formatRatingInfo(book);

            // 리뷰 요약 구성 (100자 제한, null 처리)
            String summaryInfo = formatReviewSummary(book.getReviewSummary());

            // 컨텍스트 구성
            StringBuilder bookContext = new StringBuilder();
            bookContext.append(String.format("ID: %d, 제목: %s, 저자: %s",
                book.getId(), book.getTitle(), book.getAuthorName()));

            // 평점 정보가 있으면 추가
            if (!ratingInfo.isEmpty()) {
                bookContext.append(", ").append(ratingInfo);
            }

            // 리뷰 요약이 있으면 추가
            if (!summaryInfo.isEmpty()) {
                bookContext.append(", ").append(summaryInfo);
            }

            // 출판일과 내용 추가
            bookContext.append(String.format(", 출판일: %s, 내용: %s\n",
                book.getEditionPublishDate() != null ? book.getEditionPublishDate().toString() : "알 수 없음",
                book.getBookContent() != null ? book.getBookContent() : "내용 없음"));

            context.append(bookContext);

            log.debug("[컨텍스트 생성] ID={}, 평점={}, 리뷰수={}, 요약길이={}",
                book.getId(),
                book.getAverageRating(),
                book.getReviewCount(),
                summaryInfo.length());
        }

        // ... 프롬프트 생성 및 AI 호출 ...
    }

    /**
     * 평점 정보 포맷팅
     *
     * @return "평점: 4.8/5.0(127개 리뷰)" 또는 빈 문자열
     */
    private String formatRatingInfo(BookSearchResponse book) {
        if (book.getAverageRating() != null
                && book.getReviewCount() != null
                && book.getReviewCount() > 0) {
            return String.format("평점: %.1f/5.0(%d개 리뷰)",
                book.getAverageRating(),
                book.getReviewCount());
        }
        return "";  // 리뷰 없으면 빈 문자열
    }

    /**
     * 리뷰 요약 포맷팅
     *
     * @return "요약: '리뷰 내용...'" 또는 빈 문자열
     */
    private String formatReviewSummary(String summary) {
        if (summary == null || summary.isBlank()) {
            return "";  // 요약 없으면 빈 문자열
        }

        // 100자 제한
        String truncated = summary.length() > MAX_REVIEW_SUMMARY_LENGTH
            ? summary.substring(0, MAX_REVIEW_SUMMARY_LENGTH) + "..."
            : summary;

        return String.format("요약: \"%s\"", truncated);
    }
}
```

**개선된 프롬프트 예시:**
```
도서 데이터:
ID: 101, 제목: 주식 입문, 저자: 김철수, 평점: 4.8/5.0(127개 리뷰), 출판일: 2020-01-01, 내용: 주식의 기본 개념을 설명합니다...
ID: 102, 제목: 파이썬 코딩, 저자: 이영희, 평점: 4.5/5.0(89개 리뷰), 출판일: 2021-03-15, 내용: 파이썬 기초부터...
ID: 103, 제목: 신간 SQL, 저자: 박민수, 출판일: 2024-01-10, 내용: 최신 SQL... (리뷰 없음)
```

**프롬프트 규칙에 리뷰 고려 사항 추가:**

기존 규칙에 다음 내용을 추가:
```
[규칙 - 리뷰 정보 반영]
- 평점이 4.0 이상인 도서를 우선적으로 고려하세요
- 리뷰가 20개 이상인 도서는 검증된 도서로 판단하고 신뢰도를 높게 평가하세요
- 리뷰 요약의 내용을 참고하여 구체적인 추천 사유를 작성하세요
  - 예: "리뷰어들이 '설명이 쉽고 실전 예제가 많다'고 평가했습니다"
- 리뷰가 없는 도서는 "리뷰 정보가 없어 신규 도서입니다"라고 언급하세요
- 평점과 리뷰 수를 relevance 점수에 반영하세요
```

**전체 프롬프트 template 예시:**
```java
String template = """
    [규칙]
    - 사용자가 제공하는 query와 가장 관련 있는 도서를 선별하세요.
    - 각 도서에 대해 relevance 점수(0~100)를 부여하세요:
      - 90–100: query와 직접적으로 강하게 연관, 주제 적합성이 매우 높음
      - 70–89: query와 밀접하게 관련 있지만 일부 범위가 제한적임
      - 50–69: query와 간접적으로 관련, 배경 지식에 도움이 됨
      - 50 미만: 관련성이 낮으므로 출력에서 제외
    - 추천 사유("why")에는 점수를 포함하지 말고, 순수하게 이유만 설명하세요.
    - 추천 사유("why")는 사용자에게 친절하고 공손한 어투(예: "~입니다", "~를 추천해 드립니다")로 작성하세요.
    - 추천 사유를 명확히 알 수 없는 경우에는 "추천 사유를 모름" 또는 "추천 사유를 명확히 알 수 없습니다"와 같이 명확하게 모른다는 표현을 사용하세요.
    - 최신 출간일과 query와의 직접적인 관련성을 함께 고려하세요.

    [규칙 - 리뷰 정보 반영]
    - 평점과 리뷰 수를 relevance 점수에 반영하세요:
      - 평점 4.5 이상 + 리뷰 20개 이상: relevance +5점 (검증된 인기 도서)
      - 평점 4.0 이상 + 리뷰 20개 이상: relevance +3점 (검증된 도서)
      - 평점 3.5 미만: relevance -10점 (부정적 평가)
      - 리뷰 없음: relevance ±0점 (변동 없음)

    - 평점이 4.0 이상인 도서를 우선적으로 고려하세요.
    - 리뷰가 20개 이상인 도서는 검증된 도서로 판단하고 신뢰도를 높게 평가하세요.
    - 리뷰 요약이 있는 경우, 요약의 내용을 참고하여 구체적인 추천 사유를 작성하세요.
      - 예: "리뷰어들이 '설명이 쉽고 실전 예제가 많다'고 평가했습니다."
    - 평점이 3.5 미만인 도서는 주의를 권장하세요.
      - 예: "평점이 3.2/5.0로 평가가 엇갈립니다. 리뷰 내용을 확인해보세요."
    - 리뷰가 없는 신간 도서는 "신간 도서로 아직 리뷰가 없습니다"라고 언급하고, 최신성과 내용의 관련성을 더 중요하게 평가하세요.

    [출력 형식]
    - 출력은 반드시 순수 JSON만 포함하세요.
    - 마크다운 코드 블록(```json ... ```)이나 추가 설명 텍스트는 절대 포함하지 마세요.
    - 언어는 반드시 한국어를 사용하세요.

    [JSON STRUCTURE]
     [
        {
          "id": 123,
          "relevance": 95,
          "why": "추천 사유"
        }
     ]

    - 결과는 relevance 기준 내림차순으로 정렬하세요.
    - 입력 데이터에 없는 필드는 추측하지 마세요.

    query: {question}

    도서 데이터:
    {context}
    """;
```

**LLM 응답 예시 (리뷰 정보 반영):**
```json
[
  {
    "id": 101,
    "relevance": 95,
    "why": "평점 4.8/5.0(127개 리뷰)의 '주식 입문'은 초보자에게 강력 추천됩니다. 리뷰어들이 '설명이 쉽고 실전 예제가 많다'고 평가했습니다."
  },
  {
    "id": 102,
    "relevance": 88,
    "why": "평점 4.5/5.0(89개 리뷰)로 검증된 도서입니다. 파이썬 기초부터 탄탄하게 다룹니다."
  },
  {
    "id": 103,
    "relevance": 72,
    "why": "신간 도서로 아직 리뷰가 없지만, 최신 SQL 내용을 다루고 있어 관련성이 높습니다."
  },
  {
    "id": 104,
    "relevance": 45,
    "why": "평점이 3.2/5.0로 평가가 엇갑립니다. 리뷰 내용을 확인해보시고 신중하게 고려하세요."
  }
]
```

**응답 예시 설명:**
- **101 (relevance 95)**: 평점 4.8 + 리뷰 127개 = 검증된 인기 도서
- **102 (relevance 88)**: 평점 4.5 + 리뷰 89개 = 검증된 도서
- **103 (relevance 72)**: 신간 도서 (리뷰 없음) = 최신성 반영
- **104 (relevance 45)**: 평점 3.2 = 부정적 평가로 relevance 감점

**구현 포인트:**
- 평점 포맷팅: `"%.1f/5.0(%d개 리뷰)"` 또는 빈 문자열
- 리뷰 요약 100자 제한 (토큰 절약)
- null 체크 (NPE 방지)
- 로그로 컨텍스트 생성 과정 디버깅

**학습 포인트:**
- 프롬프트 엔지니어링: 리뷰 정보를 LLM에게 효과적으로 전달
- 조건부 로직: 리뷰 있음/없음 처리
- 토큰 최적화: 요약 길이 제한
- @Slf4j 로깅: 디버깅과 모니터링

---

### Phase 4: 테스트 및 검증

**목표:** 리뷰 정보가 정상적으로 반영되는지 확인

**테스트 시나리오:**

1. **리뷰 있는 도서 검색**
   - 평점 4.5점 이상, 리뷰 20개 이상 도서
   - LLM 추천 사유에 평점/리뷰 요약이 포함되는지 확인

2. **리뷰 없는 도서 검색**
   - 신간 도서 (리뷰 0개)
   - LLM이 적절하게 처리하는지 확인

3. **리뷰 요약 없는 도서 검색**
   - 리뷰 1~4개 (요약 생성 안됨)
   - 평점만 있는 경우 처리 확인

**검증 포인트:**
- 평점이 LLM 추천에 반영되는지
- 리뷰 요약이 추천 사유에 인용되는지
- 리뷰 없는 도서의 처리가 적절한지

---

## 데이터 흐름 상세

### 1단계: 검색 요청

```
사용자 입력
"주식 투자 좋은 책 추천해"
    ↓
[BookSearchService.searchBooks()]
    ↓
[EmbeddingService.getEmbedding()]
    ↓
[VectorSearchStrategy + KeywordSearchStrategy]
```

---

### 2단계: 결과 조회

```
[Repository Query]
SELECT b.*, rs.*
FROM books b
LEFT JOIN book_review_summary rs ON b.id = rs.book_id
WHERE <검색 조건>
    ↓
[BookSearchResponse 생성]
- title: "주식 입문"
- authorName: "김철수"
- averageRating: 4.8  ← 새로 추가
- reviewCount: 127      ← 새로 추가
- reviewSummary: "초보자에게..." ← 새로 추가
```

---

### 3단계: LLM 프롬프트 생성

```
[AiRecommendationService.recommend()]

Context 생성:
for (BookSearchResponse book : books) {
    context.append(String.format(
        "ID: %d, 제목: %s, 저자: %s, 평점: %s(%d개), 요약: %s, 내용: %s\n",
        book.getId(),
        book.getTitle(),
        book.getAuthorName(),
        formatRating(book.getAverageRating()),    // "4.8/5.0"
        book.getReviewCount(),                   // 127
        truncate(book.getReviewSummary(), 100),  // 100자 제한
        book.getBookContent()
    ));
}
```

---

### 4단계: LLM 응답

```
[LLM 출력]
[
  {
    "id": 101,
    "relevance": 92,
    "why": "평점 4.8/5.0(127개 리뷰)의 '주식 입문'은 초보자에게 강력 추천됩니다.
          리뷰어들이 '설명이 쉽고 실전 예제가 많다'고 평가했습니다."
  }
]
```

---

## 주의사항

### 1. 리뷰 없는 도서 처리

**문제:**
- 신간 도서는 리뷰가 없음
- averageRating = null
- reviewCount = 0

**해결:**
```java
String ratingPart;
if (book.getAverageRating() != null && book.getReviewCount() > 0) {
    ratingPart = String.format("평점: %.1f/5.0(%d개 리뷰)",
        book.getAverageRating(),
        book.getReviewCount());
} else {
    ratingPart = "";  // 빈 문자열로 처리
}
```

**결과 예시:**
```
[평점 있는 도서]
ID: 101, 제목: 주식 입문, 저자: 김철수, 평점: 4.8/5.0(127개 리뷰), 출판일: 2020-01-01, ...

[리뷰 없는 도서]
ID: 103, 제목: 신간 SQL, 저자: 박민수, 출판일: 2024-01-10, ...
(평점 필드 자체가 포함되지 않음)
```

---

### 2. 리뷰 요약이 없는 도서 처리

**문제:**
- 리뷰 1~4개: 평점은 있지만 요약 생성 안됨 (04 문서 기준)
- reviewSummary = null
- LLM에게 요약을 전달하지 못함

**해결:**
```java
String summaryPart;
if (book.getReviewSummary() != null && !book.getReviewSummary().isBlank()) {
    String truncated = book.getReviewSummary().length() > 100
        ? book.getReviewSummary().substring(0, 100) + "..."
        : book.getReviewSummary();
    summaryPart = String.format("요약: \"%s\"", truncated);
} else {
    summaryPart = "";  // 빈 문자열로 처리
}
```

**결과 예시:**
```
[요약 있는 도서]
ID: 101, 제목: 주식 입문, ..., 평점: 4.8/5.0(127개 리뷰), 요약: "초보자에게 정말 좋습니다. 설명이 쉽고...", ...

[요약 없는 도서 (리뷰 1~4개)]
ID: 102, 제목: 자바 기초, ..., 평점: 4.0/5.0(3개 리뷰), 출판일: 2023-05-10, ...
(요약 필드가 포함되지 않음)
```

---

### 3. 리뷰 요약 길이 제한

**문제:**
- 리뷰 요약이 길면 프롬프트가 너무 길어짐
- 토큰 제한 초과 가능

**해결:**
```java
private static final int MAX_SUMMARY_LENGTH = 100;

String truncate(String summary) {
    if (summary == null) return "";
    if (summary.length() <= MAX_SUMMARY_LENGTH) return summary;
    return summary.substring(0, MAX_SUMMARY_LENGTH) + "...";
}
```

---

### 3. 성능 고려사항

**N+1 문제 방지:**
- Query Projection으로 한 번의 쿼리로 조회
- @EntityGraph 활용 가능

**쿼리 최적화:**
```sql
-- 좋은 예
SELECT b.*, rs.review_count, rs.average_rating, rs.review_summary
FROM books b
LEFT JOIN book_review_summary rs ON b.id = rs.book_id
WHERE b.id IN (101, 102, 103, ...)

-- 나쁜 예 (N+1 문제)
SELECT * FROM books WHERE id IN (101, 102, 103, ...)
SELECT * FROM book_review_summary WHERE book_id = 101  -- 반복!
SELECT * FROM book_review_summary WHERE book_id = 102  -- 반복!
...
```

---

## 학습 체크리스트

### 개념 이해
- [ ] 현재 시스템에서 리뷰 정보가 어디에 저장되는지 안다
- [ ] 왜 리뷰 정보를 RAG에 반영해야 하는지 이해한다
- [ ] 데이터 흐름을 이해한다 (DB → DTO → LLM)
- [ ] N+1 문제가 무엇인지 안다
- [ ] LEFT JOIN과 INNER JOIN의 차이를 안다

### 구현 능력
- [ ] BookSearchResponse에 리뷰 필드를 추가할 수 있다
- [ ] QueryDSL @QueryProjection을 활용할 수 있다
- [ ] AiRecommendationService 프롬프트를 수정할 수 있다
- [ ] null 데이터를 적절하게 처리할 수 있다
- [ ] 프롬프트 길이를 제한할 수 있다

### 아키텍처 설계
- [ ] DTO 확장 전략을 이해한다
- [ ] 성능과 기능의 트레이드오프를 판단할 수 있다
- [ ] LLM 프롬프트 엔지니어링 기초를 안다
- [ ] 하위 호환성을 유지하면서 기능을 확장할 수 있다

---

## 다음 단계

이제 여러분은:
- 리뷰 정보를 RAG 검색에 반영할 수 있습니다
- N+1 문제를 피하는 조회 전략을 알게 되었습니다
- LLM 프롬프트 엔지니어링을 경험했습니다
- 실제 데이터 평점과 사용자 피드백을 AI 활용에 연결했습니다

**Step 5로 넘어가기 전에 확인하세요:**
- [ ] 04.review-summarization.md 완료
- [ ] 리뷰 요약 시스템 구현
- [ ] RabbitMQ 기반 큐 시스템 이해
- [ ] 05.review-rag-integration.md 완료 (본 문서)
- [ ] 리뷰 정보 RAG 반영 구현

**다음에 도전해 볼 수 있는 것들**
- Step 5: Telegram Bot 연동
- Step 5: 사용자 피드백 수집
- 리뷰 감성 분석 (긍정/부정 비율)
- A/B 테스트로 리뷰 반영 효과 측정

---

**마지막 조언**

> "리뷰는 사용자들의 목소리입니다. 이 목소리를 AI가 들을 수 있도록 연결하는 것이 우리의 몫입니다.
> 평점 하나만 추가해도 LLM의 추천 품질은 크게 향상됩니다.
> 코드는 직접 작성하면서 학습하세요. 전체 흐름과 구조를 이해하는 것이 가장 중요합니다!
> 리뷰 요약 시스템(04)과 RAG 연동(05)을 완료하면 진정한 AI 도서 추천 시스템이 완성됩니다."
