# 03. 결과 캐싱: 비용 절감과 성능 향상

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- Week 4의 01, 02 문서 내용 (성능과 비용, Top-K 최적화)
- Week 1의 이벤트 기반 아키텍처 이해
- 기본적인 캐싱 개념
- 코사인 유사도 이해 (Week 2)

---

## 1. 개요

동일한 질문이 반복되면 매번 AI를 호출하는 것이 낭비입니다. 이전 결과를 저장했다가 재사용하면 비용을 절약하고 응답 속도를 높일 수 있습니다.

**이 문서에서 배울 내용:**
- 캐싱(Caching)이 무엇인지
- 시맨틱 캐싱(Semantic Caching)이란 무엇인지
- 이벤트 기반 웜업(Warm-up) 전략
- 코사인 유사도를 활용한 캐시 매칭
- TTL(Time To Live) 정책

> **캐싱의 핵심**
>
> **캐싱 없음:**
> - 질문: "자바 책 추천해줘"
> - 1번째: AI 호출 ($0.10)
> - 2번째: AI 호출 ($0.10)
> - 3번째: AI 호출 ($0.10)
> - 총비용: $0.30 (낭비)
>
> **캐싱 있음:**
> - 질문: "자바 책 추천해줘"
> - 1번째: AI 호출 → 캐시 저장 ($0.10)
> - 2번째: 캐시 사용 ($0.00)
> - 3번째: 캐시 사용 ($0.00)
> - 총비용: $0.10
>
> **70% 비용 절감!**

---

## 2. 핵심 개념 이해

### 2.1. 캐싱(Caching)이란?

자주 사용하는 데이터를 빠른 저장소에 두고 재사용하는 기술입니다.

**비유로 이해하기:**
```
[도서관에서 책 찾기]

캐싱 없음:
- 질문: "자바의 정석 어디 있어?"
- 1번째: 사서가 찾아봄 (5분)
- 2번째: 사서가 다시 찾아봄 (5분)
- 3번째: 사서가 또 찾아봄 (5분)
→ 매번 느림

캐싱 있음:
- 질문: "자바의 정석 어디 있어?"
- 1번째: 사서가 찾아봄 → 메모장에 위치 적음 (5분)
- 2번째: 메모장 보고 즉시 답변 (1초)
- 3번째: 메모장 보고 즉시 답변 (1초)
→ 2번째부터 빠름
```

### 2.2. 시맨틱 캐싱(Semantic Caching)

질문의 **의미**가 비슷하면 같은 질문으로 취급합니다.

**비교:**
```
[일반적인 캐싱 - 정확히 일치해야 함]
질문1: "자바 책 추천해줘"
질문2: "자바 책 추천해줘"
→ 캐시 적중

질문1: "자바 책 추천해줘"
질문2: "자바 교재 알려줘"
→ 캐시 미적중 (문자가 다름)

[시맨틱 캐싱 - 의미가 비슷하면 적중]
질문1: "자바 책 추천해줘"
질문2: "자바 책 추천해줘"
→ 캐시 적중

질문1: "자바 책 추천해줘"
질문2: "자바 교재 알려줘"
→ 캐시 적중 (의미가 비슷함)
질문3: "초보자용 자바 도서"
→ 캐시 적중 (의미가 비슷함)
```

**작동 원리:**
```
1. 질문 임베딩
   "자바 책 추천해줘" → [0.1, 0.2, ...]

2. 기존 캐시와 유사도 비교
   캐시1: "자바 책 추천" → [0.12, 0.18, ...]
   코사인 유사도: 0.98 → 매우 비슷함

3. 유사도가 임계값 이상이면 캐시 사용
   임계값: 0.95
   0.98 >= 0.95 → 캐시 적중
```

### 2.3. 이벤트 기반 웜업(Warm-up)

자주 검색되는 질문은 미리 캐시를 만들어둡니다.

**비유로 이해하기:**
```
[레스토랑 준비]

웜업 없음:
- 손님: "스테이크 주문"
- 요리사: 바로 요리 시작 (20분)
→ 손님 오래 기다림

웜업 있음:
- 오픈 전: 미리 스테이크 5인분 조리
- 손님: "스테이크 주문"
- 직원: 즉시 서빙 (1분)
→ 손님 바로 받음
```

**도서 검색에서의 웜업:**
```
자주 검색되는 질문 TOP 10:
1. "자바 책 추천"
2. "파이썬 입문"
3. "데이터베이스 공부"
...

서버 시작 시:
→ 이 10개 질문 미리 검색해서 캐시 저장
→ 사용자가 검색하면 즉시 응답 ✅
```

### 2.4. TTL (Time To Live)

캐시의 유효기간입니다. 너무 오래된 캐시는 폐기합니다.

**비유로 이해하기:**
```
[유통기한이 있는 식품]

유통기간 없음:
- 1년 전 샌드위치 먹음
→ 배탈 날 수 있음

유통기간 있음:
- 1시간 전 샌드위치 먹음 (안전)
- 3일 전 샌드위치 폐기 (부적합)
```

**캐시에서의 TTL:**
```
TTL = 1시간

10:00 → 캐시 생성
10:30 → 캐시 사용 (30분 경과)
11:00 → 캐시 만료 (1시간 경과)
11:01 → 다시 AI 호출해서 새 캐시 생성
```

---

## 3. 구현 가이드 (Step-by-Step)

### STEP 1: 캐시 엔티티 생성

검색 결과를 저장할 엔티티를 만듭니다.

**BookSearchCache.java**
```java
package com.nhnacademy.library.core.book.entity;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

/**
 * 도서 검색 캐시 엔티티
 *
 * 검색 결과를 저장해서 재사용합니다.
 */
@Entity
@Table(name = "book_search_cache")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BookSearchCache {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * 검색 질문
     */
    @Column(nullable = false, length = 500)
    private String query;

    /**
     * 질문 임베딩 (시맨틱 매칭용)
     */
    @Column(nullable = false, columnDefinition = "vector(1024)")
    private Vector queryEmbedding;

    /**
     * 캐시된 검색 결과 (JSON)
     */
    @Column(nullable = false, columnDefinition = "TEXT")
    private String result;

    /**
     * 생성 시간
     */
    @Column(nullable = false)
    private LocalDateTime createdAt;

    /**
     * 마지막 접근 시간
     */
    @Column(nullable = false)
    private LocalDateTime lastAccessedAt;

    /**
     * 접근 횟수
     */
    @Column(nullable = false)
    private Integer accessCount;

    /**
     * TTL (초 단위)
     */
    @Column(nullable = false)
    private Integer ttl;
}
```

### STEP 2: 시맨틱 캐시 서비스 구현

코사인 유사도를 활용한 캐시 서비스를 만듭니다.

**SemanticCacheService.java**
```java
package com.nhnacademy.library.core.book.service.cache;

import com.nhnacademy.library.core.book.entity.BookSearchCache;
import com.nhnacademy.library.core.book.repository.BookSearchCacheRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.ai.embedding.EmbeddingResponse;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * 시맨틱 캐시 서비스
 *
 * 질문의 의미가 비슷하면 캐시를 재사용합니다.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class SemanticCacheService {

    private final BookSearchCacheRepository cacheRepository;
    private final EmbeddingModel embeddingModel;

    // 코사인 유사도 임계값
    private static final double SIMILARITY_THRESHOLD = 0.95;

    // 기본 TTL (1시간)
    private static final int DEFAULT_TTL = 3600;

    /**
     * 캐시에서 결과 조회
     *
     * @param query 검색 질문
     * @return 캐시된 결과 (없으면 empty)
     */
    public Optional<String> get(String query) {
        log.info("캐시 조회: {}", query);

        // 1. 질문 임베딩 생성
        EmbeddingResponse embeddingResponse = embeddingModel.embedForResponse(List.of(query));
        float[] queryEmbedding = embeddingResponse.getResults().get(0).getOutput();

        // 2. 만료된 캐시 정리
        cacheRepository.deleteExpiredCaches(LocalDateTime.now());

        // 3. 가장 비슷한 캐시 찾기
        List<BookSearchCache> allCaches = cacheRepository.findAll();

        BookSearchCache bestMatch = null;
        double bestSimilarity = 0.0;

        for (BookSearchCache cache : allCaches) {
            double similarity = cosineSimilarity(
                    queryEmbedding,
                    cache.getQueryEmbedding()
            );

            if (similarity > bestSimilarity) {
                bestSimilarity = similarity;
                bestMatch = cache;
            }
        }

        // 4. 유사도가 임계값 이상이면 캐시 반환
        if (bestMatch != null && bestSimilarity >= SIMILARITY_THRESHOLD) {
            log.info("캐시 적중! 유사도: {}", bestSimilarity);

            // 접근 정보 업데이트
            bestMatch.setLastAccessedAt(LocalDateTime.now());
            bestMatch.setAccessCount(bestMatch.getAccessCount() + 1);
            cacheRepository.save(bestMatch);

            return Optional.of(bestMatch.getResult());
        }

        log.info("캐시 미적중 (최고 유사도: {})", bestSimilarity);
        return Optional.empty();
    }

    /**
     * 캐시에 결과 저장
     *
     * @param query 검색 질문
     * @param result 검색 결과 (JSON)
     */
    public void put(String query, String result) {
        log.info("캐시 저장: {}", query);

        // 1. 질문 임베딩 생성
        EmbeddingResponse embeddingResponse = embeddingModel.embedForResponse(List.of(query));
        float[] queryEmbedding = embeddingResponse.getResults().get(0).getOutput();

        // 2. 캐시 생성
        BookSearchCache cache = BookSearchCache.builder()
                .query(query)
                .queryEmbedding(queryEmbedding)
                .result(result)
                .createdAt(LocalDateTime.now())
                .lastAccessedAt(LocalDateTime.now())
                .accessCount(0)
                .ttl(DEFAULT_TTL)
                .build();

        // 3. 저장
        cacheRepository.save(cache);
        log.info("캐시 저장 완료");
    }

    /**
     * 코사인 유사도 계산
     *
     * @param v1 벡터1
     * @param v2 벡터2
     * @return 유사도 (0~1)
     */
    private double cosineSimilarity(float[] v1, float[] v2) {
        double dotProduct = 0.0;
        double norm1 = 0.0;
        double norm2 = 0.0;

        for (int i = 0; i < v1.length; i++) {
            dotProduct += v1[i] * v2[i];
            norm1 += v1[i] * v1[i];
            norm2 += v2[i] * v2[i];
        }

        return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
    }
}
```

### STEP 3: 이벤트 기반 웜업 구현

자주 검색되는 질문을 미리 캐시합니다.

**PopularQueries.java**
```java
package com.nhnacademy.library.core.book.config;

import lombok.Getter;

/**
 * 인기 검색어 상수
 *
 * 자주 검색되는 질문들을 정의합니다.
 */
@Getter
public enum PopularQueries {

    JAVA_BOOKS("자바 책 추천"),
    PYTHON_BOOKS("파이썬 입문책"),
    DATABASE_BOOKS("데이터베이스 공부책"),
    SPRING_BOOKS("스프링 부트 교재"),
    ALGORITHM_BOOKS("알고리즘 문제집"),
    FRONTEND_BOOKS("프론트엔드 개발책"),
    AI_BOOKS("인공지능 입문"),
    CLANGUAGE_BOOKS("C언어 기초");

    private final String query;

    PopularQueries(String query) {
        this.query = query;
    }
}
```

**BookSearchEventListener.java**
```java
package com.nhnacademy.library.core.book.event;

import com.nhnacademy.library.core.book.config.PopularQueries;
import com.nhnacademy.library.core.book.service.cache.SemanticCacheService;
import com.nhnacademy.library.core.book.service.search.BookSearchService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

/**
 * 도서 검색 이벤트 리스너
 *
 * 애플리케이션 시작 시 캐시를 웜업합니다.
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class BookSearchEventListener {

    private final SemanticCacheService semanticCacheService;
    private final BookSearchService bookSearchService;

    /**
     * 애플리케이션 시작 시 캐시 웜업
     *
     * 인기 검색어를 미리 검색해서 캐시를 만듭니다.
     */
    @EventListener(ApplicationReadyEvent.class)
    public void warmUpCache() {
        log.info("=== 캐시 웜업 시작 ===");

        for (PopularQueries popularQuery : PopularQueries.values()) {
            String query = popularQuery.getQuery();

            try {
                log.info("웜업: {}", query);

                // 1. 검색 실행
                var result = bookSearchService.searchBooks(
                        SearchType.HYBRID,
                        query,
                        0,
                        10
                );

                // 2. 결과를 JSON으로 변환
                String resultJson = convertToJson(result);

                // 3. 캐시에 저장
                semanticCacheService.put(query, resultJson);

            } catch (Exception e) {
                log.error("웜업 실패: {}", query, e);
            }
        }

        log.info("=== 캐시 웜업 완료 ===");
    }

    /**
     * 검색 결과를 JSON으로 변환
     */
    private String convertToJson(Object result) {
        // Jackson ObjectMapper 등을 사용해서 JSON 변환
        // 간단하게 구현
        return result.toString();
    }
}
```

### STEP 4: 검색 서비스에 캐싱 적용

검색 서비스에서 캐시를 확인하도록 수정합니다.

**BookSearchService.java - 수정**
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class BookSearchService {

    private final BookSearchCacheRepository cacheRepository;
    private final SemanticCacheService semanticCacheService;
    private final BookKeywordSearchService keywordSearchService;
    private final BookVectorSearchService vectorSearchService;

    /**
     * 도서 검색 (캐싱 적용)
     */
    public List<BookSearchResponse> searchBooks(
            SearchType searchType,
            String query,
            int page,
            int size
    ) {
        log.info("검색 요청: type={}, query={}", searchType, query);

        // 1. 캐시 확인
        Optional<String> cachedResult = semanticCacheService.get(query);

        if (cachedResult.isPresent()) {
            log.info("캐시된 결과 반환");
            return parseSearchResult(cachedResult.get());
        }

        // 2. 캐시 miss → 검색 실행
        List<BookSearchResponse> result = performSearch(searchType, query, page, size);

        // 3. 결과를 캐시에 저장
        semanticCacheService.put(query, convertToJson(result));

        return result;
    }

    /**
     * 실제 검색 수행
     */
    private List<BookSearchResponse> performSearch(
            SearchType searchType,
            String query,
            int page,
            int size
    ) {
        return switch (searchType) {
            case KEYWORD -> keywordSearchService.search(query, page, size);
            case VECTOR -> vectorSearchService.search(query, page, size);
            case HYBRID -> performHybridSearch(query, page, size);
        };
    }
}
```

### STEP 5: TTL 정책 구현

만료된 캐시를 정리하는 스케줄러를 만듭니다.

**CacheCleanupScheduler.java**
```java
package com.nhnacademy.library.core.book.scheduler;

import com.nhnacademy.library.core.book.repository.BookSearchCacheRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

/**
 * 캐시 정리 스케줄러
 *
 * 주기적으로 만료된 캐시를 삭제합니다.
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class CacheCleanupScheduler {

    private final BookSearchCacheRepository cacheRepository;

    /**
     * 매시간 정각에 만료된 캐시 정리
     */
    @Scheduled(cron = "0 0 * * * *")
    public void cleanupExpiredCaches() {
        log.info("만료된 캐시 정리 시작");

        int deletedCount = cacheRepository.deleteExpiredCaches(LocalDateTime.now());

        log.info("만료된 캐시 정리 완료: {}개 삭제", deletedCount);
    }
}
```

**BookSearchCacheRepository.java**
```java
package com.nhnacademy.library.core.book.repository;

import com.nhnacademy.library.core.book.entity.BookSearchCache;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.repository.query.Param;

import java.time.LocalDateTime;

/**
 * 도서 검색 캐시 리포지토리
 */
public interface BookSearchCacheRepository extends JpaRepository<BookSearchCache, Long> {

    /**
     * 만료된 캐시 삭제
     *
     * @param now 현재 시간
     * @return 삭제된 행 수
     */
    @Query("DELETE FROM BookSearchCache c " +
           "WHERE c.createdAt + (c.ttl / 86400.0) days < :now")
    int deleteExpiredCaches(@Param("now") LocalDateTime now);
}
```

---

## 4. 최적화 전략

### 4.1. 캐시 적중률 최적화

**캐시 적중률(Cache Hit Rate):**
```
캐시 적중률 = (캐시 적중 횟수 / 전체 요청 수) × 100%

예시:
- 전체 요청: 100회
- 캐시 적중: 70회
- 캐시 적중률: 70%
```

**최적화 방법:**

| 방법 | 설명 | 효과 |
|------|------|------|
| 웜업 | 자주 검색되는 질문 미리 캐시 | 초기 적중률 상승 |
| 임계값 조정 | 유사도 기준을 낮춤 | 더 많은 적중 |
| TTL 연장 | 캐시 유효기간 늘림 | 재계산 감소 |

### 4.2. 메모리 관리

너무 많은 캐시는 메모리 문제를 일으킬 수 있습니다.

**LRU (Least Recently Used) 전략:**
```
[캐시 사용 패턴]
캐시 A: 10분 전에 마지막 접근
캐시 B: 1분 전에 마지막 접근
캐시 C: 5분 전에 마지막 접근

[메모리 부족 시]
→ 캐시 A 삭제 (가장 오래된 것)
→ 최근에 자주 사용하는 캐시 유지
```

### 4.3. 비용 절감 효과

**비교:**
```
[캐싱 없음]
일일 요청: 1,000회
1회당 비용: $0.10
일일 비용: $100

[캐싱 있음 (적중률 70%)]
일일 요청: 1,000회
- 캐시 적중: 700회 × $0.00 = $0
- AI 호출: 300회 × $0.10 = $30
일일 비용: $30

절감: $70/일 (70%)
월간 절감: $2,100
```

---

## 5. 실습 미션

### 미션 1: 시맨틱 캐시 테스트

```java
@Test
void testSemanticCache() {
    String query1 = "자바 책 추천";
    String query2 = "자바 교재 알려줘";  // 비슷한 의미

    // 1번째 요청 - 캐시 miss
    Optional<String> result1 = semanticCacheService.get(query1);
    assertTrue(result1.isEmpty());

    // 캐시에 저장
    semanticCacheService.put(query1, "검색 결과");

    // 2번째 요청 - 캐시 hit
    Optional<String> result2 = semanticCacheService.get(query2);
    assertTrue(result2.isPresent());
    assertEquals("검색 결과", result2.get());
}
```

### 미션 2: 코사인 유사도 계산

```java
@Test
void testCosineSimilarity() {
    float[] v1 = {1.0f, 2.0f, 3.0f};
    float[] v2 = {1.0f, 2.0f, 3.0f};  // 완전히 같음
    float[] v3 = {-1.0f, -2.0f, -3.0f};  // 반대 방향

    double sim1 = cosineSimilarity(v1, v2);
    double sim2 = cosineSimilarity(v1, v3);

    assertEquals(1.0, sim1, 0.001);  // 완전히 같음
    assertEquals(-1.0, sim2, 0.001);  // 완전히 다름
}
```

### 미션 3: TTL 정책 테스트

```java
@Test
void testTtl() {
    // 캐시 생성 (TTL = 10초)
    semanticCacheService.put("test", "result", 10);

    // 5초 후 - 여전히 유효
    Thread.sleep(5000);
    Optional<String> result1 = semanticCacheService.get("test");
    assertTrue(result1.isPresent());

    // 15초 후 - 만료됨
    Thread.sleep(10000);
    Optional<String> result2 = semanticCacheService.get("test");
    assertTrue(result2.isEmpty());
}
```

---

## 6. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

- [ ] 캐싱이 무엇인지 안다
- [ ] 시맨틱 캐싱을 이해한다
- [ ] 코사인 유사도로 캐시를 매칭할 수 있다
- [ ] 이벤트 기반 웜업을 구현할 수 있다
- [ ] TTL 정책을 이해한다
- [ ] 캐시 적중률을 계산할 수 있다
- [ ] 캐싱으로 비용을 절감할 수 있다
- [ ] 만료된 캐시를 정리할 수 있다

---

## 7. 다음 단계

다음 문서에서는 **요약과 리뷰**를 배웁니다:
- 지금까지 학습한 내용 복습
- RAG 시스템 전체 흐름 이해
- 성능 최적화 기법 정리
- 실전 팁과 모범 사례

[다음: 04. 요약과 리뷰 →](04.summarization-and-review.md)
