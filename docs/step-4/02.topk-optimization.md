# 02. Top-K와 컨텍스트 최적화: 품질과 비용의 균형

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- Week 4의 01 문서 내용 (성능과 비용)
- Week 2의 하이브리드 검색 이해
- Week 3의 RAG 구현 경험
- Java Stream API 기초

---

## 1. 개요

RAG 시스템에서 검색 결과를 AI에게 전달하는 방식에 따라 성능과 비용이 크게 달라집니다. 적절한 Top-K 설정과 컨텍스트 최적화가 필요합니다.

**이 문서에서 배울 내용:**
- Retrieval K와 Rerank K의 차이
- 적절한 Top-K 값 설정법
- RRF 점수 기반 필터링
- 컨텍스트 재구성 전략
- 품질과 비용의 균형 잡기

> **핵심 전략**
>
> **Too Little (너무 적음)**
> - 컨텍스트: 3권
> - 문제: 정보 부족, 정답 누락
>
> **Too Much (너무 많음)**
> - 컨텍스트: 100권
> - 문제: 비용 증가, 노이즈 증가
>
> **Just Right (적절함)**
> - 컨텍스트: 5~10권
> - 효과: 비용 절감, 품질 유지
>
> 항상 균형이 중요합니다!

---

## 2. 핵심 개념 이해

### 2.1. Retrieval K vs Rerank K

두 가지 K를 분리해서 생각해야 합니다.

**비유로 이해하기:**
```
[도서관에서 책 찾기]

1단계: 후보군 확보 (Retrieval K)
- 사서가 100권 가져옴
- "여기 다 비교해볼게요"

2단계: 정선하기 (Rerank K)
- 그중 관련 있는 10권만 선택
- "이 10권만 보여주세요"

RAG에서도 똑같아요:
- 검색 엔진: 100권 (Retrieval)
- AI에게 전달: 10권 (Rerank)
```

**개념 비교:**

| 개념 | 설명 | 값 |
|------|------|------|
| Retrieval K | 검색 엔진에서 가져오는 문서 수 | 50~100 |
| Rerank K | AI에게 전달하는 문서 수 | 5~10 |

**구조:**
```
[검색 엔진]
하이브리드 검색 → 상위 100권 (Retrieval K)
      ↓
[필터링]
RRF 점수 기반 필터링 → 상위 30권
      ↓
[재정렬]
RRF 점수 순 정렬 → 상위 10권 (Rerank K)
      ↓
[AI 전달]
10권의 도서 정보 → 컨텍스트 구축
```

### 2.2. Lost in the Middle 현상

AI는 컨텍스트의 처음과 끝에 있는 정보를 더 잘 처리합니다.

**비유로 이해하기:**
```
[컨텍스트 구조]

도서 1 (가장 중요) → AI가 잘 기억함
도서 2 (중요)
도서 3 (보통)        → AI가 잘 기억 못 함
도서 4 (보통)
도서 5 (중요)
도서 6 (덜 중요)    → AI가 잘 기억함

해결책:
- 중요한 도서를 앞에 배치
- 관련 순서대로 정렬
```

### 2.3. 노이즈(Noise) 문제

관련 없는 정보는 AI에게 혼란을 줍니다.

**비유로 이해하기:**
```
[노이즈 있는 경우]
사용자: "자바 책 추천해줘"

컨텍스트:
1. 자바의 정석 (관련 있음)
2. 이것이 자바다 (관련 있음)
3. 파이썬 프로그래밍 (관련 없음)
4. 요리책 (전혀 관련 없음)
5. 자바 웹 개발 (관련 있음)

AI: "파이썬도 프로그래밍 언어고..."
→ 혼란스러운 답변

[노이즈 제거]
컨텍스트:
1. 자바의 정석
2. 이것이 자바다
3. 자바 웹 개발

AI: "초보자분께는 자바의 정석을..."
→ 명확한 답변
```

---

## 3. 구현 가이드 (Step-by-Step)

### STEP 1: Rerank K 구현

검색 결과에서 상위 K개만 선택합니다.

**BookRagService.java**
```java
/**
 * RAG 기반 도서 추천 서비스
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class BookRagService {

    private final BookSearchService bookSearchService;
    private final BookAiService bookAiService;

    // Rerank K (AI에게 전달할 도서 수)
    private static final int RERANK_K = 5;

    /**
     * RAG 기반 도서 추천
     */
    public List<BookAiRecommendationResponse> recommendBooks(String question) {
        log.info("=== RAG 추천 시작 ===");
        log.info("질문: {}", question);

        // 1. 검색 (Retrieval)
        List<BookSearchResponse> allBooks = searchBooks(question);
        log.info("검색된 도서: {}권", allBooks.size());

        // 2. Rerank (상위 K개 선택)
        List<BookSearchResponse> topKBooks = selectTopKBooks(allBooks);
        log.info("AI에게 전달할 도서: {}권", topKBooks.size());

        // 3. 컨텍스트 구축
        String context = buildContext(topKBooks);

        // 4. 프롬프트 생성
        String prompt = PromptTemplate.createJsonPrompt(question, context);

        // 5. AI 호출
        String rawResponse = bookAiService.askAboutBooks(prompt);

        // 6. 역직렬화
        List<BookAiRecommendationResponse> recommendations =
                JsonParser.parseRecommendations(rawResponse);

        log.info("추천된 도서: {}권", recommendations.size());
        log.info("=== RAG 추천 완료 ===");

        return recommendations;
    }

    /**
     * 검색 (Retrieval K)
     *
     * 충분한 후보군을 가져옵니다.
     */
    private List<BookSearchResponse> searchBooks(String question) {
        return bookSearchService.searchBooks(
                SearchType.HYBRID,
                question,
                0,
                50  // Retrieval K = 50
        );
    }

    /**
     * 상위 K개 선택 (Rerank K)
     *
     * RRF 점수가 높은 순서대로 K개만 선택합니다.
     */
    private List<BookSearchResponse> selectTopKBooks(
            List<BookSearchResponse> books
    ) {
        return books.stream()
                .limit(RERANK_K)  // 상위 K개만 선택
                .toList();
    }
}
```

### STEP 2: RRF 점수 필터링

관련 없는 도서를 과감히 제거합니다.

**BookRagService.java - 필터링 추가**
```java
/**
 * 상위 K개 선택 (Rerank K)
 *
 * RRF 점수 기준 필터링을 포함합니다.
 */
private List<BookSearchResponse> selectTopKBooks(
        List<BookSearchResponse> books
) {
    // RRF 점수 임계값
    final double RRF_THRESHOLD = 0.02;

    return books.stream()
            .filter(book -> book.getRrfScore() != null)  // 점수 있는 것만
            .filter(book -> book.getRrfScore() >= RRF_THRESHOLD)  // 임계값 이상
            .sorted((b1, b2) -> Double.compare(
                    b2.getRrfScore(),
                    b1.getRrfScore()
            ))  // RRF 점수 내림차순 정렬
            .limit(RERANK_K)  // 상위 K개만 선택
            .toList();
}
```

**임계값(Threshold) 설정 가이드:**

| 임계값 | 설명 | 결과 |
|--------|------|------|
| 0.03 | 매우 엄격 | 매우 관련성 높은 도서만 전달 |
| 0.02 | 엄격함 (추천) | 관련성 있는 도서만 전달 |
| 0.01 | 관대적 | 넓은 범위의 도서 전달 |

**비교:**
```
[임계값 = 0.02]
RRF 점수: 0.015 → 필터링
RRF 점수: 0.025 → 통과
RRF 점수: 0.050 → 통과

→ 노이즈 제거 효과
```

### STEP 3: 컨텍스트 최적화

컨텍스트를 효율적으로 구성합니다.

**buildContext 메서드 개선:**
```java
/**
 * 컨텍스트 구축
 *
 * Lost in the Middle 방지를 위한 최적화를 포함합니다.
 */
private String buildContext(List<BookSearchResponse> books) {
    if (books.isEmpty()) {
        return "";
    }

    StringBuilder sb = new StringBuilder();

    sb.append("## 도서 정보\n\n");

    // RRF 점수순으로 이미 정렬되어 있다고 가정
    for (int i = 0; i < books.size(); i++) {
        BookSearchResponse book = books.get(i);

        sb.append("### 도서 ").append(i + 1).append("\n");
        sb.append("- ID: ").append(book.id()).append("\n");
        sb.append("- 제목: ").append(book.title()).append("\n");
        sb.append("- 저자: ").append(book.authorName()).append("\n");

        // 내용 (요약)
        if (book.bookContent() != null) {
            String content = book.bookContent();

            // 300자로 제한
            if (content.length() > 300) {
                content = content.substring(0, 300) + "...";
            }

            sb.append("- 내용: ").append(content).append("\n");
        }

        // RRF 점수 포함 (AI 참고용)
        if (book.getRrfScore() != null) {
            sb.append("- 관련성: ")
              .append(String.format("%.4f", book.getRrfScore())).append("\n");
        }

        sb.append("\n");
    }

    return sb.toString();
}
```

---

## 4. 최적화 전략

### 4.1. K 값 결정 가이드

**사용자 질문 유형별 K 값:**

| 질문 유형 | 추천 K 값 | 이유 |
|----------|----------|------|
| 특정 도서 검색 | 3~5 | 정확한 일치 중요 |
| 주제별 추천 | 5~7 | 다양성 필요 |
| 일반적 추천 | 7~10 | 넓은 범위 필요 |

**비교:**
```
[특정 도서 검색]
질문: "자바의 정석 책 추천"
→ K=3 (정확한 답변)

[주제별 추천]
질문: "데이터베이스 공부할 책"
→ K=5 (관련 도서 포괄)

[일반적 추천]
질문: "프로그래밍 책 추천해줘"
→ K=10 (다양한 분야)
```

### 4.2. 토큰 비용 최적화

**K 값에 따른 토큰 수 변화:**

| K | 도서당 200자 | 총 토큰 | 비용 |
|---|--------------|--------|------|
| 3 | 600 | 750 | $0.075 |
| 5 | 1000 | 1250 | $0.125 |
| 7 | 1400 | 1750 | $0.175 |
| 10 | 2000 | 2500 | $0.250 |

**계산:**
```
토큰 수 = (프롬프트 기본) + (도서 수 × 200자)

K=5:
기본: 500토큰
도서: 5 × 200 = 1000토큰
총: 1500토큠큰
비용: 1500 × $0.10 / 1000 = $0.15
```

### 4.3. 품질 vs 비용 균형

**트레이드오프:**
```
[K = 3]
비용: 저렴
정답률: 낮을 수 있음
사용자 만족도: 낮음

[K = 5]
비용: 중간
정답률: 높음
사용자 만족도: 높음
→ 최적 균형

[K = 10]
비용: 높음
정답률: 높음
사용자 만족도: 높음
```

---

## 5. 실습 미션

### 미션 1: 다양한 K 값 테스트

```java
@Slf4j
class TopKOptimizationTest {

    @Test
    void testDifferentKValues() {
        String question = "자바 책 추천해줘";
        log.info("=== 다양한 K 값 테스트 시작 ===");
        log.info("질문: {}", question);

        // K = 3
        List<BookSearchResponse> k3 = selectTopKBooks(searchBooks(question), 3);
        log.info("K=3: {}권 (도서: {})", k3.size(),
            k3.stream().map(BookSearchResponse::title).toList());

        // K = 5
        List<BookSearchResponse> k5 = selectTopKBooks(searchBooks(question), 5);
        log.info("K=5: {}권 (도서: {})", k5.size(),
            k5.stream().map(BookSearchResponse::title).toList());

        // K = 10
        List<BookSearchResponse> k10 = selectTopKBooks(searchBooks(question), 10);
        log.info("K=10: {}권", k10.size());

        // 결과 비교
        assertTrue(k3.size() <= k5.size());
        assertTrue(k5.size() <= k10.size());

        log.info("=== K 값 테스트 완료: K3={} ≤ K5={} ≤ K10={} ===",
            k3.size(), k5.size(), k10.size());
    }
}
```

### 미션 2: RRF 필터링 테스트

```java
@Test
void testRrfFiltering() {
    log.info("=== RRF 필터링 테스트 시작 (threshold=0.02) ===");

    List<BookSearchResponse> books = List.of(
        new BookSearchResponse(1L, "isbn1", "book1", "author1",
            "publisher1", "url1", "content1", null, 0.025),  // 통과 예상
        new BookSearchResponse(2L, "isbn2", "book2", "author2",
            "publisher2", "url2", "content2", null, 0.015),  // 필터링 예상
        new BookSearchResponse(3L, "isbn3", "book3", "author3",
            "publisher3", "url3", "content3", null, 0.035)   // 통과 예상
    );

    log.info("입력 도서: {}권", books.size());
    books.forEach(book -> log.debug("  - {} (RRF: {:.3f})",
        book.title(), book.getRrfScore()));

    // 필터링 적용
    final double THRESHOLD = 0.02;
    List<BookSearchResponse> filtered = books.stream()
            .filter(book -> book.getRrfScore() != null)
            .filter(book -> book.getRrfScore() >= THRESHOLD)
            .toList();

    log.info("필터링 후: {}권 (threshold: {:.3f})", filtered.size(), THRESHOLD);
    filtered.forEach(book -> log.info("  ✓ {} (RRF: {:.3f})",
        book.title(), book.getRrfScore()));

    assertEquals(2, filtered.size());
    assertEquals(1L, filtered.get(0).id());
    assertEquals(3L, filtered.get(1).id());

    log.info("=== RRF 필터링 테스트 완료: {}권 통과 ===", filtered.size());
}
```

### 미션 3: 컨텍스트 길이 확인

```java
@Test
void testContextLength() {
    int bookCount = 10;
    log.info("=== 컨텍스트 길이 테스트 시작 (도서 {}권) ===", bookCount);

    List<BookSearchResponse> books = createTestBooks(bookCount);
    String context = buildContext(books);

    int contextLength = context.length();
    int estimatedTokens = contextLength / 2;  // 한글 기준 대략적 추정

    log.info("컨텍스트 길이: {}자", contextLength);
    log.info("예상 토큰: 약 {}토큰", estimatedTokens);
    log.info("도서당 평균: {}자 ({}토큰)",
        contextLength / bookCount, estimatedTokens / bookCount);

    // 목표: 2000자 이하
    boolean isWithinLimit = contextLength < 2000;
    log.info("목표 충족: {} (2000자 이하)", isWithinLimit ? "✓" : "✗");

    assertTrue(contextLength < 2000, "컨텍스트가 너무 깁니다");
    log.info("=== 컨텍스트 길이 테스트 완료 ===");
}
```

---

## 6. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

- [ ] Retrieval K와 Rerank K의 차이를 안다
- [ ] 적절한 K 값을 설정할 수 있다
- [ ] RRF 점수 필터링을 구현할 수 있다
- [ ] 임계값(Threshold)의 의미를 이해한다
- [ ] Lost in the Middle 현상을 안다
- [ ] 컨텍스트를 효율적으로 구축할 수 있다
- [ ] 품질과 비용의 균형을 잡을 수 있다

---

## 7. 다음 단계

다음 문서에서는 **결과 캐싱**을 배웁니다:
- 캐싱이란 무엇인지
- 어떤 경우 캐싱을 사용할지
- Spring Cache 추상화 활용
- 캐싱 전략 (TTL, Eviction)

[다음: 03. 결과 캐싱 →](03.result-caching.md)
