# 04. 요약 전략과 리뷰 요약 실습 (Summarization & Review Practice)

## 1. 긴 문서의 한계: 왜 요약이 필요할까요?

AI(LLM)는 똑똑하지만 한 번에 읽을 수 있는 페이지 수(컨텍스트 창, Context Window)가 정해져 있습니다. 

*   **비유**: 아무리 천재적인 독서가라도 수천 페이지 분량의 백과사전을 한 번에 눈에 담고 이해할 수는 없는 것과 같습니다. 한 번에 너무 많은 정보를 주면 AI는 혼란스러워하거나, 가장 중요한 내용을 놓치기도 합니다.
*   **비용 문제**: AI에게 긴 글을 읽게 하는 것은 공짜가 아닙니다. 읽는 글자 수만큼 비용이 발생하기 때문에, 핵심만 골라 읽게 하는 것이 경제적입니다.

이런 한계를 극복하기 위해 우리는 **"나눠서 읽고 합치는 전략"** 을 사용합니다.

---

## 2. 핵심 요약 전략 이론

### 1) Map-Reduce (나눠서 요약하고 합치기)
가장 대표적인 대용량 데이터 처리 방식입니다.

*   **💡 쉬운 비유**: 10권의 책을 읽고 전체 내용을 보고해야 한다면, 친구 10명에게 한 권씩 나눠주고 요약해오게 한 뒤(Map), 그 요약본들을 내가 모아서 최종 보고서를 작성(Reduce)하는 것과 같습니다.
*   **⚙️ 동작 원리**: 방대한 텍스트를 작은 덩어리로 나누어 각각 요약본을 만들고, 그 요약본들을 다시 하나로 합쳐서 최종 응답을 생성합니다.
*   **장단점**: 여러 작업을 동시에 처리할 수 있어 **속도가 빠르지만**, 문맥의 흐름이 끊길 수 있습니다.

### 2) Refine (점진적으로 다듬기)
문맥의 흐름을 유지하며 정보를 보강해 나가는 방식입니다.

*   **💡 쉬운 비유**: 첫 번째 책을 읽고 요약본을 만든 뒤, 두 번째 책을 읽으면서 "기존 요약본에 이 내용도 추가해서 업데이트해줘"라고 시키는 과정을 반복하는 것과 같습니다.
*   **⚙️ 동작 원리**: 첫 번째 문서 조각을 요약하고, 그 결과와 두 번째 조각을 함께 LLM에게 보내 더 나은 요약본을 만듭니다.
*   **장단점**: **앞뒤 문맥을 아주 잘 파악**하며 정교한 결과가 나오지만, 순서대로 처리해야 하므로 **시간이 오래 걸립니다.**

---

## 3. [실습] 도서 리뷰 요약 시스템 구축

이론으로 배운 전략을 실제 프로젝트에 적용해 봅시다. 사용자가 책을 선택할 때 가장 많이 참고하는 **'독자 리뷰'**를 AI로 요약하는 시스템을 설계합니다.

### 1) 왜 리뷰 요약인가요?
수백 개의 리뷰를 일일이 읽는 것은 사용자에게 고역입니다. AI가 핵심(장단점, 분위기)을 3~5문장으로 요약해 준다면 사용자 경험은 획기적으로 개선됩니다.

### 2) 시스템 설계 (Map-Reduce 적용)
우리 프로젝트에서는 대량의 리뷰를 효율적으로 처리하기 위해 **Map-Reduce** 방식을 사용합니다.

1.  **리뷰 수집**: DB에서 특정 도서의 리뷰들을 가져옵니다.
2.  **청크 분할 (Chunking)**: 리뷰를 10개씩 묶습니다.
3.  **Map 단계 (부분 요약)**: 각 묶음에 대해 공통적인 장단점을 요약합니다.
4.  **Reduce 단계 (최종 요약)**: 부분 요약본들을 하나로 모아 '최종 독자 반응'을 작성합니다.

---

## 4. 상세 구현 가이드

### 1) 프롬프트 설계
**Map 단계 프롬프트:**
```text
다음은 특정 도서에 대한 독자 리뷰들입니다. 
이 리뷰들에서 공통적으로 언급되는 [장점], [단점], [추천대상]을 각각 한 문장씩 요약하세요.

리뷰 리스트:
{review_chunks}
```

**Reduce 단계 프롬프트:**
```text
다음은 도서 리뷰들을 부분적으로 요약한 내용들입니다.
이 내용들을 종합하여 사용자가 이 책을 살지 말지 결정하는 데 도움이 되는 '최종 평판 요약'을 작성하세요.
답변은 반드시 공손하고 친절한 어투(~입니다, ~하세요)를 사용하세요.

요약 데이터:
{summary_list}
```

### 2) Java 서비스 로직 구조
```java
@Service
public class ReviewSummarizer {
    private final ChatModel chatModel;

    public String summarizeReviews(List<String> reviews) {
        // 1. Map 단계: 리뷰를 10개씩 나누어 부분 요약 생성
        List<String> partialSummaries = new ArrayList<>();
        List<List<String>> chunks = Lists.partition(reviews, 10);
        
        for (List<String> chunk : chunks) {
            String mapPrompt = createMapPrompt(chunk);
            partialSummaries.add(chatModel.call(mapPrompt));
        }

        // 2. Reduce 단계: 부분 요약들을 합쳐 최종 요약 생성
        String reducePrompt = createReducePrompt(partialSummaries);
        return chatModel.call(reducePrompt);
    }
}
```

---

## 5. 실습 미션

### [미션 1] 리뷰 데이터 시뮬레이션
가상의 리뷰 리스트 20개를 만들어 테스트해 보세요. (예: "내용이 알차요", "초보자에겐 어렵네요" 등)

### [미션 2] Map-Reduce 로직 완성
위의 Java 예시 구조를 바탕으로 실제 `ReviewSummarizer` 클래스를 만들고, `Map` 단계의 결과물이 어떻게 합쳐져서 `Reduce` 단계로 넘어가는지 로그(`log.info`)를 찍어 확인해 보세요.

### [미션 3] 출력 형식 고정
최종 요약 결과가 항상 `장점: ... / 단점: ... / 총평: ...`의 형식을 유지하도록 프롬프트를 수정해 보세요.

---

## 6. 학습 포인트 (정리)

1.  **분할 정복**: 큰 데이터를 작은 단위로 나누어 처리하는 AI 시스템 설계의 핵심 원리를 이해합니다.
2.  **프롬프트 체이닝**: 이전 호출의 결과를 다음 호출의 입력으로 사용하여 더 복잡한 문제를 해결하는 기법을 익힙니다.
3.  **속도와 정확도의 균형**: 서비스 성격에 따라 **Map-Reduce(속도)**와 **Refine(정확도)** 중 적절한 전략을 선택하는 판단력을 기릅니다.
