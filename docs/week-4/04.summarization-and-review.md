# 04. 요약 전략과 리뷰 요약 실습 (Summarization & Review Practice)

## 1. 긴 문서의 한계: 왜 요약이 필요할까요?

AI(LLM)는 똑똑하지만 한 번에 읽을 수 있는 페이지 수(컨텍스트 창, Context Window)가 정해져 있습니다. 

*   **비유**: 아무리 천재적인 독서가라도 수천 페이지 분량의 백과사전을 한 번에 눈에 담고 이해할 수는 없는 것과 같습니다. 한 번에 너무 많은 정보를 주면 AI는 혼란스러워하거나, 가장 중요한 내용을 놓치기도 합니다.
*   **비용 문제**: AI에게 긴 글을 읽게 하는 것은 공짜가 아닙니다. 읽는 글자 수만큼 비용이 발생하기 때문에, 핵심만 골라 읽게 하는 것이 경제적입니다.

이런 한계를 극복하기 위해 우리는 **"나눠서 읽고 합치는 전략"** 을 사용합니다.

---

## 2. 핵심 요약 전략 이론

### 1) Map-Reduce (나눠서 요약하고 합치기)
가장 대표적인 대용량 데이터 처리 방식입니다.

*   **💡 쉬운 비유**: 10권의 책을 읽고 전체 내용을 보고해야 한다면, 친구 10명에게 한 권씩 나눠주고 요약해오게 한 뒤(Map), 그 요약본들을 내가 모아서 최종 보고서를 작성(Reduce)하는 것과 같습니다.
*   **⚙️ 동작 원리**: 방대한 텍스트를 작은 덩어리로 나누어 각각 요약본을 만들고, 그 요약본들을 다시 하나로 합쳐서 최종 응답을 생성합니다.
*   **장단점**: 여러 작업을 동시에 처리할 수 있어 **속도가 빠르지만**, 문맥의 흐름이 끊길 수 있습니다.

### 2) Refine (점진적으로 다듬기)
문맥의 흐름을 유지하며 정보를 보강해 나가는 방식입니다.

*   **💡 쉬운 비유**: 첫 번째 책을 읽고 요약본을 만든 뒤, 두 번째 책을 읽으면서 "기존 요약본에 이 내용도 추가해서 업데이트해줘"라고 시키는 과정을 반복하는 것과 같습니다.
*   **⚙️ 동작 원리**: 첫 번째 문서 조각을 요약하고, 그 결과와 두 번째 조각을 함께 LLM에게 보내 더 나은 요약본을 만듭니다.
*   **장단점**: **앞뒤 문맥을 아주 잘 파악**하며 정교한 결과가 나오지만, 순서대로 처리해야 하므로 **시간이 오래 걸립니다.**

---

## 3. [실습] 도서 리뷰 요약 시스템 구축

이론으로 배운 전략을 실제 프로젝트에 적용해 봅시다. 사용자가 책을 선택할 때 가장 많이 참고하는 **'독자 리뷰'**를 AI로 요약하는 시스템을 설계합니다.

### 1) 왜 리뷰 요약인가요?
수백 개의 리뷰를 일일이 읽는 것은 사용자에게 고역입니다. AI가 핵심(장단점, 분위기)을 3~5문장으로 요약해 준다면 사용자 경험은 획기적으로 개선됩니다.

### 2) 성능 최적화의 필요성
리뷰가 등록될 때마다 또는 상세 페이지를 볼 때마다 매번 LLM을 호출하면 다음과 같은 문제가 발생합니다:
- **속도 저하**: LLM 응답은 수 초 이상 걸릴 수 있어 사용자 대기 시간이 길어집니다.
- **비용 증가**: API 호출 횟수에 따라 비용이 누적됩니다.
- **중복 작업**: 동일한 리뷰 데이터에 대해 반복적으로 요약을 생성하는 것은 비효율적입니다.

이를 해결하기 위해 **DB 기반의 요약 캐싱 및 통계 테이블**을 도입합니다.

### 3) 시스템 설계 (Map-Reduce 및 Dirty Flag 적용)
우리 프로젝트에서는 대량의 리뷰를 효율적으로 처리하기 위해 **Map-Reduce** 방식을 사용하며, 성능 최적화를 위해 **Dirty Flag** 전략을 결합합니다.

**도서(Book)와 리뷰 요약(BookReviewSummary) 관계:**
- **1:1 관계**: 도서 한 권은 하나의 리뷰 요약 정보를 가질 수 있습니다.
- **선택적 관계 (Optional)**: 리뷰가 없는 도서는 요약 정보가 존재하지 않을 수 있습니다 (0 또는 1의 관계).
- **공유 식별자 (Shared Primary Key)**: `book_review_summary` 테이블은 `books` 테이블의 PK를 자신의 PK이자 FK로 사용합니다.

1.  **리뷰 수집**: DB에서 특정 도서의 리뷰들을 가져옵니다.
2.  **청크 분할 (Chunking)**: 리뷰를 10개씩 묶습니다.
3.  **Map 단계 (부분 요약)**: 각 묶음에 대해 공통적인 장단점을 요약합니다.
4.  **Reduce 단계 (최종 요약)**: 부분 요약본들을 하나로 모아 '최종 독자 반응'을 작성합니다.
5.  **캐싱 및 무효화**: 생성된 요약을 DB에 저장하고, 새로운 리뷰가 등록되면 `is_summary_dirty` 플래그를 통해 요약이 필요함을 표시합니다.

---

## 4. 상세 구현 가이드

### 1) 프롬프트 설계
**Map 단계 프롬프트:**
```text
다음은 특정 도서에 대한 독자 리뷰들입니다. 
이 리뷰들에서 공통적으로 언급되는 [장점], [단점], [추천대상]을 각각 한 문장씩 요약하세요.

리뷰 리스트:
{review_chunks}
```

**Reduce 단계 프롬프트:**
```text
다음은 도서 리뷰들을 부분적으로 요약한 내용들입니다.
이 내용들을 종합하여 사용자가 이 책을 살지 말지 결정하는 데 도움이 되는 '최종 평판 요약'을 작성하세요.
답변은 반드시 공손하고 친절한 어투(~입니다, ~하세요)를 사용하세요.

요약 데이터:
{summary_list}
```

### 2) Java 서비스 로직 구조

**리뷰 엔티티 (별점 필드 추가):**
```java
@Entity
@Table(name = "book_reviews")
@Getter
@NoArgsConstructor
public class BookReview {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "book_id", nullable = false)
    private Book book;

    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;

    @Column(nullable = false)
    private Integer rating; // 1~5점 별점

    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt;

    public BookReview(Book book, String content, Integer rating) {
        this.book = book;
        this.content = content;
        this.rating = rating;
        this.createdAt = OffsetDateTime.now();
    }
}
```

**리뷰 서비스 (통계 업데이트 및 이벤트 발행):**
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class ReviewService {
    private final BookReviewRepository bookReviewRepository;
    private final BookRepository bookRepository;
    private final BookSearchService bookSearchService;
    private final BookReviewSummaryRepository bookReviewSummaryRepository;
    private final ApplicationEventPublisher eventPublisher;

    @Transactional
    public Long createReview(Long bookId, ReviewCreateRequest request) {
        Book book = bookRepository.findById(bookId)
                .orElseThrow(() -> new BookNotFoundException(bookId));

        // 1. 리뷰 저장
        BookReview review = new BookReview(book, request.content(), request.rating());
        BookReview savedReview = bookReviewRepository.save(review);
        Long reviewId = savedReview.getId();
        
        // 2. 리뷰 통계 및 Dirty Flag 업데이트
        updateReviewSummary(book, request.rating());
        
        // 3. 기존 캐시(의미적 캐싱) 무효화
        bookSearchService.evictReviewSummaryCache(bookId);

        // 4. 리뷰 등록 이벤트 발행
        eventPublisher.publishEvent(new ReviewCreatedEvent(bookId, reviewId, savedReview.getCreatedAt()));
        
        return reviewId;
    }
}
```

**리뷰 이벤트 핸들러 (비동기 요약 생성):**
```java
@Service
@RequiredArgsConstructor
public class ReviewEventListener {
    private static final int MIN_REVIEW_COUNT_FOR_SUMMARY = 5;
    private final BookReviewSummaryRepository bookReviewSummaryRepository;
    private final ReviewSummarizer reviewSummarizer;

    @Async
    @EventListener
    @Transactional
    public void handleReviewCreatedEvent(ReviewCreatedEvent event) {
        bookReviewSummaryRepository.findById(event.bookId()).ifPresent(summary -> {
            // 조건: 리뷰가 5개 이상이고 데이터가 변경(Dirty)된 경우에만 LLM 호출
            if (summary.getReviewCount() >= MIN_REVIEW_COUNT_FOR_SUMMARY && summary.getIsSummaryDirty()) {
                List<String> reviews = fetchReviews(event.bookId());
                String newSummary = reviewSummarizer.summarizeReviews(reviews);
                
                summary.updateSummary(newSummary); // is_summary_dirty = false
                bookReviewSummaryRepository.save(summary);
            }
        });
    }
}
```

**도서 검색 서비스 (비차단 요약 조회):**
```java
@Service
@RequiredArgsConstructor
public class BookSearchService {
    private final BookReviewSummaryRepository bookReviewSummaryRepository;
    
    public String getReviewSummary(Long bookId) {
        // DB에 저장된 요약을 즉시 반환 (사용자 대기 없음)
        return bookReviewSummaryRepository.findById(bookId)
                .map(summary -> {
                    if (summary.getReviewSummary() != null) return summary.getReviewSummary();
                    return "리뷰 분석 중입니다... (현재 " + summary.getReviewCount() + "개)";
                })
                .orElse("아직 등록된 리뷰가 없습니다.");
    }
}
```

---

## 5. 실습 미션

### [미션 1] 리뷰 데이터 시뮬레이션
가상의 리뷰 리스트 20개를 만들어 테스트해 보세요. (예: "내용이 알차요", "초보자에겐 어렵네요" 등)

### [미션 2] Map-Reduce 로직 완성
위의 Java 예시 구조를 바탕으로 실제 `ReviewSummarizer` 클래스를 만들고, `Map` 단계의 결과물이 어떻게 합쳐져서 `Reduce` 단계로 넘어가는지 로그(`log.info`)를 찍어 확인해 보세요.

### [미션 3] 출력 형식 고정
최종 요약 결과가 항상 `장점: ... / 단점: ... / 총평: ...`의 형식을 유지하도록 프롬프트를 수정해 보세요.

---

## 7. 리뷰 통계 및 요약 테이블 설계

리뷰가 늘어날 때마다 LLM을 호출하는 것은 비용과 성능 면에서 비효율적입니다. 이를 해결하기 위해 리뷰 통계와 요약을 미리 저장해두는 테이블을 설계하고 활용합니다.

### 1) 테이블 구조 (`book_review_summary`)

```sql
CREATE TABLE book_review_summary (
    -- 책 ID (books 테이블 참조)
    book_id BIGINT PRIMARY KEY
        REFERENCES books(id),

    -- 리뷰 통계
    review_count BIGINT NOT NULL DEFAULT 0,      -- 전체 리뷰 수
    average_rating NUMERIC(3,2) NOT NULL DEFAULT 0.00,  -- 평균 평점

    -- 별점별 리뷰 수
    rating_1_count INTEGER NOT NULL DEFAULT 0,
    rating_2_count INTEGER NOT NULL DEFAULT 0,
    rating_3_count INTEGER NOT NULL DEFAULT 0,
    rating_4_count INTEGER NOT NULL DEFAULT 0,
    rating_5_count INTEGER NOT NULL DEFAULT 0,

    -- 가장 최근 리뷰 작성 시간
    last_reviewed_at TIMESTAMP,

    -- LLM으로 생성한 리뷰 요약
    review_summary TEXT,

    -- 요약 갱신 필요 여부 (Dirty Flag)
    is_summary_dirty BOOLEAN DEFAULT TRUE,

    -- 요약 갱신 시각
    updated_at TIMESTAMP DEFAULT NOW()
);
```

### 2) 갱신 전략 (Event-Driven & Dirty Flag)

1.  **리뷰 등록 시**: `review_count`, `average_rating` 등을 즉시 업데이트하고 `is_summary_dirty = TRUE`로 설정한 뒤, `ReviewCreatedEvent`를 발행합니다.
2.  **조회 시**: DB에 저장된 `review_summary`를 즉시 반환하여 사용자 대기 시간을 없앱니다. 요약이 없더라도 '분석 중' 메시지를 보여주며 비차단(Non-blocking) 방식으로 동작합니다.
3.  **비동기 요약 갱신**: 이벤트 핸들러가 비동기적으로 실행되며, 특정 조건(예: 리뷰 5개 이상) 충족 시에만 LLM을 호출하여 요약을 갱신하고 `is_summary_dirty = FALSE`로 변경합니다.

---

## 8. 학습 포인트 (정리)

1.  **분할 정복**: 큰 데이터를 작은 단위로 나누어 처리하는 AI 시스템 설계의 핵심 원리를 이해합니다.
2.  **프롬프트 체이닝**: 이전 호출의 결과를 다음 호출의 입력으로 사용하여 더 복잡한 문제를 해결하는 기법을 익힙니다.
3.  **속도와 정확도의 균형**: 서비스 성격에 따라 **Map-Reduce(속도)**와 **Refine(정확도)** 중 적절한 전략을 선택하는 판단력을 기릅니다.
