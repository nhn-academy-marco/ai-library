# 04. 리뷰 요약 시스템 구현하기

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- Week 4의 01, 02, 03 문서 내용 (성능 최적화)
- Week 1의 이벤트 기반 아키텍처 이해
- Spring의 @Async, @Transactional 활용 능력
- 리스트 처리와 Stream API 기초

---

## 1. 개요

수백 개의 리뷰를 일일이 읽는 것은 사용자에게 큰 부담입니다. AI가 리뷰를 요약해서 "장점/단점/추천대상"을 3~5문장으로 정리해 주면 사용자 경험이 획기적으로 개선됩니다.

**이 문서에서 배울 내용:**
- 왜 리뷰를 요약해야 하는지
- Map-Reduce 요약 전략이란 무엇인지
- **누적 요약(Incremental Summary)으로 비용 최적화하기**
- **큐(Queue) 기반 비동기 처리 아키텍처**
- Dirty Flag로 비용 절감하기
- 중복 실행 방지 전략
- 단계별 구현 가이드

---

## 2. 핵심 개념 이해

### 2.1. 왜 요약이 필요한가?

**문제: AI도 읽기엔 너무 길어요**

AI의 컨텍스트 윈도우(Context Window)는 한 번에 읽을 수 있는 토큰 수에 제한이 있습니다. 리뷰 100개는 약 10,000토큰에 달해 한계를 초과할 수 있습니다.

**해결: 나눠서 읽고 합치기**

1. 리뷰를 10개씩 묶음 (Chunking)
2. 각 묶음을 요약 (Map)
3. 요약본들을 다시 합쳐서 최종 요약 (Reduce)

### 2.2. Map-Reduce 전략

**비유로 이해하기**

10권의 책을 요약해야 한다고 가정해 봅시다.

Map-Reduce 방식:
1. 10명의 친구에게 각각 1권씩 나눠줌
2. 친구들이 각자 요약해서 가져옴 (Map 단계)
3. 내가 모아서 최종 요약본 작성 (Reduce 단계)

장점:
- 병렬 처리 가능으로 속도 향상
- 한 사람이 모두 읽을 필요 없음

**구조**

```
[입력]
리뷰 1~100

[Map 단계]
리뷰 1~10   → 요약1
리뷰 11~20 → 요약2
리뷰 21~30 → 요약3
...
리뷰 91~100 → 요약10

[Reduce 단계]
요약1 + 요약2 + ... + 요약10
    ↓
[최종 요약]
"이 책의 장점은... 단점은..."
```

### 2.3. 누적 요약(Incremental Summary)

**문제: 전체를 다시 요약하면 비용이 큼**

전체 재요약 방식:
- 리뷰 5개: 요약 ($0.10)
- 리뷰 10개: 전체 재요약 ($0.10)
- 리뷰 15개: 전체 재요약 ($0.10)
- ...
- 리뷰 100개: 전체 재요약 ($0.10)
- 총: $1.00 (10회)

**해결: 새 리뷰만 요약해서 병합**

누적 요약 방식:
- 리뷰 5개: 요약1 ($0.10) → 저장
- 리뷰 10개: 새로운 5개만 요약 ($0.05) → 요약1 + 요약2 머지
- 리뷰 15개: 새로운 5개만 요약 ($0.05) → 요약1-2 + 요약3 머지
- ...
- 리뷰 100개: 새로운 5개만 요약 ($0.05)
- 총: $0.55 (50% 절감)

**비유로 이해하기**

전체 재요약은 1장부터 100장까지 다시 읽는 것과 같아 시간이 오래 걸립니다. 누적 요약은 지금까지 읽은 요약본에 새로운 10장만 추가해서 요약하므로 시간이 단축됩니다.

### 2.4. 메시지 큐 기반 아키텍처

**문제 1단계: @Async만으로는 충분하지 않아요**

@Async로 처리할 때 발생하는 문제:
- 리뷰 10개가 동시에 생성되면 10개의 스레드가 동시에 AI 요약 처리 시도
- 낙관적 잠금(Optimistic Lock) 충돌 발생
- `ObjectOptimisticLockingFailureException` 에러

```
사용자 A: 리뷰 작성 → 이벤트 발생 → @Async 스레드 1
사용자 B: 리뷰 작성 → 이벤트 발생 → @Async 스레드 2
사용자 C: 리뷰 작성 → 이벤트 발생 → @Async 스레드 3
...
스레드 1, 2, 3이 동시에 같은 BookReviewSummary 업데이트 시도
→ version 충돌 → 에러 발생!
```

**문제 2단계: 인메모리 큐의 한계**

첫 번째 해결책으로 `LinkedBlockingQueue` + 단일 워커 스레드를 사용했지만, 새로운 문제 발생:
- **서버 재시작 시 큐의 작업 소실**: 처리되지 않은 요약 작업이 모두 사라짐
- **단일 서버에서만 처리 가능**: 여러 서버 인스턴스를 띄우면 각각의 큐가 따로 동작
- **LLM 호출이 블로킹**: 한 요약이 완료될 때까지 다른 요약을 시작할 수 없음
- **스케일 아웃 불가**: 트래픽이 늘어나도 워커를 늘릴 수 없음

**해결: RabbitMQ 메시지 브로커 도입**

RabbitMQ는 메시지를 안정적으로 저장하고 여러 소비자가 분산 처리할 수 있게 해줍니다.

```
[이벤트 발생]
ReviewCreatedEvent → 통계 업데이트 → ReviewAiSummaryEvent
                                              ↓
                                        [RabbitMQ Queue]
                                        (메시지 안전 저장)
                                              ↓
                                    [3-5개 Consumer]
                                    (병렬 처리 가능)
                                              ↓
                                        [AI 요약 생성]
```

**장점**
1. **메시지 지속성**: 서버가 재시작해도 메시지가 보존됨
2. **병렬 처리**: 여러 Consumer가 동시에 다른 책의 요약을 처리
3. **디커플링**: 리뷰 생성과 AI 요약 처리가 완전히 분리됨
4. **중복 제거**: 5초 내 같은 도서의 요약 요청은 자동으로 제거됨
5. **부하 조절**: Consumer 수를 조절하여 처리 속도 조절 가능
6. **스케일 아웃**: 여러 서버 인스턴스에서 동일 큐를 처리 가능

**아키텍처 구조 (RabbitMQ 기반)**

```
┌─────────────────┐
│ ReviewService   │
│  .createReview()│
└───────┬─────────┘
        │
        ▼
┌─────────────────────────────────────┐
│  ReviewCreatedEvent 발생             │
└───────┬─────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│  ReviewEventListener                │
│  - 통계 업데이트                       │
│  - ReviewAiSummaryEvent 발생         │
└───────┬─────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│  ReviewAiSummaryEventListener       │
│  @Async                             │
│  - RabbitTemplate으로 메시지 발행       │
└───────┬─────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│  RabbitMQ                           │
│  s4.java21.net:5672                  │
│  Queue: nhnacademy-library-review    │
│  - 중복 요청 필터링 (Dedup)             │
│  - 메시지 지속성 보장                   │
└───────┬─────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│  ReviewSummaryQueueProcessor        │
│  @RabbitListener (3-5개 Consumer)    │
│  - 자동 메시지 수신                     │
│  - 병렬 처리                          │
└───────┬─────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│  ReviewAiSummaryService             │
│  - 실제 AI 요약 생성 (병렬)             │
└─────────────────────────────────────┘
```

**인메모리 큐 vs RabbitMQ 비교**

| 특징 | 인메모리 큐 | RabbitMQ |
|------|-------------|----------|
| 메시지 지속성 | 서버 재시작 시 소실 | 디스크에 저장, 재시작 후 보존 |
| 분산 처리 | 단일 서버만 가능 | 여러 서버에서 동일 큐 처리 |
| 병렬 처리 | 단일 스레드 순차 처리 | 3-5개 Consumer 병렬 처리 |
| 스케일 아웃 | 불가능 | 가능 (Consumer 수만 늘리면 됨) |
| 모니터링 | 로그로만 확인 | 웹 관리 콘솔 제공 |
| 구현 복잡도 | 간단 | 설정 필요 |

### 2.5. RabbitMQ 기초 (초보자 가이드)

#### 2.5.1. RabbitMQ란 무엇인가?

**비유로 이해하기**

RabbitMQ는 **식당의 주방 시스템**과 같습니다:

```
[웨이터들] → [주방장 (RabbitMQ)] → [요리사들 (Consumers)]
           │
           ├─ 주문 1: 파스타
           ├─ 주문 2: 피자
           ├─ 주문 3: 스테이크
           └─ 주문 4: 샐러드
                     ↓
              [주문 대기열 (Queue)]
                     ↓
        ┌────────────┴────────────┐
        ↓           ↓           ↓
     요리사 1     요리사 2     요리사 3
   (파스타 조리)  (피자 조리)  (스테이크 조리)
```

- **Producer (웨이터)**: 주문을 받아서 주방에 전달
- **Exchange (주방장)**: 주문을 적절한 조리대로 배분
- **Queue (조리대)**: 주문이 순서대로 대기
- **Consumer (요리사)**: 대기열에서 주문을 가져와 조리

**왜 RabbitMQ인가?**

1. **안정성**: 서버가 죽어도 메시지가 사라지지 않음
2. **분산 처리**: 여러 서버가 함께 작업을 나누어 처리
3. **비동기 처리**: 요청을 보내고 기다리지 않고 바로 다른 작업 가능
4. **관리 용이성**: 웹 콘솔로 상황 모니터링 가능

#### 2.5.2. RabbitMQ 핵심 개념

**1. Producer (생산자)**
- 메시지를 보내는 애플리케이션
- 우리 시스템에서는 리뷰 생성 이벤트를 발생시키는 `ReviewAiSummaryEventListener`

**2. Exchange (교환기)**
- Producer로부터 메시지를 받아 Queue로 배분하는 역할
- Exchange 타입:
  - **Direct**: 정확한 routing key와 일치하는 Queue로 전송
  - **Fanout**: 연결된 모든 Queue로 방송
  - **Topic**: 패턴 매칭으로 Queue에 전송

```
[Producer] → [Exchange: Direct]
                   │
        ┌──────────┼──────────┐
        ↓          ↓          ↓
    Queue A    Queue B    Queue C
  (routing:   (routing:   (routing:
   "review")   "user")     "order")
```

**3. Queue (대기열)**
- 메시지가 저장되는 곳
- FIFO (First In, First Out) 방식
- 각 Queue는 하나 이상의 Consumer가 구독 가능

**4. Consumer (소비자)**
- Queue에서 메시지를 꺼내서 처리하는 애플리케이션
- 우리 시스템에서는 `@RabbitListener`가 있는 `ReviewSummaryQueueProcessor`

**5. Binding (바인딩)**
- Exchange와 Queue를 연결하는 규칙
- routing key를 기반으로 연결

#### 2.5.3. RabbitMQ 관리 콘솔 사용법

**접속 정보**

| 항목 | 값 |
|------|-----|
| URL | http://s4.java21.net:15672 |
| ID | admin |
| Password | nhnacademy123! |

**주요 포트**
- `5672`: AMQP 포트 (애플리케이션이 사용)
- `15672`: 관리 콘솔 포트 (사용자가 사용)

**관리 콘솔 주요 기능**

1. **Overview 탭**: 전체 시스템 상태 확인
   - 메시지 전송/수송速率
   - Queue 크기
   - Connection 상태

2. **Queues 탭**: 큐 관리
   - 큐 목록 확인
   - 큐 생성/삭제
   - 메시지 미리보기
   - 메시지 수동으로 보내기/삭제하기

3. **Exchanges 탭**: Exchange 관리
   - Exchange 목록 확인
   - Exchange 생성/삭제

4. **Bindings 탭**: 바인딩 관리
   - Exchange와 Queue의 연결 확인

**직접 Queue 생성해보기**

1. 관리 콘솔 접속: http://s4.java21.net:15672
2. 상단 메뉴에서 **Queues** 탭 클릭
3. **Add a new queue** 섹션에서:
   - **Virtual host**: `/`
   - **Name**: `nhnacademy-library-review`
   - **Type**: `Quorum Queue` (권장) 또는 `Classic Queue`
   - **Durability**: `Durable` (서버 재시작 후에도 큐 유지)
   - **Auto delete**: 체크 해제
4. **Add queue** 버튼 클릭

**메시지 수동으로 보내보기 (테스트용)**

1. 생성된 큐 이름 클릭
2. **Publish message** 섹션에서:
   - **Payload**: `{"bookId": 1, "enqueueTime": 1234567890}`
   - **Headers**: Content-Type을 `application/json`으로 설정
3. **Publish message** 버튼 클릭
4. **Get messages** 섹션에서 메시지 수신 확인

#### 2.5.4. Spring Boot와 RabbitMQ 연동

**의존성 추가 (pom.xml)**

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

**설정 (application.properties)**

```properties
# RabbitMQ 연결 정보
spring.rabbitmq.host=s4.java21.net
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=nhnacademy123!

# Consumer 설정 (병렬 처리 수)
spring.rabbitmq.listener.simple.concurrency=3
spring.rabbitmq.listener.simple.max-concurrency=5
spring.rabbitmq.listener.simple.acknowledge-mode=auto

# Queue 이름 (커스텀)
rabbitmq.queue.review-summary=nhnacademy-library-review
```

**설정 설명**

| 설정 | 설명 | 예시 |
|------|------|------|
| `concurrency` | 최소 Consumer 스레드 수 | 3 (항상 3개 스레드 유지) |
| `max-concurrency` | 최대 Consumer 스레드 수 | 5 (부하 시 5개까지 증가) |
| `acknowledge-mode` | 메시지 확인 모드 | auto (처리 성공 시 자동 확인) |

**RabbitMQ 설정 클래스**

```java
@Configuration
public class RabbitMQConfig {

    // Queue 선언
    @Bean
    public Queue reviewSummaryQueue() {
        return QueueBuilder.durable("nhnacademy-library-review").build();
    }

    // Exchange 선언 (Direct 방식)
    @Bean
    public DirectExchange exchange() {
        return new DirectExchange("nhnacademy-library-exchange", true, false);
    }

    // Queue와 Exchange 바인딩
    @Bean
    public Binding binding(Queue queue, DirectExchange exchange) {
        return BindingBuilder.bind(queue)
                .to(exchange)
                .with("review.summary");
    }

    // JSON 메시지 컨버터
    @Bean
    public MessageConverter jsonMessageConverter() {
        return new Jackson2JsonMessageConverter();
    }
}
```

**메시지 발행 (Producer)**

```java
@Service
@RequiredArgsConstructor
public class ReviewSummaryQueueService {

    private final RabbitTemplate rabbitTemplate;

    public boolean enqueue(Long bookId) {
        ReviewSummaryTask task = new ReviewSummaryTask(bookId);
        rabbitTemplate.convertAndSend(
            "nhnacademy-library-exchange",  // Exchange
            "review.summary",                // Routing Key
            task                             // Message (JSON 변환됨)
        );
        return true;
    }
}
```

**메시지 수신 (Consumer)**

```java
@Component
@RequiredArgsConstructor
public class ReviewSummaryQueueProcessor {

    private final ReviewAiSummaryService aiSummaryService;

    // 자동으로 메시지 수신
    @RabbitListener(
        queues = "${rabbitmq.queue.review-summary}",
        concurrency = "3-5"  // 3~5개 Consumer 스레드
    )
    public void processTask(ReviewSummaryTask task) {
        aiSummaryService.generateSummary(task.getBookId());
    }
}
```

#### 2.5.5. RabbitMQ 모니터링

**로그에서 확인할 내용**

```
✓ 정상 동작 로그:
Published summary task for book 123 to RabbitMQ queue
Processing summary task for book 123
Completed summary task for book 123 in 2500ms

✗ 에러 로그:
Failed to publish summary task - Connection refused
Failed to process task - Channel closed
```

**관리 콘솔에서 모니터링할 지표**

| 지표 | 정상 상태 | 문제 상태 |
|------|-----------|-----------|
| Ready messages | 0~10개 | 100개 이상 (처리 속도 부족) |
| Unacked messages | 0~5개 | Consumer 수 이상 (처리 중단) |
| Consumer count | 3~5개 | 0개 (Consumer 다운) |
| Publish rate | 분당 수십 개 | 0개 (발행 중단) |
| Deliver rate | 분당 수십 개 | 0개 (소비 중단) |

**문제 해결 가이드**

1. **큐에 메시지가 계속 쌓일 때**
   - Consumer 수 증가 (`max-concurrency` 설정 확인)
   - Consumer 로그 확인 (에러가 없는지)
   - LLM 응답 시간 확인

2. **Consumer가 메시지를 소비하지 않을 때**
   - RabbitMQ 연결 상태 확인
   - `@RabbitListener`가 정상적으로 빈 등록되었는지 확인
   - 애플리케이션 로그에서 Connection 에러 확인

3. **메시지가 중복 처리될 때**
   - `acknowledge-mode` 확인 (auto인지)
   - Exception 발생 시 재시도 횟수 확인

---

### 2.6. 확장 스키마 설계

**기존 필드**

```sql
book_id BIGINT PRIMARY KEY
review_count BIGINT
average_rating NUMERIC(3,2)
rating_1_count ~ rating_5_count INTEGER
review_summary TEXT
is_summary_dirty BOOLEAN
```

**추가된 필드 (누적 요약용)**

```sql
last_summarized_count BIGINT  -- 마지막으로 요약한 리뷰 수
is_generating BOOLEAN         -- 현재 요약 생성 중인지 (중복 실행 방지)
```

**필드 설명**

| 필드명 | 용도 | 예시 |
|--------|------|------|
| `last_summarized_count` | 어디까지 요약했는지 추적 | 50 (50개까지 요약됨) |
| `is_generating` | 중복 실행 방지 | true (요약 생성 중) |

**누적 요약 로직**

```
현재 리뷰 수: 100
last_summarized_count: 50

새로운 리뷰: 51~100번 (50개)
이 50개만 요약해서 기존 요약과 머지
last_summarized_count = 100으로 업데이트
```

### 2.7. 중복 실행 방지

**문제: 동시에 여러 이벤트가 발생하면?**

시나리오:
- 사용자 A: 리뷰 작성 → 요약 이벤트 발생
- 사용자 B: 리뷰 작성 → 요약 이벤트 발생 (동시에!)
- 두 요약이 동시에 실행됨
- 비용 낭비 + 데이터 충돌

**해결 1단계: 큐 기반 아키텍처**

큐에 작업이 쌓이고, 단일 워커 스레드가 순차적으로 처리하므로 동시성 문제 자체가 발생하지 않음.

**해결 2단계: is_generating 플래그**

이중 안전장치:
1. 요약 시작 전: is_generating = true 확인
2. true면 요약 건너뜀기 (이미 진행 중)
3. 요약 시작: is_generating = true 설정
4. 요약 완료: is_generating = false 설정

**해결 3단계: 중복 요청 필터링 (Deduplication)**

```java
// 5초 내 같은 도서의 요약 요청은 무시
private static final long DEDUP_WINDOW_MS = 5000;
```

### 2.8. 비용 최적화 종합

**전략 비교**

| 전략 | 비용 | 장점 | 단점 |
|------|------|------|------|
| 전체 재요약 | 높음 | 구현 간단 | 리뷰 많으면 비용 큼 |
| 누적 요약 | 중간 | 비용 절감 | Drift 발생 가능 |
| Dirty Flag | 낮음 | 조건부 실행 | 충분한 데이터 필요 |
| RabbitMQ | 낮음 | 병렬 처리, 안정성 | 설정 복잡도 증가 |

**최적 전략**

```
RabbitMQ + Dirty Flag + 누적 요약 + 중복 실행 방지

1. is_summary_dirty = true일 때만 실행
2. 새 리뷰만 요약 (누적)
3. RabbitMQ 큐에서 메시지 대기 (안정성 보장)
4. 3-5개 Consumer가 병렬 처리 (성능 향상)
5. is_generating로 이중 안전장치
6. Dedup으로 중복 요청 제거

비용 70% 절감 + 동시성 문제 해결 + 서버 안정성
```

---

## 3. 구현 가이드 (Step-by-Step)

### STEP 1: 리뷰 통계 테이블 설계

**목표:** 리뷰 통계와 요약을 저장할 테이블 만들기

**필요한 필드**

| 필드명 | 타입 | 설명 | 예시 |
|--------|------|------|------|
| book_id | BIGINT | 도서 ID (PK이자 FK) | 1 |
| review_count | BIGINT | 전체 리뷰 수 | 100 |
| average_rating | NUMERIC(3,2) | 평균 평점 | 4.50 |
| rating_1_count | INTEGER | 1점 리뷰 수 | 2 |
| rating_2_count | INTEGER | 2점 리뷰 수 | 3 |
| rating_3_count | INTEGER | 3점 리뷰 수 | 5 |
| rating_4_count | INTEGER | 4점 리뷰 수 | 20 |
| rating_5_count | INTEGER | 5점 리뷰 수 | 70 |
| last_reviewed_at | TIMESTAMP | 가장 최근 리뷰 시간 | 2024-01-10 10:00:00 |
| review_summary | TEXT | AI 생성 요약 | "장점은..." |
| is_summary_dirty | BOOLEAN | 요약 갱신 필요 여부 | true |
| last_summarized_count | BIGINT | 마지막 요약 리뷰 수 | 50 |
| is_generating | BOOLEAN | 요약 생성 중 여부 | false |
| updated_at | TIMESTAMP | 마지막 갱신 시간 | 2024-01-10 10:00:00 |
| version | BIGINT | 낙관적 잠금 (JPA) | 1 |

**구현 힌트**
- `@Table(name = "book_review_summary")`
- `@Id`가 `book_id`이면서 동시에 외래키
- `@OneToOne` 관계로 Book과 연결
- `@Version`으로 낙관적 잠금

### STEP 2: 이벤트 클래스 정의

**목표:** 리뷰 관련 이벤트를 정의하기

**필요한 이벤트**
1. `ReviewCreatedEvent` - 리뷰 생성 이벤트
2. `ReviewAiSummaryEvent` - AI 요약 이벤트

**구현 가이드**

이벤트는 불변(Immutable) 객체로 설계하고 `book_id`를 포함해야 합니다. Java의 `record` 타입을 활용해 보세요.

**생각해볼 점**
- 왜 record를 사용할까요? (불변성, equals/hashCode 자동 생성)
- 이벤트에 어떤 정보를 담아야 할까요?

### STEP 3: ReviewService에서 이벤트 발행

**목표:** 리뷰 저장 후 이벤트 발행하기

**구현 흐름**

1. `ApplicationEventPublisher`를 주입받기
2. 리뷰 저장 후 `publishEvent()`로 이벤트 발행
3. `@Transactional` 사용하여 트랜잭션 커밋 후에 이벤트가 발행되도록 하기

**구현 힌트**
- 이벤트는 트랜잭션 커밋 후에 발행되어야 안전합니다
- `eventPublisher.publishEvent(new ReviewCreatedEvent(bookId))` 형태로 사용

### STEP 4: 통계 업데이트 리스너 구현

**목표:** 리뷰 생성 이벤트를 받아 통계를 업데이트하기

**구현 가이드**

1. `@Service` 클래스 생성
2. `@TransactionalEventListener`로 이벤트 수신
3. `phase = TransactionPhase.AFTER_COMMIT`으로 커밋 후에 실행
4. 독립된 트랜잭션에서 통계 업데이트

**어노테이션 설명**
- `@TransactionalEventListener`: 트랜잭션 커밋 후에 실행
- `@Transactional(propagation = REQUIRES_NEW)`: 새로운 독립 트랜잭션에서 실행

**생각해볼 점**
- 왜 `REQUIRES_NEW`를 사용할까요? (독립적인 트랜잭션)

### STEP 5: 통계 업데이트 로직 구현

**목표:** 평균 평점, 리뷰 수 등을 계산해서 저장하기

**구현 흐름**

1. 리뷰 통계 조회 (COUNT, AVG 등 집계 함수 사용)
2. BookReviewSummary 조회 또는 생성
3. 통계 업데이트
4. `is_summary_dirty = true` 설정
5. AI 요약 이벤트 발행

**SQL 힌트**

별점별 리뷰 수와 평균 평점을 조회하려면 `CASE WHEN`과 집계 함수를 활용하세요.

### STEP 6: RabbitMQ 설정 구현

**목표:** RabbitMQ 연결 설정과 Queue/Exchange 선언하기

**구현 가이드**

```java
@Configuration
public class RabbitMQConfig {

    @Value("${rabbitmq.queue.review-summary}")
    private String reviewSummaryQueueName;

    private static final String EXCHANGE = "nhnacademy-library-exchange";
    private static final String ROUTING_KEY = "review.summary";

    // Queue 선언
    @Bean
    public Queue reviewSummaryQueue() {
        return QueueBuilder.durable(reviewSummaryQueueName).build();
    }

    // Exchange 선언 (Direct 방식)
    @Bean
    public DirectExchange exchange() {
        return new DirectExchange(EXCHANGE, true, false);
    }

    // Queue와 Exchange 바인딩
    @Bean
    public Binding binding(Queue reviewSummaryQueue, DirectExchange exchange) {
        return BindingBuilder.bind(reviewSummaryQueue)
                .to(exchange)
                .with(ROUTING_KEY);
    }

    // JSON 메시지 컨버터
    @Bean
    public MessageConverter jsonMessageConverter() {
        return new Jackson2JsonMessageConverter();
    }

    // RabbitTemplate with JSON 컨버터
    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setMessageConverter(jsonMessageConverter());
        return rabbitTemplate;
    }
}
```

**application.properties 설정**

```properties
# RabbitMQ 연결 정보
spring.rabbitmq.host=s4.java21.net
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=nhnacademy123!

# Consumer 설정
spring.rabbitmq.listener.simple.concurrency=3
spring.rabbitmq.listener.simple.max-concurrency=5
spring.rabbitmq.listener.simple.acknowledge-mode=auto

# Queue 이름
rabbitmq.queue.review-summary=nhnacademy-library-review
```

**핵심 개념**
- `Durable Queue`: 서버 재시작 후에도 큐 유지
- `Direct Exchange`: 정확한 routing key와 일치하는 Queue로 전송
- `JSON Converter`: Java 객체를 JSON으로 자동 변환
- `Acknowledge-mode=auto`: 처리 성공 시 자동으로 메시지 확인

### STEP 7: 큐 서비스 구현 (RabbitMQ Producer)

**목표:** RabbitMQ로 메시지를 발행하는 서비스 만들기

**구현 가이드**

1. `RabbitTemplate`을 주입받기
2. 중복 요청 방지를 위해 `ConcurrentHashMap`으로 `pendingBooks` 관리
3. `enqueue()` 메서드에서 중복 체크 후 `rabbitTemplate.convertAndSend()`로 메시지 발행
4. `ReviewSummaryTask` 객체를 JSON으로 자동 변환되도록 구현

**핵심 개념**
- `RabbitTemplate.convertAndSend()`: Java 객체를 JSON으로 변환해서 발행
- `ConcurrentHashMap`: 스레드 안전한 맵 (중복 요청 추적용)
- Deduplication: 5초 내 중복 요청 무시

### STEP 8: RabbitMQ Consumer 구현

**목표:** RabbitMQ에서 메시지를 수신하여 처리하는 Consumer 만들기

**구현 가이드**

1. `@Component` 클래스에 `@RabbitListener`로 메시지 수신 메서드 구현
2. `concurrency = "3-5"`로 3~5개 Consumer 스레드 설정
3. 메시지 수신 후 `ReviewAiSummaryService`로 요약 생성 위임
4. 처리 완료 후 `pendingBooks` Map에서 제거

**핵심 개념**
- `@RabbitListener`: 자동으로 메시지를 수신
- 병렬 처리: 여러 책의 요약을 동시에 처리 가능
- Acknowledge-mode=auto: 처리 성공 시 자동 메시지 확인

### STEP 8: AI 요약 이벤트 리스너 구현 (큐에 추가만)

**목표:** 이벤트를 받아 큐에 작업 추가하기

**구현 가이드**

```java
@Component
@RequiredArgsConstructor
public class ReviewAiSummaryEventListener {

    private final ReviewSummaryQueueService queueService;

    @Async
    @EventListener
    public void handleReviewAiSummaryEvent(ReviewAiSummaryEvent event) {
        boolean enqueued = queueService.enqueue(event.bookId());
        if (enqueued) {
            log.info("Enqueued AI summary task for book {}", event.bookId());
        } else {
            log.debug("Summary task for book {} already queued (dedup)", event.bookId());
        }
    }
}
```

**변경점**
- 기존: @Async로 직접 AI 요약 처리
- 변경: 큐에 작업만 추가 → 워커가 처리

### STEP 9: AI 요약 이벤트 리스너 구현 (RabbitMQ에 메시지 발행)

**목표:** 이벤트를 받아 RabbitMQ에 메시지 발행하기

**구현 가이드**

1. `@Async`와 `@EventListener`로 이벤트 수신
2. `ReviewSummaryQueueService.enqueue()`로 RabbitMQ에 메시지 발행
3. 중복 요청 체크 결과에 따라 로그 출력

### STEP 10: Async 설정 (일반 비동기 처리용)

### STEP 10: Async 설정 (일반 비동기 처리용)

**목표:** 일반적인 비동기 처리를 위한 Executor 설정

**구현 가이드**

```java
@Configuration
public class AsyncConfig {

    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-task-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}
```

**설명**
- RabbitMQ를 사용하므로 전용 `summaryQueueExecutor`는 필요 없음
- `@RabbitListener`의 `concurrency` 설정으로 Consumer 수 조절

### STEP 11: AI 요약 서비스 구현 (누적 요약 포함)

**목표:** 실제 AI 요약을 생성하고 저장하기

**구현 가이드**

1. `BookReviewSummary` 조회
2. 조건 확인: 리뷰 수 >= 5, `is_summary_dirty == true`, `is_generating == false`
3. 조건 만족 시 `is_generating = true` 설정 (중복 실행 방지)
4. `last_summarized_count` 이후의 새 리뷰만 조회
5. `ReviewSummarizer`로 요약 생성 (누적 요약)
6. 요약 저장 및 상태 업데이트

### STEP 12: ReviewSummarizer 구현 (누적 요약)

**목표:** Map-Reduce 방식과 누적 요약을 지원하기

**구현 흐름**

1. **전체 요약 (`summarizeReviews`)**
   - 리뷰를 CHUNK_SIZE(10)개씩 묶기
   - 각 청크를 요약 (Map 단계)
   - 부분 요약본들을 합쳐서 최종 요약 (Reduce 단계)

2. **누적 요약 (`summarizeIncremental`)**
   - 새 리뷰를 CHUNK_SIZE개씩 묶기
   - 각 청크를 요약 (Map 단계)
   - 부분 요약본 + 기존 요약을 머지 (Reduce 단계)

**누적 요약 프롬프트**

```
기존 요약:
{existing_summary}

새로운 리뷰 요약본:
{new_summaries}

위 두 내용을 통합해서 전체 리뷰를 종합한 '최종 요약'을 작성해주세요.
기존 요약의 핵심 내용은 유지하면서, 새로운 정보를 추가해주세요.

출력 형식:
장점: ...
단점: ...
총평: ...
```

### STEP 13: Drift 방지용 Full Rebuild 전략

**문제: 누적 요약의 Drift 현상**

Drift란? 누적 요약을 계속 병합하면 요약 내용이 점점 길어지고 핵심이 흐려지는 현상입니다.

**해결: 주기적으로 Full Rebuild**

전략:
1. 새 리뷰가 특정 개수(예: 10개) 이상이면 전체 재요약
2. `review_count - last_summarized_count`가 일정 이상이면 재요약

**구현 힌트**
- `reviewSummarizer.getReduceThreshold()`로 임계값 확인
- Full Rebuild가 필요하면 전체 리뷰를 다시 요약
- 그렇지 않으면 새 리뷰만 누적 요약

### STEP 14: 사용자에게 요약 보여주기

**목표:** 저장된 요약을 즉시 반환하기 (비차단)

**구현 가이드**

1. DB에 저장된 요약을 즉시 반환
2. 요약이 없으면 "리뷰 분석 중입니다..." 메시지 반환
3. AI 요약이 백그라운드에서 생성되도록 비차단 처리

**장점**
- 사용자는 즉시 응답 받음
- AI 요약이 백그라운드에서 생성됨
- 다음 요청부터는 완성된 요약 제공

---

## 4. 실습 미션

### 미션 1: 이벤트 클래스 만들기

**과제:** `ReviewCreatedEvent`와 `ReviewAiSummaryEvent`를 구현하세요.

**요구사항**
- record 타입 사용
- 불변 객체로 설계
- book_id 필드 포함

### 미션 2: 청킹(Chunking) 구현하기

**과제:** 리스트를 주어진 크기로 나누는 메서드를 구현하세요.

```java
private <T> List<List<T>> partition(List<T> list, int size) {
    // 구현해보세요!
}
```

**힌트**
- for문과 subList 활용
- 또는 Stream API 활용

### 미션 3: Dirty Flag 로직 구현하기

**과제:** 다음 조건을 만족하는 메서드를 구현하세요.

```java
public boolean shouldGenerateSummary(BookReviewSummary summary) {
    // 조건:
    // 1. 리뷰 수 >= 5
    // 2. is_summary_dirty == true
    // 3. is_generating == false

    // 위 세 조건이 모두 만족하면 true 반환
}
```

### 미션 4: 누적 요약 로직 구현하기

**과제:** 새 리뷰만 추출하는 로직을 구현하세요.

```java
public List<BookReview> findNewReviews(
        Long bookId,
        Long lastSummarizedCount) {

    // lastSummarizedCount 이후의 리뷰만 조회
    // BookReviewRepository에 메서드 추가 필요
}
```

**힌트**

```java
// BookReviewRepository
@Query("SELECT r FROM BookReview r " +
       "WHERE r.book.id = :bookId " +
       "AND r.id > :lastSummarizedCount " +
       "ORDER BY r.id ASC")
List<BookReview> findByBookIdAndIdGreaterThanOrderByIdAsc(
    @Param("bookId") Long bookId,
    @Param("lastSummarizedCount") Long lastSummarizedCount
);
```

### 미션 5: Full Rebuild 조건 구현하기

**과제:** Full Rebuild가 필요한지 판단하는 로직을 구현하세요.

```java
public boolean needsFullRebuild(BookReviewSummary summary) {
    // review_count와 last_summarized_count의 차이가
    // REBUILD_THRESHOLD(10) 이상이면 true 반환
}
```

### 미션 6: 큐 Deduplication 구현하기

**과제:** 중복 요청을 필터링하는 로직을 구현하세요.

```java
private static final long DEDUP_WINDOW_MS = 5000; // 5초

public boolean shouldEnqueue(Long bookId) {
    Long lastEnqueueTime = pendingBooks.get(bookId);
    long now = System.currentTimeMillis();

    // 5초 내 같은 bookId의 요청이 있으면 false 반환
    // 없으면 true 반환
}
```

---

## 5. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

### 개념 이해
- [ ] 왜 리뷰를 요약해야 하는지 안다
- [ ] Map-Reduce 전략을 이해한다
- [ ] 누적 요약(Incremental Summary)을 이해한다
- [ ] Dirty Flag 패턴을 이해한다
- [ ] **메시지 큐 기반 아키텍처를 이해한다**
- [ ] **RabbitMQ의 기본 개념을 이해한다** (Producer, Exchange, Queue, Consumer)
- [ ] **왜 인메모리 큐에서 RabbitMQ로 전환했는지 안다**
- [ ] 중복 실행 방지 전략을 이해한다
- [ ] Drift 현상과 Full Rebuild 전략을 이해한다

### 구현 능력
- [ ] 이벤트 클래스를 정의할 수 있다
- [ ] @EventListener를 사용할 수 있다
- [ ] @Async로 비동기 처리할 수 있다
- [ ] **RabbitMQ 연결 설정을 할 수 있다**
- [ ] **@RabbitListener로 메시지를 수신할 수 있다**
- [ ] **RabbitTemplate으로 메시지를 발행할 수 있다**
- [ ] **RabbitMQ 관리 콘솔을 사용할 수 있다**
- [ ] **Deduplication 로직을 구현할 수 있다**
- [ ] Map-Reduce 요약 로직을 구현할 수 있다
- [ ] 누적 요약 로직을 구현할 수 있다
- [ ] 중복 실행 방지를 구현할 수 있다
- [ ] Dirty Flag로 비용을 최적화할 수 있다

### 아키텍처 설계
- [ ] 관심사 분리 (Separation of Concerns)를 이해한다
- [ ] **왜 메시지 큐 기반 아키텍처가 필요한지 안다**
- [ ] **@Async만으로는 충분하지 않은 이유를 안다**
- [ ] **낙관적 잠금 충돌이 왜 발생하는지 안다**
- [ ] **RabbitMQ가 어떻게 동시성 문제를 해결하는지 안다**
- [ ] 비동기 처리의 장단점을 안다
- [ ] 누적 요약과 전체 재요약의 트레이드오프를 안다

---

## 6. 심화 학습 주제

### 주제 1: 큐 vs 직접 @Async

**@Async만 사용할 때의 문제점**
```
리뷰 10개 동시 생성
    ↓
10개의 @Async 스레드가 동시에 BookReviewSummary 업데이트 시도
    ↓
version 충돌 (낙관적 잠금)
    ↓
ObjectOptimisticLockingFailureException
```

**큐 기반 아키텍처의 해결**
```
리뷰 10개 동시 생성
    ↓
10개의 이벤트가 큐에 추가됨
    ↓
단일 워커 스레드가 순차적으로 처리
    ↓
version 충돌 없음
```

### 주제 2: Refine 전략

Map-Reduce 대신 Refine 전략을 사용하면 어떨까요?

**Refine 방식**
1. 첫 번째 리뷰 청크를 요약
2. 두 번째 청크를 읽으면서 "기존 요약본에 이 내용도 추가"
3. 세 번째 청크를 읽으면서 "기존 요약본에 이 내용도 추가"
...반복...

장점: 문맥 흐름 유지 잘 됨
단점: 순서대로 처리해야 해서 느림

**생각해볼 점**
- 어떤 상황에서 Refine이 더 적합할까요?
- 속도 vs 정확도 트레이드오프는?

### 주제 3: 분산 락 (Distributed Lock)

`is_generating` 플래그만으로 충분할까요?

**고려사항**
- 여러 서버 인스턴스가 실행 중이면?
- DB 레벨 락이 필요할까?
- Redis 분산 락은 어떨까?

### 주제 4: 요약 품질 모니터링

요약 품질을 어떻게 측정할까요?

**지표**
- 요약 길이 (너무 길어지지 않는지)
- Drift 정도 (기존 요약과 얼마나 다른지)
- 사용자 만족도 (별점과 요약의 연관성)

### 주제 5: RabbitMQ 실전 활용

실제 프로젝트에서 RabbitMQ를 도입한 경험과 운영 노하우

**도입 배경**

1단계: @Async만 사용
```
문제: 리뷰 10개 동시 생성 → 10개 스레드 동시에 요약 처리
→ 낙관적 잠금 충돌 발생
```

2단계: 인메모리 큐 (LinkedBlockingQueue)
```
해결: 단일 스레드 워커로 순차 처리
→ 충돌 해결

새로운 문제:
- 서버 재시작 시 큐 소실
- 단일 서버에서만 처리 가능
- LLM 호출이 블로킹 → 한 요약이 끝날 때까지 대기
```

3단계: RabbitMQ 도입
```
해결:
- 메시지 지속성 (서버 재시작해도 보존)
- 3-5개 Consumer 병렬 처리
- 여러 서버 인스턴스에서 동일 큐 처리 가능
```

**RabbitMQ vs 인메모리 큐 비교**

| 상황 | 인메모리 큐 | RabbitMQ |
|------|-------------|----------|
| 정상 상태 | 잘 동작함 | 잘 동작함 |
| 서버 재시작 | 큐의 모든 작업 소실 | 큐의 작업 보존됨 |
| 트래픽 급증 | 단일 스레드로 처리 부족 | Consumer 수 자동 증가 |
| 다중 인스턴스 | 각각의 큐가 따로 동작 | 모든 인스턴스가 동일 큐 처리 |
| 장애 복구 | 불가능 | 자동으로 재시도 (DLQ) |

**운영 팁**

1. **Consumer 수 조절**
   ```properties
   # 트래픽이 적을 때
   spring.rabbitmq.listener.simple.concurrency=1
   spring.rabbitmq.listener.simple.max-concurrency=2

   # 트래픽이 많을 때
   spring.rabbitmq.listener.simple.concurrency=5
   spring.rabbitmq.listener.simple.max-concurrency=10
   ```

2. **모니터링 필수 지표**
   - Ready messages: 100개 이상이면 처리 속도 부족
   - Unacked messages: Consumer 수 이상이면 처리 중단
   - Consumer count: 0개이면 Consumer 다운

3. **메시지 재시도 정책**
   ```properties
   # 최대 재시도 횟수
   spring.rabbitmq.listener.simple.retry.max-attempts=3

   # 재시도 간격
   spring.rabbitmq.listener.simple.retry.initial-interval=2000
   ```

4. **Dead Letter Queue (DLQ) 활용**
   - 재시료 실패 시 메시지를 별도 큐로 이동
   - 나중에 원인 분석 후 재처리 가능

---

## 7. 다음 단계

이제 여러분은:
- 비용 효율적인 AI 시스템을 설계할 수 있습니다
- 이벤트 기반 아키텍처를 구현할 수 있습니다
- **RabbitMQ 기반 메시지 큐 시스템을 구축할 수 있습니다**
- Map-Reduce 같은 분산 처리 전략을 이해합니다
- 누적 요약으로 비용을 최적화할 수 있습니다
- **동시성 문제를 메시지 큐로 해결할 수 있습니다**
- 운영 수준의 안정적인 시스템을 구축할 수 있습니다

**다음에 도전해 볼 수 있는 것들**
- Redis를 활용한 분산 캐싱
- Kafka를 활용한 대용량 실시간 스트리밍
- A/B 테스트로 요약 품질 개선
- Dead Letter Queue를 활용한 에러 처리 및 재처리
- RabbitMQ Cluster로 고가용성 구성

---

**마지막 조언**

> "완벽한 코드는 없습니다. 중요한 것은 사용자의 피드백을 듣고 지속적으로 개선하는 것입니다.
> 누적 요약으로 비용을 줄이되, 주기적으로 Full Rebuild로 품질을 유지하세요.
> 메시지 큐로 동시성 문제를 해결하고 안정적이고 확장 가능한 시스템을 구축하세요.
> RabbitMQ 관리 콘솔을 활용해 시스템 상태를 항상 모니터링하세요.
> 지금 당장 구현부터 시작해 보세요!"
