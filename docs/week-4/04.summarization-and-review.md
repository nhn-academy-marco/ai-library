# 04. 리뷰 요약 시스템 구현하기

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- Week 4의 01, 02, 03 문서 내용 (성능 최적화)
- Week 1의 이벤트 기반 아키텍처 이해
- Spring의 @Async, @Transactional 활용 능력
- 리스트 처리와 Stream API 기초

---

## 1. 개요

수백 개의 리뷰를 일일이 읽는 것은 사용자에게 큰 부담입니다. AI가 리뷰를 요약해서 "장점/단점/추천대상"을 3~5문장으로 정리해 주면 사용자 경험이 획기적으로 개선됩니다.

**이 문서에서 배울 내용:**
- 왜 리뷰를 요약해야 하는지
- Map-Reduce 요약 전략이란 무엇인지
- **누적 요약(Incremental Summary)으로 비용 최적화하기**
- **큐(Queue) 기반 비동기 처리 아키텍처**
- Dirty Flag로 비용 절감하기
- 중복 실행 방지 전략
- 단계별 구현 가이드

---

## 2. 핵심 개념 이해

### 2.1. 왜 요약이 필요한가?

**문제: AI도 읽기엔 너무 길어요**

AI의 컨텍스트 윈도우(Context Window)는 한 번에 읽을 수 있는 토큰 수에 제한이 있습니다. 리뷰 100개는 약 10,000토큰에 달해 한계를 초과할 수 있습니다.

**해결: 나눠서 읽고 합치기**

1. 리뷰를 10개씩 묶음 (Chunking)
2. 각 묶음을 요약 (Map)
3. 요약본들을 다시 합쳐서 최종 요약 (Reduce)

### 2.2. Map-Reduce 전략

**비유로 이해하기**

10권의 책을 요약해야 한다고 가정해 봅시다.

Map-Reduce 방식:
1. 10명의 친구에게 각각 1권씩 나눠줌
2. 친구들이 각자 요약해서 가져옴 (Map 단계)
3. 내가 모아서 최종 요약본 작성 (Reduce 단계)

장점:
- 병렬 처리 가능으로 속도 향상
- 한 사람이 모두 읽을 필요 없음

**구조**

```
[입력]
리뷰 1~100

[Map 단계]
리뷰 1~10   → 요약1
리뷰 11~20 → 요약2
리뷰 21~30 → 요약3
...
리뷰 91~100 → 요약10

[Reduce 단계]
요약1 + 요약2 + ... + 요약10
    ↓
[최종 요약]
"이 책의 장점은... 단점은..."
```

### 2.3. 누적 요약(Incremental Summary)

**문제: 전체를 다시 요약하면 비용이 큼**

전체 재요약 방식:
- 리뷰 5개: 요약 ($0.10)
- 리뷰 10개: 전체 재요약 ($0.10)
- 리뷰 15개: 전체 재요약 ($0.10)
- ...
- 리뷰 100개: 전체 재요약 ($0.10)
- 총: $1.00 (10회)

**해결: 새 리뷰만 요약해서 병합**

누적 요약 방식:
- 리뷰 5개: 요약1 ($0.10) → 저장
- 리뷰 10개: 새로운 5개만 요약 ($0.05) → 요약1 + 요약2 머지
- 리뷰 15개: 새로운 5개만 요약 ($0.05) → 요약1-2 + 요약3 머지
- ...
- 리뷰 100개: 새로운 5개만 요약 ($0.05)
- 총: $0.55 (50% 절감)

**비유로 이해하기**

전체 재요약은 1장부터 100장까지 다시 읽는 것과 같아 시간이 오래 걸립니다. 누적 요약은 지금까지 읽은 요약본에 새로운 10장만 추가해서 요약하므로 시간이 단축됩니다.

### 2.4. 큐(Queue) 기반 아키텍처

**문제: @Async만으로는 충분하지 않아요**

@Async로 처리할 때 발생하는 문제:
- 리뷰 10개가 동시에 생성되면 10개의 스레드가 동시에 AI 요약 처리 시도
- 낙관적 잠금(Optimistic Lock) 충돌 발생
- `ObjectOptimisticLockingFailureException` 에러

```
사용자 A: 리뷰 작성 → 이벤트 발생 → @Async 스레드 1
사용자 B: 리뷰 작성 → 이벤트 발생 → @Async 스레드 2
사용자 C: 리뷰 작성 → 이벤트 발생 → @Async 스레드 3
...
스레드 1, 2, 3이 동시에 같은 BookReviewSummary 업데이트 시도
→ version 충돌 → 에러 발생!
```

**해결: 큐 + 단일 워커 스레드**

```
[이벤트 발생]
ReviewCreatedEvent → 통계 업데이트 → ReviewAiSummaryEvent
                                              ↓
                                        [큐에 작업 추가]
                                              ↓
                                    [단일 워커 스레드]
                                              ↓
                                        [순차적 처리]
```

**장점**
1. **순차적 처리**: 같은 도서의 요약이 순차적으로 처리되어 낙관적 잠금 충돌 방지
2. **디커플링**: 리뷰 생성과 AI 요약 처리가 완전히 분리됨
3. **중복 제거**: 5초 내 같은 도서의 요약 요청은 자동으로 제거됨
4. **부하 조절**: 처리 속도를 조절할 수 있음

**아키텍처 구조**

```
┌─────────────────┐
│ ReviewService  │
│  .createReview()│
└───────┬────────┘
        │
        ▼
┌─────────────────────────────────────┐
│  ReviewCreatedEvent 발생          │
└───────┬─────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│  ReviewEventListener              │
│  - 통계 업데이트               │
│  - ReviewAiSummaryEvent 발생     │
└───────┬─────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│  ReviewAiSummaryEventListener     │
│  @Async                        │
│  - 큐에 작업 추가               │
└───────┬─────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│  ReviewSummaryQueueService       │
│  - BlockingQueue               │
│  - 중복 요청 필터링 (Dedup)   │
└───────┬─────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│  ReviewSummaryQueueProcessor     │
│  (단일 스레드 워커)           │
│  - 큐에서 작업 가져오기          │
│  - 순차적 처리                  │
└───────┬─────────────────────────┘
        │
        ▼
┌─────────────────────────────────────┐
│  ReviewAiSummaryService         │
│  - 실제 AI 요약 생성             │
└───────────────────────────────────┘
```

### 2.5. 확장 스키마 설계

**기존 필드**

```sql
book_id BIGINT PRIMARY KEY
review_count BIGINT
average_rating NUMERIC(3,2)
rating_1_count ~ rating_5_count INTEGER
review_summary TEXT
is_summary_dirty BOOLEAN
```

**추가된 필드 (누적 요약용)**

```sql
last_summarized_count BIGINT  -- 마지막으로 요약한 리뷰 수
is_generating BOOLEAN         -- 현재 요약 생성 중인지 (중복 실행 방지)
```

**필드 설명**

| 필드명 | 용도 | 예시 |
|--------|------|------|
| `last_summarized_count` | 어디까지 요약했는지 추적 | 50 (50개까지 요약됨) |
| `is_generating` | 중복 실행 방지 | true (요약 생성 중) |

**누적 요약 로직**

```
현재 리뷰 수: 100
last_summarized_count: 50

새로운 리뷰: 51~100번 (50개)
이 50개만 요약해서 기존 요약과 머지
last_summarized_count = 100으로 업데이트
```

### 2.6. 중복 실행 방지

**문제: 동시에 여러 이벤트가 발생하면?**

시나리오:
- 사용자 A: 리뷰 작성 → 요약 이벤트 발생
- 사용자 B: 리뷰 작성 → 요약 이벤트 발생 (동시에!)
- 두 요약이 동시에 실행됨
- 비용 낭비 + 데이터 충돌

**해결 1단계: 큐 기반 아키텍처**

큐에 작업이 쌓이고, 단일 워커 스레드가 순차적으로 처리하므로 동시성 문제 자체가 발생하지 않음.

**해결 2단계: is_generating 플래그**

이중 안전장치:
1. 요약 시작 전: is_generating = true 확인
2. true면 요약 건너뜀기 (이미 진행 중)
3. 요약 시작: is_generating = true 설정
4. 요약 완료: is_generating = false 설정

**해결 3단계: 중복 요청 필터링 (Deduplication)**

```java
// 5초 내 같은 도서의 요약 요청은 무시
private static final long DEDUP_WINDOW_MS = 5000;
```

### 2.7. 비용 최적화 종합

**전략 비교**

| 전략 | 비용 | 장점 | 단점 |
|------|------|------|------|
| 전체 재요약 | 높음 | 구현 간단 | 리뷰 많으면 비용 큼 |
| 누적 요약 | 중간 | 비용 절감 | Drift 발생 가능 |
| Dirty Flag | 낮음 | 조건부 실행 | 충분한 데이터 필요 |
| 큐 기반 | 낮음 | 순차 처리, 동시성 해결 | 복잡도 증가 |

**최적 전략**

```
큐 기반 + Dirty Flag + 누적 요약 + 중복 실행 방지

1. is_summary_dirty = true일 때만 실행
2. 새 리뷰만 요약 (누적)
3. 큐에서 순차적으로 처리 (동시성 해결)
4. is_generating로 이중 안전장치
5. Dedup으로 중복 요청 제거

비용 70% 절감 + 동시성 문제 해결
```

---

## 3. 구현 가이드 (Step-by-Step)

### STEP 1: 리뷰 통계 테이블 설계

**목표:** 리뷰 통계와 요약을 저장할 테이블 만들기

**필요한 필드**

| 필드명 | 타입 | 설명 | 예시 |
|--------|------|------|------|
| book_id | BIGINT | 도서 ID (PK이자 FK) | 1 |
| review_count | BIGINT | 전체 리뷰 수 | 100 |
| average_rating | NUMERIC(3,2) | 평균 평점 | 4.50 |
| rating_1_count | INTEGER | 1점 리뷰 수 | 2 |
| rating_2_count | INTEGER | 2점 리뷰 수 | 3 |
| rating_3_count | INTEGER | 3점 리뷰 수 | 5 |
| rating_4_count | INTEGER | 4점 리뷰 수 | 20 |
| rating_5_count | INTEGER | 5점 리뷰 수 | 70 |
| last_reviewed_at | TIMESTAMP | 가장 최근 리뷰 시간 | 2024-01-10 10:00:00 |
| review_summary | TEXT | AI 생성 요약 | "장점은..." |
| is_summary_dirty | BOOLEAN | 요약 갱신 필요 여부 | true |
| last_summarized_count | BIGINT | 마지막 요약 리뷰 수 | 50 |
| is_generating | BOOLEAN | 요약 생성 중 여부 | false |
| updated_at | TIMESTAMP | 마지막 갱신 시간 | 2024-01-10 10:00:00 |
| version | BIGINT | 낙관적 잠금 (JPA) | 1 |

**구현 힌트**
- `@Table(name = "book_review_summary")`
- `@Id`가 `book_id`이면서 동시에 외래키
- `@OneToOne` 관계로 Book과 연결
- `@Version`으로 낙관적 잠금

### STEP 2: 이벤트 클래스 정의

**목표:** 리뷰 관련 이벤트를 정의하기

**필요한 이벤트**
1. `ReviewCreatedEvent` - 리뷰 생성 이벤트
2. `ReviewAiSummaryEvent` - AI 요약 이벤트

**구현 가이드**

```java
// 이벤트는 불변(Immutable) 객체로 설계
// book_id를 포함

public record ReviewCreatedEvent(Long bookId) {
}

public record ReviewAiSummaryEvent(Long bookId) {
}
```

**생각해볼 점**
- 왜 record를 사용할까요? (불변성, equals/hashCode 자동 생성)
- 이벤트에 어떤 정보를 담아야 할까요?

### STEP 3: ReviewService에서 이벤트 발행

**목표:** 리뷰 저장 후 이벤트 발행하기

**구현 흐름**

```java
@Service
public class ReviewService {

    private final ApplicationEventPublisher eventPublisher;

    @Transactional
    public Long createReview(Long bookId, ReviewCreateRequest request) {
        // 1. Book 조회
        // 2. Review 엔티티 생성
        // 3. Review 저장

        // 4. 이벤트 발행 (트랜잭션 커밋 후 실행됨)
        eventPublisher.publishEvent(new ReviewCreatedEvent(bookId));

        return savedReview.getId();
    }
}
```

**구현 힌트**
- `@Transactional`을 사용해야 이벤트가 트랜잭션 후에 발행
- `ApplicationEventPublisher`를 주입받아 사용

### STEP 4: 통계 업데이트 리스너 구현

**목표:** 리뷰 생성 이벤트를 받아 통계를 업데이트하기

**구현 가이드**

```java
@Service
@RequiredArgsConstructor
public class ReviewEventListener {

    private final ReviewService reviewService;

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void handleReviewCreatedEvent(ReviewCreatedEvent event) {
        // 통계 업데이트 로직 호출
        reviewService.updateReviewSummary(event.bookId());
    }
}
```

**어노테이션 설명**
- `@TransactionalEventListener`: 트랜잭션 커밋 후에 실행
- `phase = TransactionPhase.AFTER_COMMIT`: 커밋된 후에 실행
- `@Transactional(propagation = Propagation.REQUIRES_NEW)`: 새로운 트랜잭션에서 실행

**생각해볼 점**
- 왜 `REQUIRES_NEW`를 사용할까요? (독립적인 트랜잭션)

### STEP 5: 통계 업데이트 로직 구현

**목표:** 평균 평점, 리뷰 수 등을 계산해서 저장하기

**구현 흐름**

```java
@Service
public class ReviewService {

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateReviewSummary(Long bookId) {
        // 1. 리뷰 통계 조회 (COUNT, AVG 등 집계 함수)
        // 2. BookReviewSummary 조회 또는 생성
        // 3. 통계 업데이트
        // 4. is_summary_dirty = true 설정
        // 5. AI 요약 이벤트 발행

        eventPublisher.publishEvent(new ReviewAiSummaryEvent(bookId));
    }
}
```

**SQL 힌트**

```sql
-- 별점별 리뷰 수와 평균 평점 조회
SELECT
    COUNT(*) as review_count,
    AVG(rating) as average_rating,
    SUM(CASE WHEN rating = 1 THEN 1 ELSE 0 END) as rating_1_count,
    SUM(CASE WHEN rating = 2 THEN 1 ELSE 0 END) as rating_2_count,
    SUM(CASE WHEN rating = 3 THEN 1 ELSE 0 END) as rating_3_count,
    SUM(CASE WHEN rating = 4 THEN 1 ELSE 0 END) as rating_4_count,
    SUM(CASE WHEN rating = 5 THEN 1 ELSE 0 END) as rating_5_count
FROM book_reviews
WHERE book_id = :bookId
```

### STEP 6: 큐 서비스 구현

**목표:** AI 요약 작업을 관리하는 큐 서비스 만들기

**구현 가이드**

```java
@Service
public class ReviewSummaryQueueService {

    // 작업 대기열 (Thread-safe)
    private final BlockingQueue<ReviewSummaryTask> queue = new LinkedBlockingQueue<>();

    // 중복 요청 방지 (bookId -> enqueueTime)
    private final Map<Long, Long> pendingBooks = new ConcurrentHashMap<>();

    private static final long DEDUP_WINDOW_MS = 5000; // 5초 내 중복 무시

    /**
     * 큐에 작업 추가 (중복 요청 필터링)
     */
    public boolean enqueue(Long bookId) {
        Long lastEnqueueTime = pendingBooks.get(bookId);
        long now = System.currentTimeMillis();

        // 중복 요청 체크
        if (lastEnqueueTime != null && (now - lastEnqueueTime) < DEDUP_WINDOW_MS) {
            return false; // 중복으로 무시
        }

        boolean offered = queue.offer(new ReviewSummaryTask(bookId));
        if (offered) {
            pendingBooks.put(bookId, now);
        }
        return offered;
    }

    /**
     * 큐에서 작업 꺼내기
     */
    public ReviewSummaryTask dequeue(long timeout) throws InterruptedException {
        ReviewSummaryTask task = queue.poll(timeout, TimeUnit.MILLISECONDS);
        if (task != null) {
            pendingBooks.remove(task.getBookId());
        }
        return task;
    }
}
```

**Task 객체**

```java
@Value
public class ReviewSummaryTask {
    Long bookId;
    long enqueueTime;

    public ReviewSummaryTask(Long bookId) {
        this.bookId = bookId;
        this.enqueueTime = System.currentTimeMillis();
    }
}
```

**핵심 개념**
- `BlockingQueue`: 스레드 안전한 큐
- `ConcurrentHashMap`: 스레드 안전한 맵
- `Deduplication`: 5초 내 중복 요청 무시

### STEP 7: 큐 프로세서 구현

**목표:** 큐에서 작업을 가져와 순차적으로 처리하는 워커 만들기

**구현 가이드**

```java
@Component
@RequiredArgsConstructor
public class ReviewSummaryQueueProcessor {

    private final ReviewSummaryQueueService queueService;
    private final ReviewAiSummaryService reviewAiSummaryService;

    private static final long POLL_TIMEOUT_MS = 1000; // 1초
    private volatile boolean running = true;

    /**
     * 애플리케이션 시작 시 워커 시작
     */
    @EventListener(ApplicationReadyEvent.class)
    @Async("summaryQueueExecutor")
    public void start() {
        processQueue();
    }

    /**
     * 큐에서 작업을 가져와 처리
     */
    private void processQueue() {
        while (running) {
            try {
                ReviewSummaryTask task = queueService.dequeue(POLL_TIMEOUT_MS);
                if (task != null) {
                    processTask(task);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }

    private void processTask(ReviewSummaryTask task) {
        try {
            reviewAiSummaryService.generateSummary(task.getBookId());
        } catch (Exception e) {
            log.error("Failed to process task for book {}", task.getBookId(), e);
        }
    }
}
```

### STEP 8: AI 요약 이벤트 리스너 구현 (큐에 추가만)

**목표:** 이벤트를 받아 큐에 작업 추가하기

**구현 가이드**

```java
@Component
@RequiredArgsConstructor
public class ReviewAiSummaryEventListener {

    private final ReviewSummaryQueueService queueService;

    @Async
    @EventListener
    public void handleReviewAiSummaryEvent(ReviewAiSummaryEvent event) {
        boolean enqueued = queueService.enqueue(event.bookId());
        if (enqueued) {
            log.info("Enqueued AI summary task for book {}", event.bookId());
        } else {
            log.debug("Summary task for book {} already queued (dedup)", event.bookId());
        }
    }
}
```

**변경점**
- 기존: @Async로 직접 AI 요약 처리
- 변경: 큐에 작업만 추가 → 워커가 처리

### STEP 9: Async 설정

**목표:** 큐 처리를 위한 전용 Executor 설정

**구현 가이드**

```java
@Configuration
public class AsyncConfig {

    @Bean(name = "summaryQueueExecutor")
    public Executor summaryQueueExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(1);  // 단일 스레드 (순차 처리)
        executor.setMaxPoolSize(1);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("summary-queue-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}
```

**설정 설명**
- `corePoolSize=1`: 단일 스레드로 순차 처리
- `maxPoolSize=1`: 스레드 수 증가 안함
- `CallerRunsPolicy`: 큐가 꽉 차면 호출 스레드가 실행

### STEP 10: AI 요약 서비스 구현 (누적 요약 포함)

**목표:** 실제 AI 요약을 생성하고 저장하기

**구현 가이드**

```java
@Service
public class ReviewAiSummaryService {

    private static final int MIN_REVIEW_COUNT_FOR_SUMMARY = 5;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void generateSummary(Long bookId) {
        // 1. BookReviewSummary 조회
        // 2. 조건 확인:
        //    - 리뷰 수 >= 5?
        //    - is_summary_dirty == true?
        //    - is_generating == false? (중복 실행 방지)
        // 3. 조건 만족 시:
        //    a) is_generating = true 설정
        //    b) 새 리뷰만 조회 (last_summarized_count 이후)
        //    c) ReviewSummarizer로 요약 생성 (누적 요약)
        //    d) 요약 저장
        //    e) last_summarized_count 업데이트
        //    f) is_summary_dirty = false
        //    g) is_generating = false
    }
}
```

**누적 요약 로직**

```java
// 새 리뷰만 조회
Long lastSummarizedCount = summary.getLastSummarizedCount();
if (lastSummarizedCount == null) {
    lastSummarizedCount = 0L;
}

// last_summarized_count 이후의 리뷰만 조회
List<BookReview> newReviews = reviewRepository
    .findByBookIdAndIdGreaterThanOrderByIdAsc(
        bookId,
        lastSummarizedCount
    );

// 새 리뷰가 있으면 요약
if (!newReviews.isEmpty()) {
    // 기존 요약 가져오기
    String existingSummary = summary.getReviewSummary();

    // 새 리뷰 요약
    String newSummary = reviewSummarizer.summarizeIncremental(
        newReviews,
        existingSummary
    );

    // 저장
    summary.updateSummary(newSummary);
}
```

### STEP 11: ReviewSummarizer 구현 (누적 요약)

**목표:** Map-Reduce 방식과 누적 요약을 지원하기

**구현 흐름**

```java
@Service
public class ReviewSummarizer {

    private static final int CHUNK_SIZE = 10;
    private final ChatModel chatModel;

    // 전체 요약 (초기 요약용)
    public String summarizeReviews(List<String> reviews) {
        // 1. 리뷰를 CHUNK_SIZE개씩 묶기 (Chunking)
        // 2. Map: 각 청크를 요약
        // 3. Reduce: 부분 요약본들을 합쳐서 최종 요약
    }

    // 누적 요약 (새 리뷰만 요약해서 기존 요약과 머지)
    public String summarizeIncremental(
            List<String> newReviews,
            String existingSummary) {

        // 1. 새 리뷰를 CHUNK_SIZE개씩 묶기
        // 2. Map: 각 청크를 요약
        // 3. Reduce: 부분 요약본 + 기존 요약 머지
        //    프롬프트: "기존 요약에 새로운 내용을 추가해서 통합 요약을 만드세요"
    }
}
```

**누적 요약 프롬프트**

```
기존 요약:
{existing_summary}

새로운 리뷰 요약본:
{new_summaries}

위 두 내용을 통합해서 전체 리뷰를 종합한 '최종 요약'을 작성해주세요.
기존 요약의 핵심 내용은 유지하면서, 새로운 정보를 추가해주세요.

출력 형식:
장점: ...
단점: ...
총평: ...
```

### STEP 12: Drift 방지용 Full Rebuild 전략

**문제: 누적 요약의 Drift 현상**

Drift란? 누적 요약을 계속 병합하면 요약 내용이 점점 길어지고 핵심이 흐려지는 현상입니다.

- 요약 1: "장점: 설명 잘 됨"
- 요약 2: "장점: 설명 잘 됨, 예제 좋음"
- 요약 3: "장점: 설명 잘 됨, 예제 좋음, 연습문제 많음"
- ...
- 요약 10: 내용이 너무 길어짐, 핵심이 흐려짐

**해결: 주기적으로 Full Rebuild**

전략:
1. 새 리뷰가 특정 개수 이상이면 전체 재요약
2. 또는 `review_count - last_summarized_count`가 일정 이상이면 재요약

**구현 가이드**

```java
private static final int REBUILD_THRESHOLD = 10;  // 10회 누적 후 재요약

public void generateSummary(Long bookId) {
    BookReviewSummary summary = ...

    long reviewCount = summary.getReviewCount();
    long lastSummarizedCount = summary.getLastSummarizedCount() != null
        ? summary.getLastSummarizedCount()
        : 0;

    // Full Rebuild 필요성 확인
    boolean needsRebuild = (reviewCount - lastSummarizedCount) >= reviewSummarizer.getReduceThreshold();

    if (needsRebuild) {
        // 전체 리뷰를 다시 요약 (Map-Reduce)
        List<BookReview> allReviews = reviewRepository.findAllByBookId(bookId);
        String newSummary = reviewSummarizer.summarizeReviews(allReviews);

        summary.updateSummaryWithCount(newSummary, reviewCount);
    } else {
        // 누적 요약
        List<BookReview> newReviews = findNewReviews(...);
        String newSummary = reviewSummarizer.summarizeIncremental(
            newReviews,
            summary.getReviewSummary()
        );

        summary.updateSummaryWithCount(newSummary, reviewCount);
    }
}
```

### STEP 13: 사용자에게 요약 보여주기

**목표:** 저장된 요약을 즉시 반환하기 (비차단)

**구현 가이드**

```java
@Service
public class BookSearchService {

    public String getReviewSummary(Long bookId) {
        // DB에 저장된 요약을 즉시 반환
        return summaryRepository.findById(bookId)
            .map(summary -> {
                if (summary.getReviewSummary() != null) {
                    return summary.getReviewSummary();  // 저장된 요약
                }
                return "리뷰 분석 중입니다... (현재 "
                    + summary.getReviewCount() + "개)";
            })
            .orElse("아직 등록된 리뷰가 없습니다.");
    }
}
```

**장점**
- 사용자는 즉시 응답 받음
- AI 요약이 백그라운드에서 생성됨
- 다음 요청부터는 완성된 요약 제공

---

## 4. 실습 미션

### 미션 1: 이벤트 클래스 만들기

**과제:** `ReviewCreatedEvent`와 `ReviewAiSummaryEvent`를 구현하세요.

**요구사항**
- record 타입 사용
- 불변 객체로 설계
- book_id 필드 포함

### 미션 2: 청킹(Chunking) 구현하기

**과제:** 리스트를 주어진 크기로 나누는 메서드를 구현하세요.

```java
private <T> List<List<T>> partition(List<T> list, int size) {
    // 구현해보세요!
}
```

**힌트**
- for문과 subList 활용
- 또는 Stream API 활용

### 미션 3: Dirty Flag 로직 구현하기

**과제:** 다음 조건을 만족하는 메서드를 구현하세요.

```java
public boolean shouldGenerateSummary(BookReviewSummary summary) {
    // 조건:
    // 1. 리뷰 수 >= 5
    // 2. is_summary_dirty == true
    // 3. is_generating == false

    // 위 세 조건이 모두 만족하면 true 반환
}
```

### 미션 4: 누적 요약 로직 구현하기

**과제:** 새 리뷰만 추출하는 로직을 구현하세요.

```java
public List<BookReview> findNewReviews(
        Long bookId,
        Long lastSummarizedCount) {

    // lastSummarizedCount 이후의 리뷰만 조회
    // BookReviewRepository에 메서드 추가 필요
}
```

**힌트**

```java
// BookReviewRepository
@Query("SELECT r FROM BookReview r " +
       "WHERE r.book.id = :bookId " +
       "AND r.id > :lastSummarizedCount " +
       "ORDER BY r.id ASC")
List<BookReview> findByBookIdAndIdGreaterThanOrderByIdAsc(
    @Param("bookId") Long bookId,
    @Param("lastSummarizedCount") Long lastSummarizedCount
);
```

### 미션 5: Full Rebuild 조건 구현하기

**과제:** Full Rebuild가 필요한지 판단하는 로직을 구현하세요.

```java
public boolean needsFullRebuild(BookReviewSummary summary) {
    // review_count와 last_summarized_count의 차이가
    // REBUILD_THRESHOLD(10) 이상이면 true 반환
}
```

### 미션 6: 큐 Deduplication 구현하기

**과제:** 중복 요청을 필터링하는 로직을 구현하세요.

```java
private static final long DEDUP_WINDOW_MS = 5000; // 5초

public boolean shouldEnqueue(Long bookId) {
    Long lastEnqueueTime = pendingBooks.get(bookId);
    long now = System.currentTimeMillis();

    // 5초 내 같은 bookId의 요청이 있으면 false 반환
    // 없으면 true 반환
}
```

---

## 5. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

### 개념 이해
- [ ] 왜 리뷰를 요약해야 하는지 안다
- [ ] Map-Reduce 전략을 이해한다
- [ ] 누적 요약(Incremental Summary)을 이해한다
- [ ] Dirty Flag 패턴을 이해한다
- [ ] **큐(Queue) 기반 아키텍처를 이해한다**
- [ ] 중복 실행 방지 전략을 이해한다
- [ ] Drift 현상과 Full Rebuild 전략을 이해한다

### 구현 능력
- [ ] 이벤트 클래스를 정의할 수 있다
- [ ] @EventListener를 사용할 수 있다
- [ ] @Async로 비동기 처리할 수 있다
- [ ] **BlockingQueue를 사용할 수 있다**
- [ ] **단일 스레드 워커를 구현할 수 있다**
- [ ] **Deduplication 로직을 구현할 수 있다**
- [ ] Map-Reduce 요약 로직을 구현할 수 있다
- [ ] 누적 요약 로직을 구현할 수 있다
- [ ] 중복 실행 방지를 구현할 수 있다
- [ ] Dirty Flag로 비용을 최적화할 수 있다

### 아키텍처 설계
- [ ] 관심사 분리 (Separation of Concerns)를 이해한다
- [ ] **왜 큐 기반 아키텍처가 필요한지 안다**
- [ ] **@Async만으로는 충분하지 않은 이유를 안다**
- [ ] **낙관적 잠금 충돌이 왜 발생하는지 안다**
- [ ] 비동기 처리의 장단점을 안다
- [ ] 누적 요약과 전체 재요약의 트레이드오프를 안다

---

## 6. 심화 학습 주제

### 주제 1: 큐 vs 직접 @Async

**@Async만 사용할 때의 문제점**
```
리뷰 10개 동시 생성
    ↓
10개의 @Async 스레드가 동시에 BookReviewSummary 업데이트 시도
    ↓
version 충돌 (낙관적 잠금)
    ↓
ObjectOptimisticLockingFailureException
```

**큐 기반 아키텍처의 해결**
```
리뷰 10개 동시 생성
    ↓
10개의 이벤트가 큐에 추가됨
    ↓
단일 워커 스레드가 순차적으로 처리
    ↓
version 충돌 없음
```

### 주제 2: Refine 전략

Map-Reduce 대신 Refine 전략을 사용하면 어떨까요?

**Refine 방식**
1. 첫 번째 리뷰 청크를 요약
2. 두 번째 청크를 읽으면서 "기존 요약본에 이 내용도 추가"
3. 세 번째 청크를 읽으면서 "기존 요약본에 이 내용도 추가"
...반복...

장점: 문맥 흐름 유지 잘 됨
단점: 순서대로 처리해야 해서 느림

**생각해볼 점**
- 어떤 상황에서 Refine이 더 적합할까요?
- 속도 vs 정확도 트레이드오프는?

### 주제 3: 분산 락 (Distributed Lock)

`is_generating` 플래그만으로 충분할까요?

**고려사항**
- 여러 서버 인스턴스가 실행 중이면?
- DB 레벨 락이 필요할까?
- Redis 분산 락은 어떨까?

### 주제 4: 요약 품질 모니터링

요약 품질을 어떻게 측정할까요?

**지표**
- 요약 길이 (너무 길어지지 않는지)
- Drift 정도 (기존 요약과 얼마나 다른지)
- 사용자 만족도 (별점과 요약의 연관성)

### 주제 5: 메시지 브로커 도입

현재 인메모리 큐의 한계와 개선 방안

**현재 방식의 한계**
- 서버 재시작 시 큐의 작업 소실
- 단일 서버에서만 처리 가능
- 스케일 아웃 시 대응 어려움

**개선 방안**
- RabbitMQ: 안정적인 메시지 브로커
- Kafka: 대용량 처리
- Redis Pub/Sub: 간단한 메시징

---

## 7. 다음 단계

이제 여러분은:
- 비용 효율적인 AI 시스템을 설계할 수 있습니다
- 이벤트 기반 아키텍처를 구현할 수 있습니다
- **큐 기반 비동기 처리를 구현할 수 있습니다**
- Map-Reduce 같은 분산 처리 전략을 이해합니다
- 누적 요약으로 비용을 최적화할 수 있습니다
- **동시성 문제를 해결할 수 있습니다**
- 운영 수준의 안정적인 시스템을 구축할 수 있습니다

**다음에 도전해 볼 수 있는 것들**
- Redis를 활용한 분산 캐싱
- 대용량 트래픽 처리를 위한 메시지 브로커 (Kafka, RabbitMQ)
- A/B 테스트로 요약 품질 개선
- 실시간 리뷰 스트리밍 처리

---

**마지막 조언**

> "완벽한 코드는 없습니다. 중요한 것은 사용자의 피드백을 듣고 지속적으로 개선하는 것입니다.
> 누적 요약으로 비용을 줄이되, 주기적으로 Full Rebuild로 품질을 유지하세요.
> 큐 기반 아키텍처로 동시성 문제를 해결하고 안정적인 시스템을 구축하세요.
> 지금 당장 구현부터 시작해 보세요!"
