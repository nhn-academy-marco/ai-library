# 04. 리뷰 요약 시스템 구현하기

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- Week 4의 01, 02, 03 문서 내용 (성능 최적화)
- Week 1의 이벤트 기반 아키텍처 이해
- Spring의 @Async, @Transactional 활용 능력
- 리스트 처리와 Stream API 기초

---

## 1. 개요

수백 개의 리뷰를 일일이 읽는 것은 사용자에게 큰 부담입니다. AI가 리뷰를 요약해서 "장점/단점/추천대상"을 3~5문장으로 정리해 주면 사용자 경험이 획기적으로 개선됩니다.

**이 문서에서 배울 내용:**
- 왜 리뷰를 요약해야 하는지
- Map-Reduce 요약 전략이란 무엇인지
- **누적 요약(Incremental Summary)으로 비용 최적화하기**
- 이벤트 기반 아키텍처로 비동기 처리하기
- Dirty Flag로 비용 절감하기
- 중복 실행 방지 전략
- 단계별 구현 가이드

---

## 2. 핵심 개념 이해

### 2.1. 왜 요약이 필요한가?

**문제: AI도 읽기엔 너무 길어요**

AI의 컨텍스트 윈도우(Context Window)는 한 번에 읽을 수 있는 토큰 수에 제한이 있습니다. 리뷰 100개는 약 10,000토큰에 달해 한계를 초과할 수 있습니다.

**해결: 나눠서 읽고 합치기**

1. 리뷰를 10개씩 묶음 (Chunking)
2. 각 묶음을 요약 (Map)
3. 요약본들을 다시 합쳐서 최종 요약 (Reduce)

### 2.2. Map-Reduce 전략

**비유로 이해하기**

10권의 책을 요약해야 한다고 가정해 봅시다.

Map-Reduce 방식:
1. 10명의 친구에게 각각 1권씩 나눠줌
2. 친구들이 각자 요약해서 가져옴 (Map 단계)
3. 내가 모아서 최종 요약본 작성 (Reduce 단계)

장점:
- 병렬 처리 가능으로 속도 향상
- 한 사람이 모두 읽을 필요 없음

**구조**

```
[입력]
리뷰 1~100

[Map 단계]
리뷰 1~10   → 요약1
리뷰 11~20 → 요약2
리뷰 21~30 → 요약3
...
리뷰 91~100 → 요약10

[Reduce 단계]
요약1 + 요약2 + ... + 요약10
    ↓
[최종 요약]
"이 책의 장점은... 단점은..."
```

### 2.3. 누적 요약(Incremental Summary)

**문제: 전체를 다시 요약하면 비용이 큼**

전체 재요약 방식:
- 리뷰 5개: 요약 ($0.10)
- 리뷰 10개: 전체 재요약 ($0.10)
- 리뷰 15개: 전체 재요약 ($0.10)
- ...
- 리뷰 100개: 전체 재요약 ($0.10)
- 총: $1.00 (10회)

**해결: 새 리뷰만 요약해서 병합**

누적 요약 방식:
- 리뷰 5개: 요약1 ($0.10) → 저장
- 리뷰 10개: 새로운 5개만 요약 ($0.05) → 요약1 + 요약2 머지
- 리뷰 15개: 새로운 5개만 요약 ($0.05) → 요약1-2 + 요약3 머지
- ...
- 리뷰 100개: 새로운 5개만 요약 ($0.05)
- 총: $0.55 (50% 절감)

**비유로 이해하기**

전체 재요약은 1장부터 100장까지 다시 읽는 것과 같아 시간이 오래 걸립니다. 누적 요약은 지금까지 읽은 요약본에 새로운 10장만 추가해서 요약하므로 시간이 단축됩니다.

### 2.4. 확장 스키마 설계

**기존 필드**

```sql
book_id BIGINT PRIMARY KEY
review_count BIGINT
average_rating NUMERIC(3,2)
rating_1_count ~ rating_5_count INTEGER
review_summary TEXT
is_summary_dirty BOOLEAN
```

**추가된 필드 (누적 요약용)**

```sql
last_summarized_count BIGINT  -- 마지막으로 요약한 리뷰 수
is_generating BOOLEAN         -- 현재 요약 생성 중인지 (중복 실행 방지)
```

**필드 설명**

| 필드명 | 용도 | 예시 |
|--------|------|------|
| `last_summarized_count` | 어디까지 요약했는지 추적 | 50 (50개까지 요약됨) |
| `is_generating` | 중복 실행 방지 | true (요약 생성 중) |

**누적 요약 로직**

```
현재 리뷰 수: 100
last_summarized_count: 50

새로운 리뷰: 51~100번 (50개)
이 50개만 요약해서 기존 요약과 머지
last_summarized_count = 100으로 업데이트
```

### 2.5. 중복 실행 방지

**문제: 동시에 여러 이벤트가 발생하면?**

시나리오:
- 사용자 A: 리뷰 작성 → 요약 이벤트 발생
- 사용자 B: 리뷰 작성 → 요약 이벤트 발생 (동시에!)
- 두 요약이 동시에 실행됨
- 비용 낭비 + 데이터 충돌

**해결: is_generating 플래그**

1. 요약 시작 전: is_generating = true 확인
2. true면 요약 건너뜀기 (이미 진행 중)
3. 요약 시작: is_generating = true 설정
4. 요약 완료: is_generating = false 설정

### 2.6. 비용 최적화 종합

**전략 비교**

| 전략 | 비용 | 장점 | 단점 |
|------|------|------|------|
| 전체 재요약 | 높음 | 구현 간단 | 리뷰 많으면 비용 큼 |
| 누적 요약 | 중간 | 비용 절감 | Drift 발생 가능 |
| Dirty Flag | 낮음 | 조건부 실행 | 충분한 데이터 필요 |

**최적 전략**

```
Dirty Flag + 누적 요약 + 중복 실행 방지

1. is_summary_dirty = true일 때만 실행
2. 새 리뷰만 요약 (누적)
3. is_generating로 중복 방지

비용 70% 절감
```

---

## 3. 구현 가이드 (Step-by-Step)

### STEP 1: 리뷰 통계 테이블 설계

**목표:** 리뷰 통계와 요약을 저장할 테이블 만들기

**필요한 필드**

| 필드명 | 타입 | 설명 | 예시 |
|--------|------|------|------|
| book_id | BIGINT | 도서 ID (PK이자 FK) | 1 |
| review_count | BIGINT | 전체 리뷰 수 | 100 |
| average_rating | NUMERIC(3,2) | 평균 평점 | 4.50 |
| rating_1_count | INTEGER | 1점 리뷰 수 | 2 |
| rating_2_count | INTEGER | 2점 리뷰 수 | 3 |
| rating_3_count | INTEGER | 3점 리뷰 수 | 5 |
| rating_4_count | INTEGER | 4점 리뷰 수 | 20 |
| rating_5_count | INTEGER | 5점 리뷰 수 | 70 |
| last_reviewed_at | TIMESTAMP | 가장 최근 리뷰 시간 | 2024-01-10 10:00:00 |
| review_summary | TEXT | AI 생성 요약 | "장점은..." |
| is_summary_dirty | BOOLEAN | 요약 갱신 필요 여부 | true |
| last_summarized_count | BIGINT | 마지막 요약 리뷰 수 | 50 |
| is_generating | BOOLEAN | 요약 생성 중 여부 | false |
| updated_at | TIMESTAMP | 마지막 갱신 시간 | 2024-01-10 10:00:00 |
| version | BIGINT | 낙관적 잠금 (JPA) | 1 |

**구현 힌트**
- `@Table(name = "book_review_summary")`
- `@Id`가 `book_id`이면서 동시에 외래키
- `@OneToOne` 관계로 Book과 연결
- `@Version`으로 낙관적 잠금

### STEP 2: 이벤트 클래스 정의

**목표:** 리뷰 관련 이벤트를 정의하기

**필요한 이벤트**
1. `ReviewCreatedEvent` - 리뷰 생성 이벤트
2. `ReviewAiSummaryEvent` - AI 요약 이벤트

**구현 가이드**

```java
// 이벤트는 불변(Immutable) 객체로 설계
// book_id를 포함

public record ReviewCreatedEvent(Long bookId) {
}

public record ReviewAiSummaryEvent(Long bookId) {
}
```

**생각해볼 점**
- 왜 record를 사용할까요? (불변성, equals/hashCode 자동 생성)
- 이벤트에 어떤 정보를 담아야 할까요?

### STEP 3: ReviewService에서 이벤트 발행

**목표:** 리뷰 저장 후 이벤트 발행하기

**구현 흐름**

```java
@Service
public class ReviewService {

    private final ApplicationEventPublisher eventPublisher;

    @Transactional
    public Long createReview(Long bookId, ReviewCreateRequest request) {
        // 1. Book 조회
        // 2. Review 엔티티 생성
        // 3. Review 저장

        // 4. 이벤트 발행 (트랜잭션 커밋 후 실행됨)
        eventPublisher.publishEvent(new ReviewCreatedEvent(bookId));

        return savedReview.getId();
    }
}
```

**구현 힌트**
- `@Transactional`을 사용해야 이벤트가 트랜잭션 후에 발행
- `ApplicationEventPublisher`를 주입받아 사용

### STEP 4: 통계 업데이트 리스너 구현

**목표:** 리뷰 생성 이벤트를 받아 통계를 업데이트하기

**구현 가이드**

```java
@Service
@RequiredArgsConstructor
public class ReviewEventListener {

    private final ReviewService reviewService;

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void handleReviewCreatedEvent(ReviewCreatedEvent event) {
        // 통계 업데이트 로직 호출
        reviewService.updateReviewSummary(event.bookId());
    }
}
```

**어노테이션 설명**
- `@TransactionalEventListener`: 트랜잭션 커밋 후에 실행
- `phase = TransactionPhase.AFTER_COMMIT`: 커밋된 후에 실행
- `@Transactional(propagation = Propagation.REQUIRES_NEW)`: 새로운 트랜잭션에서 실행

**생각해볼 점**
- 왜 `REQUIRES_NEW`를 사용할까요? (독립적인 트랜잭션)

### STEP 5: 통계 업데이트 로직 구현

**목표:** 평균 평점, 리뷰 수 등을 계산해서 저장하기

**구현 흐름**

```java
@Service
public class ReviewService {

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateReviewSummary(Long bookId) {
        // 1. 리뷰 통계 조회 (COUNT, AVG 등 집계 함수)
        // 2. BookReviewSummary 조회 또는 생성
        // 3. 통계 업데이트
        // 4. is_summary_dirty = true 설정
        // 5. AI 요약 이벤트 발행

        eventPublisher.publishEvent(new ReviewAiSummaryEvent(bookId));
    }
}
```

**SQL 힌트**

```sql
-- 별점별 리뷰 수와 평균 평점 조회
SELECT
    COUNT(*) as review_count,
    AVG(rating) as average_rating,
    SUM(CASE WHEN rating = 1 THEN 1 ELSE 0 END) as rating_1_count,
    SUM(CASE WHEN rating = 2 THEN 1 ELSE 0 END) as rating_2_count,
    SUM(CASE WHEN rating = 3 THEN 1 ELSE 0 END) as rating_3_count,
    SUM(CASE WHEN rating = 4 THEN 1 ELSE 0 END) as rating_4_count,
    SUM(CASE WHEN rating = 5 THEN 1 ELSE 0 END) as rating_5_count
FROM book_reviews
WHERE book_id = :bookId
```

### STEP 6: AI 요약 리스너 구현 (누적 요약 포함)

**목표:** 비동기로 AI 요약을 생성하고 저장하기

**구현 가이드**

```java
@Service
@RequiredArgsConstructor
public class ReviewAiSummeryEventListener {

    private static final int MIN_REVIEW_COUNT_FOR_SUMMARY = 5;

    private final BookReviewSummaryRepository summaryRepository;
    private final BookReviewRepository reviewRepository;
    private final ReviewSummarizer reviewSummarizer;

    @Async  // 비동기 실행
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void handleReviewAiSummeryEvent(ReviewAiSummaryEvent event) {
        // 1. BookReviewSummary 조회
        // 2. 조건 확인:
        //    - 리뷰 수 >= 5?
        //    - is_summary_dirty == true?
        //    - is_generating == false? (중복 실행 방지)
        // 3. 조건 만족 시:
        //    a) is_generating = true 설정 (중복 실행 방지)
        //    b) 새 리뷰만 조회 (last_summarized_count 이후)
        //    c) ReviewSummarizer로 요약 생성 (누적 요약)
        //    d) 요약 저장
        //    e) last_summarized_count 업데이트
        //    f) is_summary_dirty = false
        //    g) is_generating = false
    }
}
```

**누적 요약 로직**

```java
// 새 리뷰만 조회
Long lastSummarizedCount = summary.getLastSummarizedCount();
if (lastSummarizedCount == null) {
    lastSummarizedCount = 0L;
}

// last_summarized_count 이후의 리뷰만 조회
List<BookReview> newReviews = reviewRepository
    .findByBookIdAndIdGreaterThanOrderByIdAsc(
        bookId,
        lastSummarizedCount
    );

// 새 리뷰가 있으면 요약
if (!newReviews.isEmpty()) {
    // 기존 요약 가져오기
    String existingSummary = summary.getReviewSummary();

    // 새 리뷰 요약
    String newSummary = reviewSummarizer.summarizeIncremental(
        newReviews,
        existingSummary
    );

    // 저장
    summary.updateSummary(newSummary);
}
```

**어노테이션 설명**
- `@Async`: 별도 스레드에서 비동기 실행
- `@TransactionalEventListener`: 트랜잭션 커밋 후 실행
- `propagation = Propagation.REQUIRES_NEW`: 독립 트랜잭션

### STEP 7: ReviewSummarizer 구현 (누적 요약)

**목표:** Map-Reduce 방식과 누적 요약을 지원하기

**구현 흐름**

```java
@Service
public class ReviewSummarizer {

    private static final int CHUNK_SIZE = 10;
    private final ChatModel chatModel;

    // 전체 요약 (초기 요약용)
    public String summarizeReviews(List<String> reviews) {
        // 1. 리뷰를 CHUNK_SIZE개씩 묶기 (Chunking)
        // 2. Map: 각 청크를 요약
        // 3. Reduce: 부분 요약본들을 합쳐서 최종 요약
    }

    // 누적 요약 (새 리뷰만 요약해서 기존 요약과 머지)
    public String summarizeIncremental(
            List<String> newReviews,
            String existingSummary) {

        // 1. 새 리뷰를 CHUNK_SIZE개씩 묶기
        // 2. Map: 각 청크를 요약
        // 3. Reduce: 부분 요약본 + 기존 요약 머지
        //    프롬프트: "기존 요약에 새로운 내용을 추가해서 통합 요약을 만드세요"
    }
}
```

**누적 요약 프롬프트**

```
기존 요약:
{existing_summary}

새로운 리뷰 요약본:
{new_summaries}

위 두 내용을 통합해서 전체 리뷰를 종합한 '최종 요약'을 작성해주세요.
기존 요약의 핵심 내용은 유지하면서, 새로운 정보를 추가해주세요.

출력 형식:
장점: ...
단점: ...
총평: ...
```

### STEP 8: 중복 실행 방지 구현

**목표:** 동시에 여러 요약이 실행되는 것을 방지하기

**구현 가이드**

```java
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void handleReviewAiSummeryEvent(ReviewAiSummaryEvent event) {
    BookReviewSummary summary = summaryRepository.findById(event.bookId())
        .orElse(null);

    if (summary == null) {
        return;
    }

    // 중복 실행 방지 체크
    if (summary.getIsGenerating()) {
        log.info("이미 요약 생성 중입니다. 건너뜁니다.");
        return;  // 이미 생성 중이면 실행하지 않음
    }

    try {
        // 요약 시작 플래그 설정
        summary.setIsGenerating(true);
        summaryRepository.save(summary);

        // 요약 생성 로직...
        String newSummary = generateSummary(event.bookId());

        summary.updateSummary(newSummary);
        summary.setLastSummarizedCount(summary.getReviewCount());

    } finally {
        // 항상 플래그 해제 (에러 발생해도)
        summary.setIsGenerating(false);
        summaryRepository.save(summary);
    }
}
```

**생각해볼 점**
- 왜 `try-finally`를 사용할까요? (에러 발생해도 플래그 해제)
- `is_generating`만으로 충분할까요? (DB 레벨 락도 고려 필요)

### STEP 9: Drift 방지용 Full Rebuild 전략

**문제: 누적 요약의 Drift 현상**

Drift란? 누적 요약을 계속 병합하면 요약 내용이 점점 길어지고 핵심이 흐려지는 현상입니다.

- 요약 1: "장점: 설명 잘 됨"
- 요약 2: "장점: 설명 잘 됨, 예제 좋음"
- 요약 3: "장점: 설명 잘 됨, 예제 좋음, 연습문제 많음"
- ...
- 요약 10: 내용이 너무 길어짐, 핵심이 흐려짐

**해결: 주기적으로 Full Rebuild**

전략:
1. 매 10회 누적 요약마다 전체 재요약
2. 또는 last_summarized_count가 review_count와 너무 차이 나면 재요약

**구현 가이드**

```java
private static final int REBUILD_THRESHOLD = 10;  // 10회 누적 후 재요약

public void handleReviewAiSummeryEvent(ReviewAiSummaryEvent event) {
    BookReviewSummary summary = ...

    long reviewCount = summary.getReviewCount();
    long lastSummarizedCount = summary.getLastSummarizedCount() != null
        ? summary.getLastSummarizedCount()
        : 0;

    // Full Rebuild 필요성 확인
    boolean needsRebuild = (reviewCount - lastSummarizedCount) > REBUILD_THRESHOLD;

    if (needsRebuild) {
        // 전체 리뷰를 다시 요약 (Map-Reduce)
        List<BookReview> allReviews = reviewRepository.findAllByBookId(event.bookId());
        String newSummary = reviewSummarizer.summarizeReviews(allReviews);

        summary.updateSummary(newSummary);
        summary.setLastSummarizedCount(reviewCount);  // 초기화
    } else {
        // 누적 요약
        List<BookReview> newReviews = findNewReviews(...);
        String newSummary = reviewSummarizer.summarizeIncremental(
            newReviews,
            summary.getReviewSummary()
        );

        summary.updateSummary(newSummary);
        summary.setLastSummarizedCount(reviewCount);
    }
}
```

### STEP 10: 사용자에게 요약 보여주기

**목표:** 저장된 요약을 즉시 반환하기 (비차단)

**구현 가이드**

```java
@Service
public class BookSearchService {

    public String getReviewSummary(Long bookId) {
        // DB에 저장된 요약을 즉시 반환
        return summaryRepository.findById(bookId)
            .map(summary -> {
                if (summary.getReviewSummary() != null) {
                    return summary.getReviewSummary();  // 저장된 요약
                }
                return "리뷰 분석 중입니다... (현재 "
                    + summary.getReviewCount() + "개)";
            })
            .orElse("아직 등록된 리뷰가 없습니다.");
    }
}
```

**장점**
- 사용자는 즉시 응답 받음
- AI 요약이 백그라운드에서 생성됨
- 다음 요청부터는 완성된 요약 제공

---

## 4. 실습 미션

### 미션 1: 이벤트 클래스 만들기

**과제:** `ReviewCreatedEvent`와 `ReviewAiSummaryEvent`를 구현하세요.

**요구사항**
- record 타입 사용
- 불변 객체로 설계
- book_id 필드 포함

### 미션 2: 청킹(Chunking) 구현하기

**과제:** 리스트를 주어진 크기로 나누는 메서드를 구현하세요.

```java
private <T> List<List<T>> partition(List<T> list, int size) {
    // 구현해보세요!
}
```

**힌트**
- for문과 subList 활용
- 또는 Stream API 활용

### 미션 3: Dirty Flag 로직 구현하기

**과제:** 다음 조건을 만족하는 메서드를 구현하세요.

```java
public boolean shouldGenerateSummary(BookReviewSummary summary) {
    // 조건:
    // 1. 리뷰 수 >= 5
    // 2. is_summary_dirty == true
    // 3. is_generating == false

    // 위 세 조건이 모두 만족하면 true 반환
}
```

### 미션 4: 누적 요약 로직 구현하기

**과제:** 새 리뷰만 추출하는 로직을 구현하세요.

```java
public List<BookReview> findNewReviews(
        Long bookId,
        Long lastSummarizedCount) {

    // lastSummarizedCount 이후의 리뷰만 조회
    // BookReviewRepository에 메서드 추가 필요
}
```

**힌트**

```java
// BookReviewRepository
@Query("SELECT r FROM BookReview r " +
       "WHERE r.book.id = :bookId " +
       "AND r.id > :lastSummarizedCount " +
       "ORDER BY r.id ASC")
List<BookReview> findByBookIdAndIdGreaterThanOrderByIdAsc(
    @Param("bookId") Long bookId,
    @Param("lastSummarizedCount") Long lastSummarizedCount
);
```

### 미션 5: Full Rebuild 조건 구현하기

**과제:** Full Rebuild가 필요한지 판단하는 로직을 구현하세요.

```java
public boolean needsFullRebuild(BookReviewSummary summary) {
    // review_count와 last_summarized_count의 차이가
    // REBUILD_THRESHOLD(10) 이상이면 true 반환
}
```

---

## 5. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

### 개념 이해
- [ ] 왜 리뷰를 요약해야 하는지 안다
- [ ] Map-Reduce 전략을 이해한다
- [ ] 누적 요약(Incremental Summary)을 이해한다
- [ ] Dirty Flag 패턴을 이해한다
- [ ] 중복 실행 방지 전략을 이해한다
- [ ] Drift 현상과 Full Rebuild 전략을 이해한다

### 구현 능력
- [ ] 이벤트 클래스를 정의할 수 있다
- [ ] @EventListener를 사용할 수 있다
- [ ] @Async로 비동기 처리할 수 있다
- [ ] Map-Reduce 요약 로직을 구현할 수 있다
- [ ] 누적 요약 로직을 구현할 수 있다
- [ ] 중복 실행 방지를 구현할 수 있다
- [ ] Dirty Flag로 비용을 최적화할 수 있다

### 아키텍처 설계
- [ ] 관심사 분리 (Separation of Concerns)를 이해한다
- [ ] 왜 두 개의 이벤트 리스너로 나누는지 안다
- [ ] 비동기 처리의 장단점을 안다
- [ ] 누적 요약과 전체 재요약의 트레이드오프를 안다

---

## 6. 심화 학습 주제

### 주제 1: Refine 전략

Map-Reduce 대신 Refine 전략을 사용하면 어떨까요?

**Refine 방식**
1. 첫 번째 리뷰 청크를 요약
2. 두 번째 청크를 읽으면서 "기존 요약본에 이 내용도 추가"
3. 세 번째 청크를 읽으면서 "기존 요약본에 이 내용도 추가"
...반복...

장점: 문맥 흐름 유지 잘 됨
단점: 순서대로 처리해야 해서 느림

**생각해볼 점**
- 어떤 상황에서 Refine이 더 적합할까요?
- 속도 vs 정확도 트레이드오프는?

### 주제 2: 분산 락 (Distributed Lock)

`is_generating` 플래그만으로 충분할까요?

**고려사항**
- 여러 서버 인스턴스가 실행 중이면?
- DB 레벨 락이 필요할까?
- Redis 분산 락은 어떨까?

### 주제 3: 요약 품질 모니터링

요약 품질을 어떻게 측정할까요?

**지표**
- 요약 길이 (너무 길어지지 않는지)
- Drift 정도 (기존 요약과 얼마나 다른지)
- 사용자 만족도 (별점과 요약의 연관성)

---

## 7. 다음 단계

이제 여러분은:
- 비용 효율적인 AI 시스템을 설계할 수 있습니다
- 이벤트 기반 아키텍처를 구현할 수 있습니다
- Map-Reduce 같은 분산 처리 전략을 이해합니다
- 누적 요약으로 비용을 최적화할 수 있습니다
- 운영 수준의 안정적인 시스템을 구축할 수 있습니다

**다음에 도전해 볼 수 있는 것들**
- Redis를 활용한 분산 캐싱
- 대용량 트래픽 처리를 위한 메시지 큐 (Kafka, RabbitMQ)
- A/B 테스트로 요약 품질 개선
- 실시간 리뷰 스트리밍 처리

---

**마지막 조언**

> "완벽한 코드는 없습니다. 중요한 것은 사용자의 피드백을 듣고 지속적으로 개선하는 것입니다.
> 누적 요약으로 비용을 줄이되, 주기적으로 Full Rebuild로 품질을 유지하세요.
> 지금 당장 구현부터 시작해 보세요!"
