# 사용자 피드백 수집

## 개요

사용자로부터 검색 결과에 대한 피드백을 수집하고, 이를 통해 AI 검색 품질을 개선합니다. 수집된 피드백 데이터는 **지속적인 AI 시스템 개선의 핵심 자산**으로 활용됩니다.

## 학습 목표

- **JPA Entity 설계**: 도메인 모델을 데이터베이스 스키마로 매핑
- **계층형 아키텍처**: Controller → Service → Repository 구조 이해
- **사용자 인터랙션**: Inline Keyboard와 Callback Query 처리 흐름
- **데이터 설계**: 피드백 데이터를 AI 학습에 활용할 수 있는 구조 설계
- **피드백 루프**: 수집 → 분석 → 개선의 전체 사이클 이해

---

## 왜 피드백인가?

### AI 시스템의 성장 루프

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   사용자 검색 ──▶ 결과 표시 ──▶ 피드백 수집              │
│       ▲                                    │            │
│       │                                    ▼            │
│   더 나은 경험 ◀── AI 모델 개선 ◀── 데이터 분석          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**피드백이 중요한 이유:**
1. **객관적 품질 지표**: 사용자가 실제로 만족하는지 측정
2. **지속적 개선**: 시스템을 사용할수록 더 똑똑해짐
3. **개인화 기반**: 사용자별 선호도 학습 가능
4. **A/B 테스트**: 개선 효과를 정량적으로 검증

### 실무 사례

| 서비스 | 피드백 활용 |
|--------|-------------|
| **Netflix** | 시청 여부로 추천 알고리즘 개선 |
| **YouTube** | 클릭률, 시청 시간으로 추천 최적화 |
| **Google 검색** | 클릭 여부로 검색 순위 개선 |
| **Amazon** | 구매 여부로 상품 추천 개선 |

---

## 전체 아키텍처

### 시스템 구조도

```
┌─────────────────────────────────────────────────────────────┐
│                      Telegram User                         │
│                    (검색 결과 확인 후)                      │
└────────────────────────┬────────────────────────────────────┘
                         │ 클릭: 👍 도움이 됨
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                 Inline Keyboard (버튼 UI)                   │
│  [👍 도움이 됨] [👎 도움이 안됨]  [✅ 관련 있음] [❌ 관련 없음]│
└────────────────────────┬────────────────────────────────────┘
                         │ Callback Query 전송
                         ▼
┌─────────────────────────────────────────────────────────────┐
│              CallbackQueryHandler                          │
│  1. Callback 데이터 수신                                   │
│  2. 데이터 파싱 (query, bookId, type)                     │
│  3. FeedbackService 호출                                   │
│  4. 감사 메시지 전송                                       │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                FeedbackService                             │
│  • 피드백 저장                                             │
│  • 통계 계산                                               │
│  • 사용자별 조회                                           │
└──────────────────┬────────────────┬────────────────────────┘
                   │                │
                   ▼                ▼
        ┌──────────────────┐  ┌──────────────────┐
        │  Repository      │  │  AI Improvement  │
        │  (DB 저장)       │  │  Services        │
        └──────────────────┘  │  • 검색 재정렬    │
                               │  • 개인화        │
                               │  • 프롬프트 개선 │
                               │  • 품질 분석     │
                               │  • A/B 테스트     │
                               └──────────────────┘
```

### 데이터 흐름도

```
1. 사용자가 검색 → 결과 표시 + Inline Keyboard
                    ↓
2. 사용자가 버튼 클릭 → Callback Query 전송
                    ↓
3. CallbackHandler 수신 → 데이터 파싱
                    ↓
4. FeedbackService → DB 저장
                    ↓
5. 저장된 피드백 → 분석 및 AI 개선에 활용
                    ↓
6. 다음 검색 시 → 개선된 결과 제공
```

### 계층별 역할

```
┌─────────────────────────────────────────────────────┐
│  Presentation Layer                                │
│  • Inline Keyboard: 사용자 버튼 UI                 │
│  • CallbackQueryHandler: Callback 처리             │
│  • Admin API: 관리자용 조회/통계                   │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│  Business Layer                                    │
│  • FeedbackService: 피드백 비즈니스 로직           │
│  • FeedbackAwareRankingService: 재정렬            │
│  • PersonalizedRecommendationService: 개인화      │
│  • FeedbackEnhancedAiPromptService: 프롬프트 개선 │
│  • SearchQualityAnalyticsService: 품질 분석       │
│  • FeedbackAbTestService: A/B 테스트               │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│  Data Access Layer                                 │
│  • SearchFeedbackRepository: DB CRUD               │
│  • SearchFeedback Entity: 데이터 모델              │
│  • FeedbackRequest/Stats: 데이터 전송 객체         │
└─────────────────────────────────────────────────────┘
```

---

## 핵심 개념

### 1. 피드백 데이터 모델

**수집할 정보:**
- **누가**: Chat ID (사용자 식별)
- **무엇을**: 검색어, 도서 ID
- **어떻게**: 피드백 타입 (긍정/부정)
- **언제**: 타임스탬프

**피드백 타입:**
```
👍 좋았음 (GOOD)   → 검색 결과가 마음에 들음  (+1점)
👎 별로였음 (BAD)  → 검색 결과가 별로였음    (-1점)
```

**설계 이유:**
- 단순명료: 사용자가 고민할 필요 없이 바로 클릭
- 명확한 점수화: 긍정 +1, 부정 -1로 계산 단순
- 실무 표준: Reddit, Hacker News 등 많은 서비스가 이 방식 사용

### 2. Inline Keyboard

**Inline Keyboard란 무엇인가요?**

Telegram의 **버튼 형태 UI**로, 사용자가 클릭하면 Bot에 Callback(콜백) 신호가 전달됩니다.

웹사이트의 버튼을 생각하면 쉽습니다:
- 웹사이트: `<button onclick="handleClick()">클릭</button>`
- Telegram: `InlineKeyboardButton(callbackData="feedback:123")`

**왜 Inline Keyboard를 사용하나요?**

1. **사용자 친화적**: 텍스트를 직접 입력할 필요 없이 버튼 클릭만으로 동작
2. **입력 오류 방지**: "/search 해리포터" 같은 명령어를 틀리지 않고 버튼으로 정확하게 전달
3. **실시간 피드백**: 클릭 즉시 Bot이 응답하고 메시지를 수정 가능

---

**Markdown 링크 vs Inline Keyboard 비교**

현재 Bot에서 이미 사용 중인 Markdown 링크와 비교해보겠습니다:

| 구분 | Markdown 링크 | Inline Keyboard |
|------|---------------|-----------------|
| **용도** | 웹사이트로 이동 | Bot에 신호 전달 |
| **예시** | `🔗 상세 보기: [링크](https://...)` | `[👍 도움이 됨] 버튼` |
| **동작** | 외부 브라우저 열림 | Bot 내에서 처리 |
| **Bot 수신** | 수신 불가 (사용자가 브라우저로 이동) | `hasCallbackQuery()`로 감지 |
| **사용 사례** | 도서 상세 페이지 보기 | 피드백 전송, 명령 실행 |

**실제 코드 예시:**

```java
// 1. Markdown 링크 (현재 사용 중)
String message = "🔗 상세 보기: https://library.java21.net/books/123";
SendMessage(msg).text(message).build();
// → 사용자가 클릭하면 웹브라우저가 열림

// 2. Inline Keyboard (이번에 추가)
InlineKeyboardButton button = InlineKeyboardButton.builder()
    .text("👍 도움이 됨")
    .callbackData("feedback:해리포터:123:HELPFUL")
    .build();
// → 사용자가 클릭하면 Bot이 callbackData를 수신
```

---

**Inline Keyboard 작동 방식**

```
┌─────────────────────────────────────────────┐
│         사용자 화면 (Telegram App)          │
│                                             │
│  Bot: 검색 결과가 도움이 되셨나요?           │
│                                             │
│  [👍 도움이 됨] [👎 도움이 안됨]  ← 버튼    │
│  [✅ 관련 있음] [❌ 관련 없음]  ← Inline     │
│           Keyboard                          │
└─────────────────┬───────────────────────────┘
                  │
                  │ 사용자가 버튼 클릭
                  ▼
┌─────────────────────────────────────────────┐
│           Telegram 서버                      │
│  callbackData: "feedback:해리포터:123:HELPUL" │
└─────────────────┬───────────────────────────┘
                  │
                  │ Callback Query 전송
                  ▼
┌─────────────────────────────────────────────┐
│           LibraryTelegramBot                │
│  onUpdateReceived(Update) 호출              │
│  update.hasCallbackQuery() == true          │
└─────────────────┬───────────────────────────┘
                  │
                  │ CallbackQueryHandler 처리
                  ▼
┌─────────────────────────────────────────────┐
│         데이터 파싱 및 저장                  │
│  query = "해리포터"                         │
│  bookId = 123                               │
│  type = HELPFUL                             │
│  → DB 저장                                  │
└─────────────────────────────────────────────┘
```

---

**일반 메시지와의 차이**

| 구분 | 일반 메시지 | Inline Keyboard |
|------|-------------|-----------------|
| **사용자 입력** | 텍스트 직접 입력 | 버튼 클릭 |
| **Bot 수신 메서드** | `hasMessage()` | `hasCallbackQuery()` |
| **응답 방식** | `SendMessage` (새 메시지) | `EditMessageText` (기존 메시지 수정) |
| **예시** | User: "해리포터" 입력 | User: [👍 좋았음] 클릭 |

---

**참고 자료**

Telegram Bot 공식 문서:
- [Inline Keyboards](https://core.telegram.org/bots/features#inline-keyboards)
- [InlineKeyboardMarkup](https://core.telegram.org/bots/api#inlinekeyboardmarkup)
- [Callback Query](https://core.telegram.org/bots/api#callbackquery)

Java 라이브러리 (telegram-bot):
- [TelegramBots GitHub](https://github.com/rubenlagus/TelegramBots)

### 3. Callback 데이터 설계

버튼 식별을 위한 데이터 포맷:

**포맷:**
```
feedback:{query}:{bookId}:{type}

예: feedback:해리포터:123:GOOD
```

**고려사항:**
- 특수문자 처리 (`:` → URL 인코딩 필요)
- 파싱 용이성
- 확장성 (다른 타입의 Callback 추가 가능)

---

### 4. 피드백 UI 설계

**중요한 설계 결정: 개별 도서별 피드백**

각 검색 결과 도서마다 별도의 피드백 버튼을 제공합니다:

```
Bot: 📚 "해리포터" 검색 결과 (5권)

     1. 해리포터와 마법사의 돌
        [👍 좋았음] [👎 별로였음]

     2. 해리포터와 비밀의 방
        [👍 좋았음] [👎 별로였음]
```

**왜 개별 도서별인가?**
1. **더 정밀한 피드백**: "첫 번째 책은 좋았는데, 두 번째 책은 별로였어"
2. **AI 개선에 활용**: 피드백이 많은 도서를 상위 표시 (Learning to Rank)
3. **개인화 가능**: 사용자가 "판타지" 좋아하는 패턴 학습

**데이터 저장 예시:**
```
도서 1에 👍 클릭 → bookId = 1, type = GOOD
도서 2에 👎 클릭 → bookId = 2, type = BAD
```

---

## 데이터베이스 설계

### ERD

```
┌─────────────────────────────────────────────┐
│             search_feedbacks                │
├─────────────────────────────────────────────┤
│  id           (PK)          BIGINT          │
│  chat_id      (NOT NULL)   BIGINT           │
│  query        (NOT NULL)   VARCHAR(500)     │
│  book_id                    BIGINT          │
│  type         (NOT NULL)   VARCHAR(20)      │
│  created_at   (NOT NULL)   TIMESTAMP        │
├─────────────────────────────────────────────┤
│  INDEX: idx_chat_id                         │
│  INDEX: idx_created_at                      │
└─────────────────────────────────────────────┘
```

### 필드 상세 설명

| 컬럼명 | 타입 | NULL | 설명 | 예시 |
|--------|------|------|------|------|
| **id** | BIGINT | NOT NULL | 기본키 (PK) | 1, 2, 3, ... |
| **chat_id** | BIGINT | NOT NULL | Telegram 사용자 식별자 | 123456789, 987654321 |
| **query** | VARCHAR(500) | NOT NULL | 사용자 검색어 | "해리포터", "주식 투자" |
| **book_id** | BIGINT | NULL | 피드백 대상 도서 ID | 101, 205, NULL (전체 피드백) |
| **type** | VARCHAR(20) | NOT NULL | 피드백 유형 | GOOD, BAD |
| **created_at** | TIMESTAMP | NOT NULL | 피드백 생성 시간 | 2025-01-15 14:30:25 |

**필드별 상세 설명:**

| 필드 | 의미 | 사용 예시 |
|------|------|----------|
| **id** | 피드백 고유 번호 (자동 증가) | DB가 자동 부여 |
| **chat_id** | Telegram 사용자 고유 ID. 같은 사용자인지 식별 | 123456789 = 철수, 987654321 = 영희 |
| **query** | 사용자가 입력한 검색어. URL 인코딩된 상태로 저장 | "해리포터", "Java%20%EB%B0%B1%EC%97%94%EB%93%9C" |
| **book_id** | 피드백을 준 도서 ID. 특정 도서를 지정 | 101 = "해리포터와 마법사의 돌" |
| **type** | 피드백 종류. 긍정/부정 유형 | GOOD = 좋았음(+1점), BAD = 별로였음(-1점) |
| **created_at** | 피드백이 저장된 시간. 자동 생성 | "2025-01-15 14:30:25" |

---

### SQL DDL

**MySQL/MariaDB:**
```sql
CREATE TABLE search_feedbacks (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    chat_id BIGINT NOT NULL,
    query VARCHAR(500) NOT NULL,
    book_id BIGINT,
    type VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_chat_id (chat_id),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**H2 (개발용):**
```sql
CREATE TABLE search_feedbacks (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    chat_id BIGINT NOT NULL,
    query VARCHAR(500) NOT NULL,
    book_id BIGINT,
    type VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_chat_id (chat_id),
    INDEX idx_created_at (created_at)
);
```

**PostgreSQL:**
```sql
CREATE TABLE search_feedbacks (
    id BIGSERIAL PRIMARY KEY,
    chat_id BIGINT NOT NULL,
    query VARCHAR(500) NOT NULL,
    book_id BIGINT,
    type VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_chat_id (chat_id),
    INDEX idx_created_at (created_at)
);
```

---

### 예시 데이터

**실제 저장되는 데이터 예시:**

```
┌────┬───────────┬──────────────┬─────────┬───────────────┬─────────────────────┐
│ id │  chat_id  │    query     │ book_id │     type      │     created_at      │
├────┼───────────┼──────────────┼─────────┼───────────────┼─────────────────────┤
│  1 │ 123456789 │ 해리포터     │     101 │ GOOD          │ 2025-01-15 14:30:25 │
│  2 │ 123456789 │ 해리포터     │     102 │ BAD           │ 2025-01-15 14:31:10 │
│  3 │ 987654321 │ 주식 투자    │     205 │ GOOD          │ 2025-01-15 15:20:05 │
│  4 │ 123456789 │ Java 백엔드  │     310 │ GOOD          │ 2025-01-15 16:45:30 │
│  5 │ 987654321 │ 주식 투자    │     205 │ BAD           │ 2025-01-15 17:10:15 │
└────┴───────────┴──────────────┴─────────┴───────────────┴─────────────────────┘
```

**데이터 분석 예시:**

| 질문 | SQL 예시 | 결과 |
|------|----------|------|
| "해리포터" 검색에 대한 긍정 피드백 수? | `SELECT COUNT(*) FROM search_feedbacks WHERE query='해리포터' AND type='GOOD'` | 1건 |
| 도서 ID 101에 대한 피드백 점수? | `(긍정 1건 - 부정 0건) / 1건 = 1.0 (100% 긍정)` | +0.5 보너스 |
| 철수(chatId=123456789)가 좋아한 도서? | `SELECT book_id FROM search_feedbacks WHERE chat_id=123456789 AND type='GOOD'` | 101, 310 |
| 최근 7일간 긍정 피드백 비율? | `긍정 3건 / 전체 5건 = 60%` | 60% |

**실제 사용 시나리오:**

```
시나리오: 철수가 "해리포터"를 검색하고 피드백을 남김

1. 검색: User(chatId=123456789) → "해리포터" 검색
2. 결과: 3권의 도서 표시 (ID: 101, 102, 103)
3. 피드백:
   - 도서 101: [👍 좋았음] 클릭
   - 도서 102: [👎 별로였음] 클릭
4. DB 저장:
   INSERT INTO search_feedbacks (chat_id, query, book_id, type, created_at)
   VALUES (123456789, '해리포터', 101, 'GOOD', '2025-01-15 14:30:25');

   INSERT INTO search_feedbacks (chat_id, query, book_id, type, created_at)
   VALUES (123456789, '해리포터', 102, 'BAD', '2025-01-15 14:31:10');
5. AI 활용:
   - 도서 101: 긍정 피드백 → 다음 검색 시 상위 표시
   - 도서 102: 부정 피드백 → 다음 검색 시 하위 표시
```

---

### JPA Entity 설계 포인트

**필요한 어노테이션:**
- `@Entity` - JPA Entity임을 명시
- `@Table` - 테이블명과 인덱스 설정
- `@Id` + `@GeneratedValue` - 기본키 설정
- `@Enumerated(EnumType.STRING)` - Enum을 문자열로 저장
- `@PrePersist` - 저장 전 자동으로 created_at 설정

**구현 가이드:**
- 인덱스: chat_id, created_at (조회 성능)
- Enum: String 타입으로 저장 (가독성)
- @PrePersist: 생성 시간 자동 설정

---

## 구현 가이드

### Phase 1: Entity와 Repository

**목표:** 피드백 데이터를 저장할 데이터베이스 구조 만들기

**구현해야 할 것:**

**1. `FeedbackType` Enum**
- GOOD(1, "좋았음"), BAD(-1, "별로였음") 정의
- `getScoreValue()` 메서드로 점수 반환 (+1, -1)

**2. `SearchFeedback` Entity**
- 필드: id, chatId, query, bookId, type(FeedbackType), createdAt
- 어노테이션: @Entity, @Table(name="search_feedbacks"), @Index
- @PrePersist: createdAt 자동 설정

**3. `SearchFeedbackRepository` 인터페이스**
- Spring Data JPA 상속
- 쿼리 메서드:
  - `findByChatIdOrderByCreatedAtDesc(Long chatId)` - 특정 사용자 피드백
  - `findByBookId(Long bookId)` - 특정 도서의 모든 피드백
  - `findByQuery(String query)` - 특정 검색어 피드백

**처리 흐름:**
```
피드백 생성 → Entity 매핑 → Repository → DB 저장
```

**학습 포인트:**
- JPA 어노테이션 (@Entity, @Table, @Index, @Enumerated)
- Enum을 String으로 저장하는 이유 (가독성)
- @PrePersist로 생성 시간 자동 설정
- Spring Data JPA 메서드 네이밍 규칙

---

### Phase 2: DTO와 Service

**목표:** 비즈니스 로직과 데이터 전송 객체 만들기

**구현해야 할 것:**

**1. `FeedbackRequest` DTO (record)**
- 필드: query(@NotBlank), bookId(@NotNull), type(@NotNull)
- 역할: 피드백 요청 데이터 전달, 유효성 검사

**2. `FeedbackStats` DTO (record)**
- 필드: goodCount, badCount, totalCount, goodRatio, feedbackScore
- 메서드: `from(List<SearchFeedback>)` - Stream API로 통계 계산
- 점수 계산: (긍정 - 부정) / 전체
- 예: GOOD 15건, BAD 2건 → (15-2)/17 = 0.76

**3. `FeedbackService` 인터페이스**
- `recordFeedback(FeedbackRequest)` - 피드백 저장
- `getUserFeedback(Long chatId)` - 사용자별 피드백 목록
- `getBookFeedbackStats(Long bookId)` - 도서별 통계
- `getQueryFeedbackStats(String query)` - 검색어별 통계
- `getRecentFeedback(int days)` - 최근 N일 피드백

**4. `FeedbackServiceImpl` 구현**
- @Transactional 트랜잭션 처리
- Repository 호출하여 DB 저장
- Stream API로 통계 계산

**처리 흐름:**
```
Request DTO → Service → Repository → DB
              ↓
         Stats 계산 → Stats DTO 반환
```

**학습 포인트:**
- record 활용 (불변 객체)
- Validation 어노테이션 (@NotNull, @NotBlank)
- @Transactional (readOnly 최적화)
- Stream API로 데이터 집계

---

### Phase 3: Inline Keyboard Factory

**목표:** 버튼 UI 생성 로직 만들기

**구현해야 할 것:**

**`TelegramKeyboardFactory` 클래스**
- `createFeedbackKeyboard(String query, Long bookId)` 메서드
  - 검색어 URL 인코딩 (공백, 한글 처리)
  - InlineKeyboardButton 2개 생성 (좋았음, 별로였음)
  - InlineKeyboardMarkup.builder()로 Keyboard 조립
  - callbackData 포맷: `feedback:{query}:{bookId}:{type}`
  - 예: `feedback:해리포터:123:GOOD`

**UI 레이아웃:**
```
┌─────────────────────────────────┐
│  [👍 좋았음] [👎 별로였음]       │
└─────────────────────────────────┘
```

**처리 흐름:**
```
검색어 입력 → URL 인코딩 → Keyboard 생성 → 버튼에 Callback 데이터 연결
```

**학습 포인트:**
- Builder 패턴으로 Keyboard 생성
- URL 인코딩으로 특수문자 처리
- Callback 데이터 포맷 설계 (콜론(:)으로 구분)

---

### Phase 4: Callback Handler

**목표:** 버튼 클릭 처리 로직 만들기

**구현해야 할 것:**

**`CallbackQueryHandler` 클래스**
- `handleCallback(Update update)` 메서드
  1. Callback 유형 확인 (hasCallbackQuery)
  2. Callback 데이터 파싱 (split(":"))
     - `feedback:해리포터:123:GOOD` → ["feedback", "해리포터", "123", "GOOD"]
  3. URL 디코딩으로 검색어 복원
  4. FeedbackRequest 생성
  5. FeedbackService로 저장
  6. EditMessageText로 메시지 수정 (감사 메시지)
  7. AnswerCallbackQuery로 Telegram에 응답
  8. 예외 처리 (IllegalArgumentException, 일반 Exception)

**처리 흐름:**
```
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│ 사용자 클릭 │ →  │ Callback 수신 │ →  │  데이터 파싱  │ →  │  DB 저장    │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
                                                                ↓
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│  완료 응답   │ ←  │ 메시지 수정   │ ←  │ 감사 메시지  │ ←  │ Telegram API │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
```

**학습 포인트:**
- URL 디코딩으로 특수문자 복원
- Enum 변환 시 IllegalArgumentException 처리
- EditMessageText로 기존 메시지 수정
- AnswerCallbackQuery로 Telegram에 응답 전송

            // 3. 피드백 저장
            FeedbackRequest request = new FeedbackRequest(query, bookId, type);
            feedbackService.recordFeedback(request);

            // 4. 메시지 수정 (감사 메시지)
            EditMessageText editMessage = EditMessageText.builder()
                .chatId(chatId)
                .messageId(callbackQuery.getMessage().getMessageId())
                .text("✅ 소중한 피드백 감사합니다!\n검색 품질 개선에 활용하겠습니다.")
                .build();

            // execute(editMessage);

            // 5. Callback 응답 (Telegram에 전송 완료 알림)
            AnswerCallbackQuery answer = AnswerCallbackQuery.builder()
                .callbackQueryId(callbackQuery.getId())
                .text("피드백이 저장되었습니다.")
                .build();
            // execute(answer);

        } catch (IllegalArgumentException e) {
            log.error("Invalid callback data: {}", callbackData, e);
            sendErrorMessage(chatId, "피드백 처리 중 오류가 발생했습니다.");
        } catch (Exception e) {
            log.error("Failed to process callback: {}", callbackData, e);
            sendErrorMessage(chatId, "피드백 처리 중 오류가 발생했습니다.");
        }
    }

    private void sendErrorMessage(Long chatId, String text) {
        // 에러 메시지 전송 로직
    }
}
```
**역할:** 버튼 클릭 시 Callback 처리

**처리 흐름:**
```
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│ 사용자 클릭 │ →  │ Callback 수신 │ →  │  데이터 파싱  │ →  │  DB 저장    │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
                                                                ↓
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│  완료 응답   │ ←  │ 메시지 수정   │ ←  │ 감사 메시지  │ ←  │ Telegram API │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
```

**학습 포인트:**
- URL 디코딩으로 특수문자 복원
- Enum 변환 시 IllegalArgumentException 처리
- EditMessageText로 기존 메시지 수정
- AnswerCallbackQuery로 Telegram에 응답 전송

---

### Phase 5: Bot 연동

**목표:** 기존 Bot에 피드백 기능 통합

**수정해야 할 것:**

**1. `LibraryTelegramBot`에 의존성 추가**
- CallbackQueryHandler 주입
- TelegramKeyboardFactory 주입

**2. `onUpdateReceived` 메서드 수정**
- Callback Query 처리를 최우선으로 분기
- 일반 메시지는 기존 로직대로 처리
- 우선순위: Callback → 일반 메시지

**3. 검색 결과 전송 메서드 수정**
- 도서 정보 전송 시 Keyboard 생성
- SendMessage.builder()에 .replyMarkup(keyboard) 추가
- 각 도서마다 개별 Keyboard 부착

**처리 흐름:**
```
Update 수신 → Callback 확인? → YES: CallbackHandler 처리
                          → NO: 기존 메시지 처리
검색 결과 전송 → Keyboard 생성 → replyMarkup 설정 → 전송
```

**학습 포인트:**
- 기존 코드에 새 기능 통합 방법
- 우선순위 기반 분기 처리
- replyMarkup으로 Keyboard 메시지에 부착

---

### Phase 6: Admin API

**목표:** 관리자용 조회/통계 API 만들기

**구현해야 할 것:**

**`FeedbackAdminController` 클래스 (@RestController)**
- `GET /api/admin/feedback/stats?query=해리포터`
  - 특정 검색어의 피드백 통계 조회
  - @RequestParam으로 query 수신

- `GET /api/admin/feedback/recent?days=7`
  - 최근 N일간 피드백 목록 조회
  - @RequestParam(defaultValue="7")로 days 수신

- `GET /api/admin/feedback/user/{chatId}`
  - 특정 사용자의 피드백 목록 조회
  - @PathVariable으로 chatId 수신

- `GET /api/admin/feedback/book/{bookId}`
  - 특정 도서의 피드백 통계 조회
  - @PathVariable으로 bookId 수신

**API 응답 예시:**
```json
GET /api/admin/feedback/stats?query=해리포터

{
  "goodCount": 15,
  "badCount": 2,
  "totalCount": 17,
  "goodRatio": 0.882,
  "feedbackScore": 0.764
}
```

**처리 흐름:**
```
HTTP 요청 → Controller → Service → Repository → DB
                 ↓
           ResponseEntity ← Stats DTO ← 변환
```

**학습 포인트:**
- @GetMapping, @RequestParam, @PathVariable 활용
- ResponseEntity로 JSON 응답
- REST API 설계 원칙

**목표:** 관리자용 조회/통계 API 만들기

**구현해야 할 것:**

**`FeedbackAdminController` 클래스**
```java
@RestController
@RequestMapping("/api/admin/feedback")
@RequiredArgsConstructor
public class FeedbackAdminController {

    private final FeedbackService feedbackService;

    /**
     * 특정 검색어의 피드백 통계 조회
     * GET /api/admin/feedback/stats?query=해리포터
     */
    @GetMapping("/stats")
    public ResponseEntity<FeedbackStats> getQueryStats(@RequestParam String query) {
        FeedbackStats stats = feedbackService.getQueryFeedbackStats(query);
        return ResponseEntity.ok(stats);
    }

    /**
     * 최근 N일간 피드백 목록 조회
     * GET /api/admin/feedback/recent?days=7
     */
    @GetMapping("/recent")
    public ResponseEntity<List<SearchFeedback>> getRecentFeedback(
            @RequestParam(defaultValue = "7") int days) {
        List<SearchFeedback> feedbacks = feedbackService.getRecentFeedback(days);
        return ResponseEntity.ok(feedbacks);
    }

    /**
     * 특정 사용자의 피드백 목록 조회
     * GET /api/admin/feedback/user/{chatId}
     */
    @GetMapping("/user/{chatId}")
    public ResponseEntity<List<SearchFeedback>> getUserFeedback(
            @PathVariable Long chatId) {
        List<SearchFeedback> feedbacks = feedbackService.getUserFeedback(chatId);
        return ResponseEntity.ok(feedbacks);
    }

    /**
     * 특정 도서의 피드백 통계 조회
     * GET /api/admin/feedback/book/{bookId}
     */
    @GetMapping("/book/{bookId}")
    public ResponseEntity<FeedbackStats> getBookStats(@PathVariable Long bookId) {
        FeedbackStats stats = feedbackService.getBookFeedbackStats(bookId);
        return ResponseEntity.ok(stats);
    }
}
```
**역할:** 관리자용 피드백 조회/통계 API 제공

**API 사용 예시:**
```bash
# 통계 조회
curl "http://localhost:8080/api/admin/feedback/stats?query=해리포터"

# 최근 7일 피드백
curl "http://localhost:8080/api/admin/feedback/recent?days=7"

# 사용자 피드백
curl "http://localhost:8080/api/admin/feedback/user/123456789"
```

**학습 포인트:**
- @GetMapping, @RequestParam, @PathVariable
- ResponseEntity로 응답
- REST API 설계

---

## 피드백 활용: AI 개선 연계

수집된 피드백을 실제 AI 개선에 활용하는 방법입니다.

> **⚠️ 중요**: 피드백 데이터를 검색에 반영하는 방식(집계 기준, 가중치, 적용 시점 등)은 **프로젝트 요구사항, 데이터 수집 상황, 실험 결과에 따라 적절히 변경**할 수 있습니다. 본 문서에 제시된 전략은 참고용 가이드라인으로, 실제 구현에서는 A/B 테스트를 통해 최적의 방식을 찾아보시기를 권장합니다.

**고려해볼 수 있는 변형 전략:**
- **집계 기준**: 검색어별(query), 도서별(book_id), 사용자별(chatId) 또는 이들의 조합
- **가중치 방식**: 선형 가중치, 지수 가중치, 계단 함수 등
- **적용 시점**: RRF 계산 직후, 최종 정렬 전, LLM 프롬프트에만 반영 등
- **최소 데이터门槛**: 3건, 5건, 10건 등 (통계적 유의성에 따라 조정)
- **시간 감쇠**: 최근 피드백 가중치 부여, 전체 기간 평균 등

**데이터 분석 기반 의사결정:**
- 충분한 피드백이 쌓인 후 집계 방식 변경
- A/B 테스트로 효과 측정 후 가중치 조정
- 검색어별 피드백 패턴 분석으로 전략 수정

---

**핵심 원칙:** 피드백은 도서 ID 기준으로 집계합니다. 같은 도서에 대한 피드백은 검색어가 달라도 모두 통합하여 반영합니다.

**왜 book_id인가?**

1. **실용성**: 사용자가 "좋아요" 누른 건 검색어가 아니라 **도서**임
2. **단순함**: query 벡터 저장 없이 바로 집계 가능
3. **정확성**: 같은 도서는 어떤 검색어로 찾든 동일한 품질을 가짐

**실제 예시:**
```
도서 101이 총 100번 검색됨

- "해리포터" 검색 → GOOD 80건, BAD 5건
- "마법사 돌" 검색 → GOOD 10건, BAD 2건
- "Harry Potter" 검색 → GOOD 2건, BAD 1건

집계 결과:
- 총 GOOD: 92건, BAD: 8건
- 피드백 점수: (92 - 8) / 100 = 0.84
- 보너스 점수: 0.84 × 0.5 = +0.42점
```

**query는 언제 사용하나요?**
- 검색어별 품질 분석 (관리자 대시보드)
- "어떤 검색어가 결과가 좋은지/안좋은지" 확인용
- DB에서 `GROUP BY query`로 분석

**구현 방법:**
```java
// 특정 도서의 모든 피드백을 통합 (query 무시)
FeedbackStats stats = feedbackService.getBookFeedbackStats(bookId);
double bonusScore = stats.feedbackScore() * 0.5;  // 최대 ±0.5
```

---

## 피드백 반영 기준

### 현재 시스템 구조

```
┌─────────────────────────────────────────────────────┐
│          검색 요청 (query: "해리포터")           │
└────────────────────┬────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────┐
│     1단계: 하이브리드 검색                         │
│  • Vector 유사도 검색 (80%)                       │
│  • Keyword 검색 (20%)                            │
│  • RRF(Reciprocal Rank Fusion)로 점수 결합      │
│  결과: [A: 75점, B: 70점, C: 65점, D: 60점]      │
└────────────────────┬────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────┐
│     2단계: LLM 검증 (RAG)                           │
│  • 상위 N권 도서에 대해 AI 추천 사유 생성        │
│  • 사용자에게 도서 추천                            │
└─────────────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────┐
│     3단계: 피드백 반영 (추가)                    │
│  • 수집된 피드백 점수를 계산                     │
│  • 검색 결과에 반영                                 │
└─────────────────────────────────────────────────────�
```

---

### 피드백 반영 시점과 방법

**시점 1: 검색 재정렬 (Reranking)**

**언제?** 하이브리드 검색 결과가 나온 직후
**방법:** 피드백 점수를 원래 점수에 합산

```
[원래 점수]    [피드백 보너스]    [최종 점수]
A: 75점   +   A: +0.3점      =   A: 78.2점
B: 70점   +   B: +0.0점      =   B: 70.0점
C: 65점   +   C: -0.2점      =   C: 64.8점
D: 60점   +   D: -0.5점      =   D: 59.5점

→ 재정렬: [A, B, C, D]
```

**구현:**
```java
// 피드백 점수 계산
feedbackScore = (긍정 피드백 수 - 부정 피드백 수) / 총 피드백 수
// 예: 15건 긍정, 2건 부정 → (15 - 2) / 17 = 0.76

// 보너스 점수 (최대 ±0.5점)
bonusScore = feedbackScore * 0.5

// 최종 점수
finalScore = originalScore + bonusScore
```

---

**시점 2: LLM 프롬프트에 피드백 정보 포함**

**언제?** LLM에 추천 요청할 때
**방법:** 프롬프트에 피드백 통계 추가

```
프롬프트 예시:
"""
사용자가 "해리포터" 검색했습니다.

검색 결과 도서:
1. 해리포터와 마법사의 돌 (긍정 피드백: 88%)
2. 해리포터와 비밀의 방 (긍정 피드백: 45%)
3. ...

**중요**: 사용자들이 긍정적으로 평가한 도서를 우선적으로 추천해주세요.
"""
```

---

### 피드백 점수 계산 기준

#### 1. 개별 도서 피드백 점수

```
피드백 점수 = (긍정 피드백 수 - 부정 피드백 수) / 총 피드백 수

예시:
도서 1: 👍 15건, 👎 2건 → (15 - 2) / 17 = +0.76
도서 2: 👍 5건,  👎 5건 → (5 - 5) / 10 =   0.00
도서 3: 👍 2건, 👎 8건 → (2 - 8) / 10 = -0.60
```

#### 2. 보너스 점수 범위

| 피드백 점수 | 보너스 | 최종 점수 변화 |
|------------|-------|---------------|
| +1.0 (100% 긍정) | +0.5 | 75점 → 75.5점 |
| +0.5 (50% 긍정)  | +0.25 | 70점 → 70.25점 |
| 0.0 (긍정=부정) | 0 | 65점 → 65점 |
| -0.5 (50% 부정) | -0.25 | 60점 → 59.75점 |
| -1.0 (100% 부정) | -0.5 | 55점 → 54.5점 |

**이유:** 너무 큰 보너스는 원래 검색 결과를 무시할 수 있음

#### 3. 최소 피드백 수 기준

```
피드백이 5건 미만인 도서는 반영하지 않음
이유: 통계적으로 유의미한 데이터가 부족함
```

---

### 전체 흐름도

```
1. 사용자 검색
   ↓
2. 하이브리드 검색 (Vector + Keyword + RRF)
   결과: [A: 75점, B: 70점, C: 65점, D: 60점]
   ↓
3. 피드백 점수 계산 (각 도서별)
   - 도서 A: +0.3점 (피드백 88%)
   - 도서 B: +0.0점 (피드백 50%)
   - 도서 C: -0.2점 (피드백 20%)
   - 도서 D: -0.5점 (피드백 -20%)
   ↓
4. 최종 점수 합산
   결과: [A: 78.2점, B: 70.0점, C: 64.8점, D: 59.5점]
   ↓
5. 재정렬: [A, B, C, D]
   ↓
6. LLM 추천 (피드백 정보 포함)
```

---

### 학습 포인트

1. **피드백은 보조 수단**: 원래 검색 결과를 완전히 뒤집지 않음
2. **점수 범위 제한**: 너무 큰 영향을 주지 않도록 최대 ±0.5점
3. **최소 데이터 기준**: 5건 미만은 반영하지 않아 신뢙성 확보
4. **단계별 반영**: 1차 검색 → 피드백 보너스 → 최종 결과

---

### 활용 시나리오 개요

| 시나리오 | 설명 | 활용 분야 |
|----------|------|----------|
| **Learning to Rank** | 피드백 기반 검색 결과 재정렬 | 검색 엔진 |
| **개인화** | 사용자 선호도 학습 | 추천 시스템 |
| **프롬프트 개선** | 피드백 통계를 AI에 전달 | LLM 활용 |
| **품질 분석** | 검색 품질 보고서 생성 | 데이터 분석 |
| **A/B 테스트** | 개선 효과 측정 | 실험 설계 |

---

### 1. Learning to Rank

**개념:** 사용자가 "도움이 됨" 피드백을 많이 준 도서를 상위에 표시

**구현 흐름:**
```
1. 기존 검색: [A, B, C, D]
2. 피드백 점수 계산
   - A: 0.8 (긍정 80%)
   - B: 0.6
   - C: 0.4
   - D: 0.2
3. 재정렬: 피드백 점수 순으로 정렬
```

**핵심 메서드:**
- 피드백 점수 계산
- 재정렬

---

### 1-A. 검색어별 피드백 반영 (Query-Aware Feedback) ⭐ **추천**

**개념:** 동일한 검색어에 대한 과거 피드백을 해당 도서에 가중치로 부여

**핵심 아이디어:**
- "해리포터" 검색에 대한 긍정 피드백이 많은 도서 → 다음 "해리포터" 검색 시 상위 표시
- 검색어 컨텍스트를 반영한 가장 직관적인 피드백 활용 방식
- 사용자가 실제로 만족한 검색 결과를 학습

---

#### 전략 비교: 도서 기반 vs 검색어 기반

| 구분 | 도서(book_id) 기반 | 검색어(query) 기반 ⭐ |
|------|-------------------|---------------------|
| **집계 단위** | 도서별 전체 피드백 | (검색어, 도서)별 피드백 |
| **장점** | 데이터 수집 용이 | 검색 컨텍스트 반영 |
| **단점** | 검색어 무시 | 데이터가 쌓여야 효과 있음 |
| **적용 예시** | 인기 도서 우선 | "해리포터"에 좋은 평가 받은 책 |

---

#### 구현 방법

**1. 피드백 점수 계산 (검색어 + 도서 기반)**

```java
/**
 * 특정 검색어와 도서 조합에 대한 피드백 점수 계산
 *
 * @param query 검색어 (예: "해리포터")
 * @param bookId 도서 ID
 * @return 피드백 점수 (0.0 ~ 1.0)
 */
public float calculateQueryFeedbackScore(String query, Long bookId) {
    // 1. (query, bookId) 조합으로 피드백 조회
    List<SearchFeedback> feedbacks = repository
        .findByQueryAndBookId(query, bookId);

    if (feedbacks.isEmpty()) {
        return 0.0f;  // 피드백 없으면 0점
    }

    // 2. 최소 피드백 수 확인 (안정성 확보)
    if (feedbacks.size() < 3) {
        return 0.0f;  // 3건 미만은 반영하지 않음
    }

    // 3. 피드백 점수 계산
    long goodCount = feedbacks.stream()
        .filter(f -> f.getType() == FeedbackType.GOOD)
        .count();

    long badCount = feedbacks.stream()
        .filter(f -> f.getType() == FeedbackType.BAD)
        .count();

    // (긍정 - 부정) / 전체
    float feedbackScore = (goodCount - badCount) / (float) feedbacks.size();

    return Math.max(-1.0f, Math.min(1.0f, feedbackScore));  // -1.0 ~ 1.0 클램프
}
```

**2. RRF 점수에 피드백 가중치 반영**

```java
/**
 * 피드백 점수를 RRF 점수에 반영
 *
 * @param rrfScore 기존 RRF 점수
 * @param feedbackScore 피드백 점수
 * @return 최종 점수
 */
public float applyFeedbackToScore(float rrfScore, float feedbackScore) {
    // 가중치: 최대 +0.5점
    float BONUS_WEIGHT = 0.5f;

    // 최종 점수 = RRF + (피드백 점수 * 가중치)
    return rrfScore + (feedbackScore * BONUS_WEIGHT);
}
```

---

#### 실제 적용 시나리오

**시나리오: 사용자가 "해리포터" 검색**

```
[1단계] 기존 RRF 검색 결과
┌──────────┬───────────┬─────────┐
│ 도서     │ RRF 점수 │ 순위    │
├──────────┼───────────┼─────────┤
│ 도서 A   │ 0.85      │ 1위     │
│ 도서 B   │ 0.72      │ 2위     │
│ 도서 C   │ 0.68      │ 3위     │
│ 도서 D   │ 0.55      │ 4위     │
└──────────┴───────────┴─────────┘

[2단계] "해리포터" 검색에 대한 과거 피드백
┌──────────┬─────────┬─────────┬───────────────┐
│ 도서     │ 긍정    │ 부정    │ 피드백 점수  │
├──────────┼─────────┼─────────┼───────────────┤
│ 도서 A   │ 10건    │ 1건     │ +0.82         │
│ 도서 B   │ 2건     │ 0건     │ +1.00         │
│ 도서 C   │ 0건     │ 0건     │  0.00         │
│ 도서 D   │ -        │ -       │  0.00 (없음)  │
└──────────┴─────────┴─────────┴───────────────┘

[3단계] 피드백 반영 후 최종 점수
┌──────────┬───────────┬─────────────┬───────────┬─────────┐
│ 도서     │ RRF 점수  │ 피드백 보너스│ 최종 점수 │ 순위    │
├──────────┼───────────┼─────────────┼───────────┼─────────┤
│ 도서 A   │ 0.85      │ +0.41       │ 1.26 ⬆️   │ 1위     │
│ 도서 B   │ 0.72      │ +0.50       │ 1.22 ⬆️   │ 2위     │
│ 도서 C   │ 0.68      │ +0.00       │ 0.68      │ 3위     │
│ 도서 D   │ 0.55      │ +0.00       │ 0.55      │ 4위     │
└──────────┴───────────┴─────────────┴───────────┴─────────┘

변화: 도서 B가 2위 → 1위로 상승 가능 (피드백 점수가 높음)
```

---

#### Repository 메서드 추가

```java
/**
 * QueryDSL을 사용한 (query, bookId) 조합 조회
 */
public interface SearchFeedbackRepository extends JpaRepository<SearchFeedback, Long> {

    /**
     * 특정 검색어와 도서 조합의 피드백 목록 조회
     */
    @Query("SELECT sf FROM SearchFeedback sf WHERE sf.query = :query AND sf.bookId = :bookId")
    List<SearchFeedback> findByQueryAndBookId(@Param("query") String query, @Param("bookId") Long bookId);

    /**
     * 특정 검색어의 모든 피드백을 도서별 그룹화하여 통계 조회
     */
    @Query("""
        SELECT new com.nhnacademy.library.feedback.dto.QueryBookFeedbackStats(
            sf.bookId,
            COUNT(CASE WHEN sf.type = 'GOOD' THEN 1 END),
            COUNT(CASE WHEN sf.type = 'BAD' THEN 1 END),
            COUNT(*)
        )
        FROM SearchFeedback sf
        WHERE sf.query = :query
        GROUP BY sf.bookId
        HAVING COUNT(*) >= 3
        """)
    List<QueryBookFeedbackStats> getGroupedStatsByQuery(@Param("query") String query);
}
```

---

#### 장단점 분석

**장점:**
1. ✅ **검색 컨텍스트 반영**: "해리포터" 검색에 좋은 평가를 받은 책이 실제로 상위
2. ✅ **사용자 의도 반영**: 사용자가 만족한 검색 결과를 학습
3. ✅ **직관적임**: 왜 이 도서가 상위인지 이해하기 쉬움
4. ✅ **지속적 개선**: 검색할수록 품질 향상

**단점:**
1. ⚠️ **콜드 스타트**: 초기에는 피드백이 없어 효과 없음
2. ⚠️ **데이터 편향**: 특정 검색어에만 피드백이 집중될 수 있음
3. ⚠️ **계산 비용**: 검색마다 피드백 조회 필요

---

#### 최소 피드백 수 기준

```
피드백이 3건 미만인 (query, bookId) 조합은 반영하지 않음

이유:
- 통계적으로 유의미하지 않음 (표본 부족)
- 1~2건의 피드백은 우연일 수 있음
- 너무 낮은门槛(Threshold)는 노이즈 유발

3건 기준:
- 긍정 3건: +1.0 → 최대 +0.5 보너스
- 긍정 2건, 부정 1건: +0.33 → +0.17 보너스
- 긍정 1건, 부정 2건: -0.33 → -0.17 페널티
```

---

#### 구현 체크리스트

- [ ] `SearchFeedbackRepository`에 `findByQueryAndBookId()` 메서드 추가
- [ ] `FeedbackService`에 `calculateQueryFeedbackScore()` 메서드 구현
- [ ] RRF 계산 로직에 피드백 가중치 반영
- [ ] 최소 피드백 수 (3건) 기준 적용
- [ ] 피드백 없는 경우 안전하게 처리 (return 0.0f)
- [ ] 단위 테스트로 점수 계산 로직 검증

---

#### 추가 고려사항

**1. 시간 가중치 (선택적 확장)**
```java
// 최근 피드백일수록 더 높은 가중치
float timeWeightedScore = calculateTimeWeightedScore(feedbacks);
// 예: 7일 이내 피드백 1.5배, 30일 이내 1.2배, 그 외 1.0배
```

**2. 사용자별 피드백 (개인화)**
```java
// 특정 사용자가 좋아한 도서 스타일 학습
List<Book> userFavorites = getUserFavorites(chatId);
// 추천 시 해당 스타일 가중치 부여
```

**3. 도서 전체 인기도와 결합**
```java
// 검색어 피드백 + 도서 전체 인기도 하이브리드
float queryScore = getQueryFeedbackScore(query, bookId);  // +0.5
float globalScore = getGlobalPopularityScore(bookId);      // +0.3
float finalBonus = queryScore + globalScore;
```

---

### 2. 개인화

**개념:** 사용자가 좋아한 도서 패턴을 학습

**활용 예시:**
```
사용자 A: "해리포터" → 👍, "마법사" → 👍
          → 추천 시 "판타지", "마법" 키워드 강조

사용자 B: "주식" → 👍, "투자" → 👍
          → 추천 시 "경제", "재테크" 키워드 강조
```

**핵심 메서드:**
- 선호 도서 목록 조회
- 개인화된 프롬프트 생성

---

### 3. AI 프롬프트 개선

**개념:** 피드백 정보를 LLM에게 **참고 자료(Context)**로 제공하여 지능적인 추천 가능하게 함

**⚠️ 중요: LLM에게 단순히 "피드백이 높은 순서대로 추천해달라"고 하면 안 됩니다!**

```
❌ 나쁜 예시:
"피드백이 높은 도서를 무조건 상위에 배치하세요."
→ LLM이 relevance 판단을 포기하고 피드백 순서대로 반환
→ 신간 도서(피드백 없음)은 영원히 기회를 얻지 못함
→ 피드백 편향(Bias)이 강화되어 검색 품질 저하

✅ 좋은 예시:
"피드백 정보를 참고하여 추천하되, relevance(관련성)을 최우선으로 고려하세요."
→ LLM이 피드백을 하나의 참고 자료로 활용
→ 여전히 relevance를 기반으로 지능적으로 판단
→ 피드백이 없는 신간 도서도 기회를 얻을 수 있음
```

---

#### 올바른 프롬프트 전략

**핵심 원칙: Relevance 우선, 피드백은 보조 정보**

```java
String template = """
    [규칙 - 기본]
    - 사용자 query와 가장 관련 있는 도서를 선별하세요.
    - 각 도서에 relevance 점수(0~100)를 부여하세요.
    - **relevance를 점수의 최우선 기준으로 삼으세요.**
    - relevance가 50 미만인 도서는 출력에서 제외하세요.

    [규칙 - 피드백 정보 활용]
    - 피드백 정보는 **참고 자료**로 활용하세요.
    - 피드백이 있는 도서는 **검증된 도서**로 판단할 수 있습니다.
    - 하지만 피드백이 없다고 해서 relevance가 높은 도서를 배제하지 마세요.
    - 특히 신간 도서는 피드백이 없더라도 내용의 관련성을 중요하게 평가하세요.

    [피드백 정보 해석 가이드]
    - 긍정 피드백 80% 이상: "사용자들이 만족한 검증된 도서"
    - 긍정 피드백 50~79%: "대체로 긍정적인 평가"
    - 긍정 피드백 20~49%: "평가가 엇갈리는 도서"
    - 긍정 피드백 20% 미만: "부정적인 평가가 많음"

    [규칙 - 피드백 유의사항]
    - 피드백이 너무 적은 도서(3건 미만)는 "데이터 부족"으로 간주하세요.
    - 피드백 없는 도서는 "신간 또는 리뷰가 적은 도서"로 간주하세요.
    - 피드백 수가 적더라도 relevance가 높으면 추천하세요.

    [추천 사유 작성 가이드]
    - relevance가 높은 도서: "query와 직접적으로 관련 있음" 강조
    - 피드백이 좋은 도서: "사용자들이 만족한 도서" 추가 언급 가능
    - 피드백이 없는 신간: "최신 도서로 아직 피드백이 적지만 내용이 적합함" 언급

    [도서 데이터]
    %s

    query: %s
    """;
```

---

#### 실제 프롬프트 예시

```java
// 피드백 정보를 도서 데이터에 포함
StringBuilder context = new StringBuilder();
for (BookSearchResponse book : books) {
    // 기본 정보
    bookContext.append(String.format(
        "ID: %d, 제목: %s, 저자: %s, 출판일: %s, 내용: %s",
        book.getId(), book.getTitle(), book.getAuthorName(),
        book.getEditionPublishDate(), book.getBookContent()
    ));

    // 피드백 정보가 있으면 추가 (필수 아님)
    if (book.getFeedbackStats() != null && book.getFeedbackStats().getTotalCount() >= 3) {
        bookContext.append(String.format(
            ", 피드백: 긍정 %d건/부정 %d건 (긍정률 %.0f%%)",
            book.getFeedbackStats().getGoodCount(),
            book.getFeedbackStats().getBadCount(),
            book.getFeedbackStats().getGoodRatio() * 100
        ));
    }
    // 피드백이 없으면 추가하지 않음 (LLLM이 판단하도록 남김)
}
```

---

#### 프롬프트 작성 시 주의사항

| 항목 | ❌ 피해야 할 것 | ✅ 권장하는 것 |
|------|----------------|---------------|
| **목표 설정** | "피드백 순으로 추천" | "Relevance 우선, 피드백 참고" |
| **피드백 없는 도서** | "제외" 또는 "최하위 배치" | "내용 기반으로 평가, 신간 우려" |
| **피드백 해석** | "점수가 높으면 무조건 상위" | "검증된 도서로 신뢰도 가중" |
| **강조 정도** | "무조건", "반드시", "항상" | "참고", "고려", "가능하면" |

---

#### LLM의 역할과 한계 인식

**LLM이 잘하는 것:**
- ✅ Query와 도서 내용의 관련성(relevance) 판단
- ✅ 사용자의 의도를 이해하고 맞춤형 설명
- ✅ 피드백 정보를 문맥(context)으로 활용한 균형 잡힌 추천

**LLM이 잘 못하는 것 (단순 정렬):**
- ❌ 피드백 순서대로 나열 (이건 자바 코드로 하는 게 낫음)
- ❌ 피드백 수치만 보고 기계적인 판단
- ❌ 신간 도서 배제 (피드백이 없다는 이유로)

---

#### 구현 예시: 실제 코드 기반 전체 프롬프트

실제 프로젝트의 `AiRecommendationService` 코드를 분석한 전체 프롬프트 예시입니다.

---

##### 전체 프롬프트 템플릿

```java
String template = """
    [규칙]
    - 사용자가 제공하는 query와 가장 관련 있는 도서를 선별하세요.
    - 각 도서에 대해 relevance 점수(0~100)를 부여하세요:
      - 90–100: query와 직접적으로 강하게 연관, 주제 적합성이 매우 높음
      - 70–89: query와 밀접하게 관련 있지만 일부 범위가 제한적임
      - 50–69: query와 간접적으로 관련, 배경 지식에 도움이 됨
      - 50 미만: 관련성이 낮으므로 출력에서 제외
    - 추천 사유("why")에는 점수를 포함하지 말고, 순수하게 이유만 설명하세요.
    - 추천 사유("why")는 사용자에게 친절하고 공손한 어투(예: "~입니다", "~를 추천해 드립니다")로 작성하세요.
    - 추천 사유를 명확히 알 수 없는 경우에는 "추천 사유를 모름" 또는 "추천 사유를 명확히 알 수 없습니다"와 같이 명확하게 모른다는 표현을 사용하세요.
    - 최신 출간일과 query와의 직접적인 관련성을 함께 고려하세요.

    [규칙 - 리뷰 정보 반영]
    - 평점과 리뷰 수를 relevance 점수에 반영하세요:
      - 평점 4.5 이상 + 리뷰 20개 이상: relevance +5점 (검증된 인기 도서)
      - 평점 4.0 이상 + 리뷰 20개 이상: relevance +3점 (검증된 도서)
      - 평점 3.5 미만: relevance -10점 (부정적 평가)
      - 리뷰 없음: relevance ±0점 (변동 없음)

    - 평점이 4.0 이상인 도서를 우선적으로 고려하세요.
    - 리뷰가 20개 이상인 도서는 검증된 도서로 판단하고 신뢰도를 높게 평가하세요.
    - 리뷰 요약이 있는 경우, 요약의 내용을 참고하여 구체적인 추천 사유를 작성하세요.
      - 예: "리뷰어들이 '설명이 쉽고 실전 예제가 많다'고 평가했습니다."
    - 평점이 3.5 미만인 도서는 주의를 권장하세요.
      - 예: "평점이 3.2/5.0로 평가가 엇갈립니다. 리뷰 내용을 확인해보세요."
    - 리뷰가 없는 신간 도서는 "신간 도서로 아직 리뷰가 없습니다"라고 언급하고, 최신성과 내용의 관련성을 더 중요하게 평가하세요.

    [출력 형식]
    - 출력은 반드시 순수 JSON만 포함하세요.
    - 마크다운 코드 블록(```json ... ```)이나 추가 설명 텍스트는 절대 포함하지 마세요.
    - 언어는 반드시 한국어를 사용하세요.

    [JSON STRUCTURE]
     [
        {
          "id": 123,
          "relevance": 95,
          "why": "추천 사유"
        }
     ]

    - 결과는 relevance 기준 내림차순으로 정렬하세요.
    - 입력 데이터에 없는 필드는 추측하지 마세요.

    query: {question}

    도서 데이터:
    {context}
    """;
```

---

##### 실제 데이터 포맷팅 로직

```java
/**
 * 도서 정보를 LLM 프롬프트용으로 포맷팅
 */
private String buildBookContext(BookSearchResponse book) {
    StringBuilder bookContext = new StringBuilder();

    // 1. 기본 정보 (항상 포함)
    bookContext.append(String.format("ID: %d, 제목: %s, 저자: %s",
        book.getId(), book.getTitle(), book.getAuthorName()));

    // 2. 평점 정보 (조건부 포함)
    String ratingInfo = formatRatingInfo(book);
    if (!ratingInfo.isEmpty()) {
        bookContext.append(", ").append(ratingInfo);
    }
    // 리뷰 없으면 아무것도 추가하지 않음

    // 3. 리뷰 요약 (조건부 포함, 100자 제한)
    String summaryInfo = formatReviewSummary(book.getReviewSummary());
    if (!summaryInfo.isEmpty()) {
        bookContext.append(", ").append(summaryInfo);
    }
    // 요약 없으면 아무것도 추가하지 않음

    // 4. 출판일과 내용 (항상 포함)
    bookContext.append(String.format(", 출판일: %s, 내용: %s",
        book.getEditionPublishDate() != null ? book.getEditionPublishDate().toString() : "알 수 없음",
        book.getBookContent() != null ? book.getBookContent() : "내용 없음"));

    return bookContext.toString();
}

/**
 * 평점 정보 포맷팅
 * @return "평점: 4.8/5.0(127개 리뷰)" 또는 빈 문자열
 */
private String formatRatingInfo(BookSearchResponse book) {
    if (book.getAverageRating() != null
            && book.getReviewCount() != null
            && book.getReviewCount() > 0) {
        return String.format("평점: %.1f/5.0(%d개 리뷰)",
            book.getAverageRating(),
            book.getReviewCount());
    }
    return "";  // 리뷰 없으면 빈 문자열
}

/**
 * 리뷰 요약 포맷팅
 * @return "요약: '리뷰 내용...'" 또는 빈 문자열
 */
private String formatReviewSummary(String summary) {
    if (summary == null || summary.isBlank()) {
        return "";  // 요약 없으면 빈 문자열
    }

    // 100자 제한
    String truncated = summary.length() > 100
        ? summary.substring(0, 100) + "..."
        : summary;

    return String.format("요약: \"%s\"", truncated);
}
```

---

##### 실제 프롬프트 예시 (검색어: "해리포터")

```
[규칙]
- 사용자가 제공하는 query와 가장 관련 있는 도서를 선별하세요.
- 각 도서에 대해 relevance 점수(0~100)를 부여하세요:
  - 90–100: query와 직접적으로 강하게 연관, 주제 적합성이 매우 높음
  - 70–89: query와 밀접하게 관련 있지만 일부 범위가 제한적임
  - 50–69: query와 간접적으로 관련, 배경 지식에 도움이 됨
  - 50 미만: 관련성이 낮으므로 출력에서 제외
- 추천 사유("why")에는 점수를 포함하지 말고, 순수하게 이유만 설명하세요.
- 추천 사유("why")는 사용자에게 친절하고 공손한 어투(예: "~입니다", "~를 추천해 드립니다")로 작성하세요.
- 추천 사유를 명확히 알 수 없는 경우에는 "추천 사유를 모름" 또는 "추천 사유를 명확히 알 수 없습니다"와 같이 명확하게 모른다는 표현을 사용하세요.
- 최신 출간일과 query와의 직접적인 관련성을 함께 고려하세요.

[규칙 - 리뷰 정보 반영]
- 평점과 리뷰 수를 relevance 점수에 반영하세요:
  - 평점 4.5 이상 + 리뷰 20개 이상: relevance +5점 (검증된 인기 도서)
  - 평점 4.0 이상 + 리뷰 20개 이상: relevance +3점 (검증된 도서)
  - 평점 3.5 미만: relevance -10점 (부정적 평가)
  - 리뷰 없음: relevance ±0점 (변동 없음)

- 평점이 4.0 이상인 도서를 우선적으로 고려하세요.
- 리뷰가 20개 이상인 도서는 검증된 도서로 판단하고 신뢰도를 높게 평가하세요.
- 리뷰 요약이 있는 경우, 요약의 내용을 참고하여 구체적인 추천 사유를 작성하세요.
  - 예: "리뷰어들이 '설명이 쉽고 실전 예제가 많다'고 평가했습니다."
- 평점이 3.5 미만인 도서는 주의를 권장하세요.
  - 예: "평점이 3.2/5.0로 평가가 엇갈립니다. 리뷰 내용을 확인해보세요."
- 리뷰가 없는 신간 도서는 "신간 도서로 아직 리뷰가 없습니다"라고 언급하고, 최신성과 내용의 관련성을 더 중요하게 평가하세요.

[출력 형식]
- 출력은 반드시 순수 JSON만 포함하세요.
- 마크다운 코드 블록(```json ... ```)이나 추가 설명 텍스트는 절대 포함하지 마세요.
- 언어는 반드시 한국어를 사용하세요.

[JSON STRUCTURE]
 [
    {
      "id": 123,
      "relevance": 95,
      "why": "추천 사유"
    }
 ]

- 결과는 relevance 기준 내림차순으로 정렬하세요.
- 입력 데이터에 없는 필드는 추측하지 마세요.

query: 해리포터

도서 데이터:
ID: 101, 제목: 해리포터와 마법사의 돌, 저자: J.K. 롤링, 평점: 4.8/5.0(127개 리뷰), 요약: "초보자에게 정말 좋습니다. 설명이 쉽고...", 출판일: 2020-01-01, 내용: 해리포터의 첫 번째 이야기...
ID: 102, 제목: 해리포터와 비밀의 방, 저자: J.K. 롤링, 평점: 4.6/5.0(89개 리뷰), 요약: "전개가 좋고 미스터리가 심도 있습니다.", 출판일: 2020-05-01, 내용: 해리포터의 두 번째 이야기...
ID: 103, 제목: 해리포터와 아즈카반의 죄수, 저자: J.K. 롤링, 출판일: 2021-03-01, 내용: 해리포터의 세 번째 이야기...
ID: 104, 제목: 주식 투자를 위한 기초 분석, 저자: 김철수, 출판일: 2023-07-15, 내용: 주식의 기본 개념을 설명합니다...
ID: 105, 제목: 신간 SQL 완전 정복, 저자: 박민수, 출판일: 2024-10-10, 내용: 최신 SQL 기능을 다룹니다...
```

---

##### LLM이 수신하는 실제 데이터 분석

**리뷰 있는 도서 (ID: 101, 102)**
- 평점/리뷰 수/요약 정보가 모두 포함됨
- LLM이 구체적인 사용자 피드백을 참고 가능
- +5점 또는 +3점 보너스를 relevance 점수에 반영할 수 있음

**리뷰 없는 도서 (ID: 103)**
- 평점/요약 정보가 없음
- LLM이 내용 기반으로만 relevance 판단
- "신간 도서"로 간주되거나 무관하게 판단

**검색어와 무관한 도서 (ID: 104, 105)**
- "해리포터" 검색인데 주책 관련 도서도 포함됨 (하이브리드 검색 결과)
- LLM이 relevance를 낮게 판단하고 제외할 가능성 높음
- 피드백 정보가 있어도 relevance 50 미만이면 제외됨

---

##### 핵심 설계 포인트

1. **조건부 포함**: 리뷰 정보가 있을 때만 프롬프트에 추가
2. **데이터 누락 방지**: 리뷰가 없는 도서를 "불완전한 데이터"로 표시하지 않음
3. **토큰 최적화**: 요약을 100자로 제한하여 프롬프트 길이 관리
4. **명시적 점수 규칙**: "+5점", "+3점", "-10점"으로 LLM에 가이드라인 제공
5. **우선순위 명시**: "평점 4.0 이상인 도서를 우선적으로 고려"로 신뢰도 강조

---

**핵심 메서드:**
- 피드백 정보를 프롬프트에 자연스럽게 통합
- "무조건 우선" 지양, "참고 자료"로 활용
- 피드백 없는 도서의 기회 보장

---

### 4. 품질 분석

**개념:** 검색어별 품질 보고서 생성

**활용:**
- 어떤 검색어가 결과가 좋은지/안좋은지 분석
- 개선이 필요한 검색어 식별
- 시스템 품질 모니터링

**핵심 메서드:**
- 품질 보고서 생성
- 전체 긍정률, 검색어별 그룹화, 긍정률이 낮은 검색어 TOP 5

---

### 5. A/B 테스트

**개념:** 피드백 반영 전/후 효과 측정

**그룹 할당:**
```
사용자 A (chatId=123) → 해시값 → 짝수 → 피드백 반영 그룹
사용자 B (chatId=456) → 해시값 → 홀수 → 통제 그룹
```

**핵심 메서드:**
- 그룹 할당 (50:50)
- A/B 그룹별 긍정률 비교

---

## 피드백 루프 아키텍처

```
┌─────────────────────────────────────────────────────────┐
│                    사용자                                │
│  ┌──────────┐                                          │
│  │ 검색 요청 │                                          │
│  └─────┬────┘                                          │
│        │                                                │
│        ▼                                                │
│  ┌──────────────────────────────────────────────┐      │
│  │        검색 결과 + Inline Keyboard            │      │
│  │  [도서 목록]                                  │      │
│  │  [👍 도움이 됨] [👎 도움이 안됨]              │      │
│  └───────────────┬──────────────────────────────┘      │
│                  │                                      │
│                  ▼                                      │
│  ┌──────────────────────────────────────────────┐      │
│  │           버튼 클릭 (피드백)                  │      │
│  └───────────────┬──────────────────────────────┘      │
└──────────────────┼─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│              피드백 데이터 수집                          │
│  CallbackQueryHandler → FeedbackService → Repository    │
└──────────────────────────┬──────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                 피드백 분석                             │
│  • 긍정/부정 비율 계산  • 검색어별 품질 분석            │
│  • 사용자별 선호도 분석                                 │
└──────────────────────────┬──────────────────────────────┘
                           │
           ┌───────────────┼───────────────┐
           │               │               │
           ▼               ▼               ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  재정렬      │  │  개인화      │  │  프롬프트    │
│  (Ranking)   │  │  (Personal)  │  │  개선       │
│              │  │              │  │              │
│ [긍정 피드백 │  │ [사용자가    │  │ [통계를 LLM  │
│  많은 도서   │  │  좋아하는    │  │  에 전달]    │
│  상위 표시]  │  │  도서 추천]  │  │              │
└──────┬───────┘  └──────┬───────┘  └──────┬───────┘
       │                 │                 │
       └─────────────────┼─────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│               개선된 검색 결과                           │
│  • 더 관련성 높은 도서  • 개인화된 추천                 │
│  • 더 정확한 AI 추천 사유                               │
└──────────────────────────┬──────────────────────────────┘
                           │
                           ▼
                    ┌──────┴──────┐
                    │   사용자     │ (루프 계속)
                    └─────────────┘
```

---

## 구현 단계

### Phase 1: 데이터 계층 (1시간)

- [ ] SearchFeedback Entity 작성
- [ ] SearchFeedbackRepository 인터페이스 정의
- [ ] DDL로 테이블 생성 확인

**학습 포인트:**
- JPA 어노테이션 (@Entity, @Table, @Index)
- Enum 처리 (@Enumerated)
- 생명주기 콜백 (@PrePersist)

---

### Phase 2: 비즈니스 계층 (1시간)

- [ ] FeedbackRequest, FeedbackStats DTO 작성
- [ ] FeedbackService 인터페이스 설계
- [ ] FeedbackServiceImpl 구현

**학습 포인트:**
- record 활용
- Validation 어노테이션
- @Transactional 트랜잭션 관리

---

### Phase 3: UI 계층 (1.5시간)

- [ ] TelegramKeyboardFactory 작성
- [ ] CallbackQueryHandler 작성
- [ ] LibraryTelegramBot 수정

**학습 포인트:**
- Inline Keyboard 구조
- Callback 데이터 파싱
- EditMessageText 활용

---

### Phase 4: 관리자 API (30분)

- [ ] FeedbackAdminController 작성
- [ ] API 테스트

**학습 포인트:**
- REST API 설계
- @RequestParam, @PathVariable

---

### Phase 5: AI 활용 연동 (1시간)

- [ ] 피드백 기반 재정렬 Service 설계
- [ ] 개인화 Service 설계
- [ ] 프롬프트 개선 Service 설계
- [ ] 품질 분석 Service 설계
- [ ] A/B 테스트 Service 설계

**학습 포인트:**
- 피드백 루프 설계
- 데이터 기반 AI 개선
- A/B 테스트 설계

---

### Phase 6: 통합 테스트 (30분)

- [ ] 전체 플로우 테스트
- [ ] 에러 처리 확인
- [ ] 로그 확인

**총 예상 시간: 약 5시간**

---

## 패키지 구조

```
src/main/java/com/.../telegram/
├── entity/
│   └── SearchFeedback.java
├── repository/
│   └── SearchFeedbackRepository.java
├── dto/
│   ├── FeedbackRequest.java
│   └── FeedbackStats.java
├── service/
│   ├── FeedbackService.java
│   ├── FeedbackServiceImpl.java
│   ├── FeedbackAwareRankingService.java
│   ├── PersonalizedRecommendationService.java
│   ├── FeedbackEnhancedAiPromptService.java
│   ├── SearchQualityAnalyticsService.java
│   └── FeedbackAbTestService.java
├── keyboard/
│   └── TelegramKeyboardFactory.java
├── handler/
│   └── CallbackQueryHandler.java
└── api/
    └── FeedbackAdminController.java
```

---

## 사용 예시

### 1. 피드백 요청

```
User: 해리포터

Bot: 📚 "해리포터" 검색 결과

     🤖 AI 추천 사유
     💬 해리포터 시리즈의 첫 번째 책으로...

     검색된 도서 (3개)

     💡 검색 결과가 도움이 되셨나요?
     아래 버튼으로 피드백을 주시면 검색 품질 개선에 참고하겠습니다!

     1. 해리포터와 마법사의 돌
     📖 조앤 K. 롤링
     🎯 유사도: 85.50%

     [👍 좋았음] [👎 별로였음]
```

### 2. 피드백 제출

```
User: [👍 좋았음] 클릭

Bot: ✅ 소중한 피드백 감사합니다!

     검색 품질 개선에 활용하겠습니다.
```

### 3. 관리자 API

```bash
# 통계 조회
curl "http://localhost:8080/api/admin/feedback/stats?query=해리포터"

응답:
{
  "goodCount": 15,
  "badCount": 2,
  "totalCount": 17,
  "goodRatio": 0.882,
  "feedbackScore": 0.764
}
```

---

## 학습 체크리스트

### 필수 구현 사항

- [ ] JPA Entity 설계
- [ ] Repository 인터페이스 정의
- [ ] Service 인터페이스 및 구현
- [ ] DTO 설계
- [ ] Inline Keyboard 생성
- [ ] Callback Query 처리
- [ ] Bot 연동
- [ ] Admin API 설계 및 구현

### 도전 과제

#### 기본 과제
- [ ] 피드백 중복 방지
- [ ] 피드백 익명화
- [ ] 피드백 내보내기 (CSV)

#### AI 활용 과제 (추천)
- [ ] 피드백 기반 검색 재정렬
- [ ] 사용자 선호 기반 개인화
- [ ] 피드백 통계를 AI 프롬프트에 포함
- [ ] 검색 품질 분석 보고서
- [ ] A/B 테스트로 효과 측정

---

## 트러블슈팅

### 1. Inline Keyboard가 표시되지 않음

**원인:** `replyMarkup` 설정 누락
**해결:** `SendMessage.builder().replyMarkup(keyboard).build()` 확인

### 2. Callback 데이터 파싱 오류

**원인:** 특수문자(`:`) 처리 미흡
**해결:** URL 인코딩/디코딩 사용

### 3. JPA Entity 생성 오류

**원인:** 기본 생성자 누락
**해결:** `@NoArgsConstructor(access = AccessLevel.PROTECTED)` 추가

### 4. 트랜잭션 롤백 문제

**원인:** `@Transactional` 누락
**해결:** Service 메서드에 `@Transactional` 추가

---

## Step 5 완료

이제 다음 기능이 완료되었습니다:

- ✅ Telegram Bot 기본 설정
- ✅ RAG 검색 연동
- ✅ 사용자 피드백 수집
- ✅ **피드백 기반 AI 개선 루프**

**축하합니다!** AI 기반 검색 시스템에 사용자 피드백 기능을 구축하고, 피드백 데이터를 활용하여 AI를 지속적으로 개선하는 **피드백 루프(Feedback Loop)**를 완성했습니다.

### AI 시스템 개선의 핵심: 피드백 루프

```
사용자 → 검색 → 피드백 → 분석 → AI 개선 → 더 나은 검색 → 사용자
   ↑                                              ↓
   └──────────────── 더 나은 경험 ←────────────────┘
```

이 피드백 루프는 다음과 같은 AI 시스템의 핵심 원칙을 체험합니다:

1. **데이터 기반 의사결정**: 피드백 데이터를 분석하여 시스템 개선
2. **지속적 학습**: 사용자 피드백을 통해 시스템이 계속 발전
3. **개인화**: 사용자별 선호도를 학습하여 맞춤형 추천
4. **측정 가능성**: A/B 테스트로 개선 효과를 정량적으로 측정

---

## 다음 단계

- [Step 6: MCP 및 외부 서비스 연계](../step-6/01.understanding-mcp.md)
