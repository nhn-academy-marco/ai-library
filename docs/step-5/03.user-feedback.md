# 사용자 피드백 수집

## 개요

사용자로부터 검색 결과에 대한 피드백을 수집하고, 이를 통해 AI 검색 품질을 개선합니다. 수집된 피드백 데이터는 **지속적인 AI 시스템 개선의 핵심 자산**으로 활용됩니다.

## 학습 목표

- **JPA Entity 설계**: 도메인 모델을 데이터베이스 스키마로 매핑
- **계층형 아키텍처**: Controller → Service → Repository 구조 이해
- **사용자 인터랙션**: Inline Keyboard와 Callback Query 처리 흐름
- **데이터 설계**: 피드백 데이터를 AI 학습에 활용할 수 있는 구조 설계
- **피드백 루프**: 수집 → 분석 → 개선의 전체 사이클 이해

---

## 왜 피드백인가?

### AI 시스템의 성장 루프

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   사용자 검색 ──▶ 결과 표시 ──▶ 피드백 수집              │
│       ▲                                    │            │
│       │                                    ▼            │
│   더 나은 경험 ◀── AI 모델 개선 ◀── 데이터 분석          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**피드백이 중요한 이유:**
1. **객관적 품질 지표**: 사용자가 실제로 만족하는지 측정
2. **지속적 개선**: 시스템을 사용할수록 더 똑똑해짐
3. **개인화 기반**: 사용자별 선호도 학습 가능
4. **A/B 테스트**: 개선 효과를 정량적으로 검증

### 실무 사례

| 서비스 | 피드백 활용 |
|--------|-------------|
| **Netflix** | 시청 여부로 추천 알고리즘 개선 |
| **YouTube** | 클릭률, 시청 시간으로 추천 최적화 |
| **Google 검색** | 클릭 여부로 검색 순위 개선 |
| **Amazon** | 구매 여부로 상품 추천 개선 |

---

## 전체 아키텍처

### 시스템 구조도

```
┌─────────────────────────────────────────────────────────────┐
│                      Telegram User                         │
│                    (검색 결과 확인 후)                      │
└────────────────────────┬────────────────────────────────────┘
                         │ 클릭: 👍 도움이 됨
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                 Inline Keyboard (버튼 UI)                   │
│  [👍 도움이 됨] [👎 도움이 안됨]  [✅ 관련 있음] [❌ 관련 없음]│
└────────────────────────┬────────────────────────────────────┘
                         │ Callback Query 전송
                         ▼
┌─────────────────────────────────────────────────────────────┐
│              CallbackQueryHandler                          │
│  1. Callback 데이터 수신                                   │
│  2. 데이터 파싱 (query, bookId, type)                     │
│  3. FeedbackService 호출                                   │
│  4. 감사 메시지 전송                                       │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                FeedbackService                             │
│  • 피드백 저장                                             │
│  • 통계 계산                                               │
│  • 사용자별 조회                                           │
└──────────────────┬────────────────┬────────────────────────┘
                   │                │
                   ▼                ▼
        ┌──────────────────┐  ┌──────────────────┐
        │  Repository      │  │  AI Improvement  │
        │  (DB 저장)       │  │  Services        │
        └──────────────────┘  │  • 검색 재정렬    │
                               │  • 개인화        │
                               │  • 프롬프트 개선 │
                               │  • 품질 분석     │
                               │  • A/B 테스트     │
                               └──────────────────┘
```

### 데이터 흐름도

```
1. 사용자가 검색 → 결과 표시 + Inline Keyboard
                    ↓
2. 사용자가 버튼 클릭 → Callback Query 전송
                    ↓
3. CallbackHandler 수신 → 데이터 파싱
                    ↓
4. FeedbackService → DB 저장
                    ↓
5. 저장된 피드백 → 분석 및 AI 개선에 활용
                    ↓
6. 다음 검색 시 → 개선된 결과 제공
```

### 계층별 역할

```
┌─────────────────────────────────────────────────────┐
│  Presentation Layer                                │
│  • Inline Keyboard: 사용자 버튼 UI                 │
│  • CallbackQueryHandler: Callback 처리             │
│  • Admin API: 관리자용 조회/통계                   │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│  Business Layer                                    │
│  • FeedbackService: 피드백 비즈니스 로직           │
│  • FeedbackAwareRankingService: 재정렬            │
│  • PersonalizedRecommendationService: 개인화      │
│  • FeedbackEnhancedAiPromptService: 프롬프트 개선 │
│  • SearchQualityAnalyticsService: 품질 분석       │
│  • FeedbackAbTestService: A/B 테스트               │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│  Data Access Layer                                 │
│  • SearchFeedbackRepository: DB CRUD               │
│  • SearchFeedback Entity: 데이터 모델              │
│  • FeedbackRequest/Stats: 데이터 전송 객체         │
└─────────────────────────────────────────────────────┘
```

---

## 핵심 개념

### 1. 피드백 데이터 모델

**수집할 정보:**
- **누가**: Chat ID (사용자 식별)
- **무엇을**: 검색어, 도서 ID
- **어떻게**: 피드백 타입 (긍정/부정)
- **언제**: 타임스탬프

**피드백 타입:**
```
👍 좋았음 (GOOD)   → 검색 결과가 마음에 들음  (+1점)
👎 별로였음 (BAD)  → 검색 결과가 별로였음    (-1점)
```

**설계 이유:**
- 단순명료: 사용자가 고민할 필요 없이 바로 클릭
- 명확한 점수화: 긍정 +1, 부정 -1로 계산 단순
- 실무 표준: Reddit, Hacker News 등 많은 서비스가 이 방식 사용

### 2. Inline Keyboard

**Inline Keyboard란 무엇인가요?**

Telegram의 **버튼 형태 UI**로, 사용자가 클릭하면 Bot에 Callback(콜백) 신호가 전달됩니다.

웹사이트의 버튼을 생각하면 쉽습니다:
- 웹사이트: `<button onclick="handleClick()">클릭</button>`
- Telegram: `InlineKeyboardButton(callbackData="feedback:123")`

**왜 Inline Keyboard를 사용하나요?**

1. **사용자 친화적**: 텍스트를 직접 입력할 필요 없이 버튼 클릭만으로 동작
2. **입력 오류 방지**: "/search 해리포터" 같은 명령어를 틀리지 않고 버튼으로 정확하게 전달
3. **실시간 피드백**: 클릭 즉시 Bot이 응답하고 메시지를 수정 가능

---

**Markdown 링크 vs Inline Keyboard 비교**

현재 Bot에서 이미 사용 중인 Markdown 링크와 비교해보겠습니다:

| 구분 | Markdown 링크 | Inline Keyboard |
|------|---------------|-----------------|
| **용도** | 웹사이트로 이동 | Bot에 신호 전달 |
| **예시** | `🔗 상세 보기: [링크](https://...)` | `[👍 도움이 됨] 버튼` |
| **동작** | 외부 브라우저 열림 | Bot 내에서 처리 |
| **Bot 수신** | 수신 불가 (사용자가 브라우저로 이동) | `hasCallbackQuery()`로 감지 |
| **사용 사례** | 도서 상세 페이지 보기 | 피드백 전송, 명령 실행 |

**실제 코드 예시:**

```java
// 1. Markdown 링크 (현재 사용 중)
String message = "🔗 상세 보기: https://library.java21.net/books/123";
SendMessage(msg).text(message).build();
// → 사용자가 클릭하면 웹브라우저가 열림

// 2. Inline Keyboard (이번에 추가)
InlineKeyboardButton button = InlineKeyboardButton.builder()
    .text("👍 도움이 됨")
    .callbackData("feedback:해리포터:123:HELPFUL")
    .build();
// → 사용자가 클릭하면 Bot이 callbackData를 수신
```

---

**Inline Keyboard 작동 방식**

```
┌─────────────────────────────────────────────┐
│         사용자 화면 (Telegram App)          │
│                                             │
│  Bot: 검색 결과가 도움이 되셨나요?           │
│                                             │
│  [👍 도움이 됨] [👎 도움이 안됨]  ← 버튼    │
│  [✅ 관련 있음] [❌ 관련 없음]  ← Inline     │
│           Keyboard                          │
└─────────────────┬───────────────────────────┘
                  │
                  │ 사용자가 버튼 클릭
                  ▼
┌─────────────────────────────────────────────┐
│           Telegram 서버                      │
│  callbackData: "feedback:해리포터:123:HELPUL" │
└─────────────────┬───────────────────────────┘
                  │
                  │ Callback Query 전송
                  ▼
┌─────────────────────────────────────────────┐
│           LibraryTelegramBot                │
│  onUpdateReceived(Update) 호출              │
│  update.hasCallbackQuery() == true          │
└─────────────────┬───────────────────────────┘
                  │
                  │ CallbackQueryHandler 처리
                  ▼
┌─────────────────────────────────────────────┐
│         데이터 파싱 및 저장                  │
│  query = "해리포터"                         │
│  bookId = 123                               │
│  type = HELPFUL                             │
│  → DB 저장                                  │
└─────────────────────────────────────────────┘
```

---

**일반 메시지와의 차이**

| 구분 | 일반 메시지 | Inline Keyboard |
|------|-------------|-----------------|
| **사용자 입력** | 텍스트 직접 입력 | 버튼 클릭 |
| **Bot 수신 메서드** | `hasMessage()` | `hasCallbackQuery()` |
| **응답 방식** | `SendMessage` (새 메시지) | `EditMessageText` (기존 메시지 수정) |
| **예시** | User: "해리포터" 입력 | User: [👍 좋았음] 클릭 |

---

**참고 자료**

Telegram Bot 공식 문서:
- [Inline Keyboards](https://core.telegram.org/bots/features#inline-keyboards)
- [InlineKeyboardMarkup](https://core.telegram.org/bots/api#inlinekeyboardmarkup)
- [Callback Query](https://core.telegram.org/bots/api#callbackquery)

Java 라이브러리 (telegram-bot):
- [TelegramBots GitHub](https://github.com/rubenlagus/TelegramBots)

### 3. Callback 데이터 설계

버튼 식별을 위한 데이터 포맷:

**포맷:**
```
feedback:{query}:{bookId}:{type}

예: feedback:해리포터:123:GOOD
```

**고려사항:**
- 특수문자 처리 (`:` → URL 인코딩 필요)
- 파싱 용이성
- 확장성 (다른 타입의 Callback 추가 가능)

---

### 4. 피드백 UI 설계

**중요한 설계 결정: 개별 도서별 피드백**

각 검색 결과 도서마다 별도의 피드백 버튼을 제공합니다:

```
Bot: 📚 "해리포터" 검색 결과 (5권)

     1. 해리포터와 마법사의 돌
        [👍 좋았음] [👎 별로였음]

     2. 해리포터와 비밀의 방
        [👍 좋았음] [👎 별로였음]
```

**왜 개별 도서별인가?**
1. **더 정밀한 피드백**: "첫 번째 책은 좋았는데, 두 번째 책은 별로였어"
2. **AI 개선에 활용**: 피드백이 많은 도서를 상위 표시 (Learning to Rank)
3. **개인화 가능**: 사용자가 "판타지" 좋아하는 패턴 학습

**데이터 저장 예시:**
```
도서 1에 👍 클릭 → bookId = 1, type = GOOD
도서 2에 👎 클릭 → bookId = 2, type = BAD
```

---

## 데이터베이스 설계

### ERD

```
┌─────────────────────────────────────────────┐
│             search_feedbacks                │
├─────────────────────────────────────────────┤
│  id           (PK)          BIGINT          │
│  chat_id      (NOT NULL)   BIGINT           │
│  query        (NOT NULL)   VARCHAR(500)     │
│  book_id                    BIGINT          │
│  type         (NOT NULL)   VARCHAR(20)      │
│  created_at   (NOT NULL)   TIMESTAMP        │
├─────────────────────────────────────────────┤
│  INDEX: idx_chat_id                         │
│  INDEX: idx_created_at                      │
└─────────────────────────────────────────────┘
```

### 필드 상세 설명

| 컬럼명 | 타입 | NULL | 설명 | 예시 |
|--------|------|------|------|------|
| **id** | BIGINT | NOT NULL | 기본키 (PK) | 1, 2, 3, ... |
| **chat_id** | BIGINT | NOT NULL | Telegram 사용자 식별자 | 123456789, 987654321 |
| **query** | VARCHAR(500) | NOT NULL | 사용자 검색어 | "해리포터", "주식 투자" |
| **book_id** | BIGINT | NULL | 피드백 대상 도서 ID | 101, 205, NULL (전체 피드백) |
| **type** | VARCHAR(20) | NOT NULL | 피드백 유형 | GOOD, BAD |
| **created_at** | TIMESTAMP | NOT NULL | 피드백 생성 시간 | 2025-01-15 14:30:25 |

**필드별 상세 설명:**

| 필드 | 의미 | 사용 예시 |
|------|------|----------|
| **id** | 피드백 고유 번호 (자동 증가) | DB가 자동 부여 |
| **chat_id** | Telegram 사용자 고유 ID. 같은 사용자인지 식별 | 123456789 = 철수, 987654321 = 영희 |
| **query** | 사용자가 입력한 검색어. URL 인코딩된 상태로 저장 | "해리포터", "Java%20%EB%B0%B1%EC%97%94%EB%93%9C" |
| **book_id** | 피드백을 준 도서 ID. 특정 도서를 지정 | 101 = "해리포터와 마법사의 돌" |
| **type** | 피드백 종류. 긍정/부정 유형 | GOOD = 좋았음(+1점), BAD = 별로였음(-1점) |
| **created_at** | 피드백이 저장된 시간. 자동 생성 | "2025-01-15 14:30:25" |

---

### SQL DDL

**MySQL/MariaDB:**
```sql
CREATE TABLE search_feedbacks (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    chat_id BIGINT NOT NULL,
    query VARCHAR(500) NOT NULL,
    book_id BIGINT,
    type VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_chat_id (chat_id),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**H2 (개발용):**
```sql
CREATE TABLE search_feedbacks (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    chat_id BIGINT NOT NULL,
    query VARCHAR(500) NOT NULL,
    book_id BIGINT,
    type VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_chat_id (chat_id),
    INDEX idx_created_at (created_at)
);
```

**PostgreSQL:**
```sql
CREATE TABLE search_feedbacks (
    id BIGSERIAL PRIMARY KEY,
    chat_id BIGINT NOT NULL,
    query VARCHAR(500) NOT NULL,
    book_id BIGINT,
    type VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_chat_id (chat_id),
    INDEX idx_created_at (created_at)
);
```

---

### 예시 데이터

**실제 저장되는 데이터 예시:**

```
┌────┬───────────┬──────────────┬─────────┬───────────────┬─────────────────────┐
│ id │  chat_id  │    query     │ book_id │     type      │     created_at      │
├────┼───────────┼──────────────┼─────────┼───────────────┼─────────────────────┤
│  1 │ 123456789 │ 해리포터     │     101 │ GOOD          │ 2025-01-15 14:30:25 │
│  2 │ 123456789 │ 해리포터     │     102 │ BAD           │ 2025-01-15 14:31:10 │
│  3 │ 987654321 │ 주식 투자    │     205 │ GOOD          │ 2025-01-15 15:20:05 │
│  4 │ 123456789 │ Java 백엔드  │     310 │ GOOD          │ 2025-01-15 16:45:30 │
│  5 │ 987654321 │ 주식 투자    │     205 │ BAD           │ 2025-01-15 17:10:15 │
└────┴───────────┴──────────────┴─────────┴───────────────┴─────────────────────┘
```

**데이터 분석 예시:**

| 질문 | SQL 예시 | 결과 |
|------|----------|------|
| "해리포터" 검색에 대한 긍정 피드백 수? | `SELECT COUNT(*) FROM search_feedbacks WHERE query='해리포터' AND type='GOOD'` | 1건 |
| 도서 ID 101에 대한 피드백 점수? | `(긍정 1건 - 부정 0건) / 1건 = 1.0 (100% 긍정)` | +0.5 보너스 |
| 철수(chatId=123456789)가 좋아한 도서? | `SELECT book_id FROM search_feedbacks WHERE chat_id=123456789 AND type='GOOD'` | 101, 310 |
| 최근 7일간 긍정 피드백 비율? | `긍정 3건 / 전체 5건 = 60%` | 60% |

**실제 사용 시나리오:**

```
시나리오: 철수가 "해리포터"를 검색하고 피드백을 남김

1. 검색: User(chatId=123456789) → "해리포터" 검색
2. 결과: 3권의 도서 표시 (ID: 101, 102, 103)
3. 피드백:
   - 도서 101: [👍 좋았음] 클릭
   - 도서 102: [👎 별로였음] 클릭
4. DB 저장:
   INSERT INTO search_feedbacks (chat_id, query, book_id, type, created_at)
   VALUES (123456789, '해리포터', 101, 'GOOD', '2025-01-15 14:30:25');

   INSERT INTO search_feedbacks (chat_id, query, book_id, type, created_at)
   VALUES (123456789, '해리포터', 102, 'BAD', '2025-01-15 14:31:10');
5. AI 활용:
   - 도서 101: 긍정 피드백 → 다음 검색 시 상위 표시
   - 도서 102: 부정 피드백 → 다음 검색 시 하위 표시
```

---

### JPA Entity 설계 포인트

**필요한 어노테이션:**
- `@Entity` - JPA Entity임을 명시
- `@Table` - 테이블명과 인덱스 설정
- `@Id` + `@GeneratedValue` - 기본키 설정
- `@Enumerated(EnumType.STRING)` - Enum을 문자열로 저장
- `@PrePersist` - 저장 전 자동으로 created_at 설정

**구현 가이드:**
- 인덱스: chat_id, created_at (조회 성능)
- Enum: String 타입으로 저장 (가독성)
- @PrePersist: 생성 시간 자동 설정

---

## 구현 가이드

### Phase 1: Entity와 Repository

**목표:** 피드백 데이터를 저장할 데이터베이스 구조 만들기

**구현해야 할 것:**

**1. `FeedbackType` Enum**
- GOOD(1, "좋았음"), BAD(-1, "별로였음") 정의
- `getScoreValue()` 메서드로 점수 반환 (+1, -1)

**2. `SearchFeedback` Entity**
- 필드: id, chatId, query, bookId, type(FeedbackType), createdAt
- 어노테이션: @Entity, @Table(name="search_feedbacks"), @Index
- @PrePersist: createdAt 자동 설정

**3. `SearchFeedbackRepository` 인터페이스**
- Spring Data JPA 상속
- 쿼리 메서드:
  - `findByChatIdOrderByCreatedAtDesc(Long chatId)` - 특정 사용자 피드백
  - `findByBookId(Long bookId)` - 특정 도서의 모든 피드백
  - `findByQuery(String query)` - 특정 검색어 피드백

**처리 흐름:**
```
피드백 생성 → Entity 매핑 → Repository → DB 저장
```

**학습 포인트:**
- JPA 어노테이션 (@Entity, @Table, @Index, @Enumerated)
- Enum을 String으로 저장하는 이유 (가독성)
- @PrePersist로 생성 시간 자동 설정
- Spring Data JPA 메서드 네이밍 규칙

---

### Phase 2: DTO와 Service

**목표:** 비즈니스 로직과 데이터 전송 객체 만들기

**구현해야 할 것:**

**1. `FeedbackRequest` DTO (record)**
- 필드: query(@NotBlank), bookId(@NotNull), type(@NotNull)
- 역할: 피드백 요청 데이터 전달, 유효성 검사

**2. `FeedbackStats` DTO (record)**
- 필드: goodCount, badCount, totalCount, goodRatio, feedbackScore
- 메서드: `from(List<SearchFeedback>)` - Stream API로 통계 계산
- 점수 계산: (긍정 - 부정) / 전체
- 예: GOOD 15건, BAD 2건 → (15-2)/17 = 0.76

**3. `FeedbackService` 인터페이스**
- `recordFeedback(FeedbackRequest)` - 피드백 저장
- `getUserFeedback(Long chatId)` - 사용자별 피드백 목록
- `getBookFeedbackStats(Long bookId)` - 도서별 통계
- `getQueryFeedbackStats(String query)` - 검색어별 통계
- `getRecentFeedback(int days)` - 최근 N일 피드백

**4. `FeedbackServiceImpl` 구현**
- @Transactional 트랜잭션 처리
- Repository 호출하여 DB 저장
- Stream API로 통계 계산

**처리 흐름:**
```
Request DTO → Service → Repository → DB
              ↓
         Stats 계산 → Stats DTO 반환
```

**학습 포인트:**
- record 활용 (불변 객체)
- Validation 어노테이션 (@NotNull, @NotBlank)
- @Transactional (readOnly 최적화)
- Stream API로 데이터 집계

---

### Phase 3: Inline Keyboard Factory

**목표:** 버튼 UI 생성 로직 만들기

**구현해야 할 것:**

**`TelegramKeyboardFactory` 클래스**
- `createFeedbackKeyboard(String query, Long bookId)` 메서드
  - 검색어 URL 인코딩 (공백, 한글 처리)
  - InlineKeyboardButton 2개 생성 (좋았음, 별로였음)
  - InlineKeyboardMarkup.builder()로 Keyboard 조립
  - callbackData 포맷: `feedback:{query}:{bookId}:{type}`
  - 예: `feedback:해리포터:123:GOOD`

**UI 레이아웃:**
```
┌─────────────────────────────────┐
│  [👍 좋았음] [👎 별로였음]       │
└─────────────────────────────────┘
```

**처리 흐름:**
```
검색어 입력 → URL 인코딩 → Keyboard 생성 → 버튼에 Callback 데이터 연결
```

**학습 포인트:**
- Builder 패턴으로 Keyboard 생성
- URL 인코딩으로 특수문자 처리
- Callback 데이터 포맷 설계 (콜론(:)으로 구분)

---

### Phase 4: Callback Handler

**목표:** 버튼 클릭 처리 로직 만들기

**구현해야 할 것:**

**`CallbackQueryHandler` 클래스**
- `handleCallback(Update update)` 메서드
  1. Callback 유형 확인 (hasCallbackQuery)
  2. Callback 데이터 파싱 (split(":"))
     - `feedback:해리포터:123:GOOD` → ["feedback", "해리포터", "123", "GOOD"]
  3. URL 디코딩으로 검색어 복원
  4. FeedbackRequest 생성
  5. FeedbackService로 저장
  6. EditMessageText로 메시지 수정 (감사 메시지)
  7. AnswerCallbackQuery로 Telegram에 응답
  8. 예외 처리 (IllegalArgumentException, 일반 Exception)

**처리 흐름:**
```
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│ 사용자 클릭 │ →  │ Callback 수신 │ →  │  데이터 파싱  │ →  │  DB 저장    │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
                                                                ↓
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│  완료 응답   │ ←  │ 메시지 수정   │ ←  │ 감사 메시지  │ ←  │ Telegram API │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
```

**학습 포인트:**
- URL 디코딩으로 특수문자 복원
- Enum 변환 시 IllegalArgumentException 처리
- EditMessageText로 기존 메시지 수정
- AnswerCallbackQuery로 Telegram에 응답 전송

            // 3. 피드백 저장
            FeedbackRequest request = new FeedbackRequest(query, bookId, type);
            feedbackService.recordFeedback(request);

            // 4. 메시지 수정 (감사 메시지)
            EditMessageText editMessage = EditMessageText.builder()
                .chatId(chatId)
                .messageId(callbackQuery.getMessage().getMessageId())
                .text("✅ 소중한 피드백 감사합니다!\n검색 품질 개선에 활용하겠습니다.")
                .build();

            // execute(editMessage);

            // 5. Callback 응답 (Telegram에 전송 완료 알림)
            AnswerCallbackQuery answer = AnswerCallbackQuery.builder()
                .callbackQueryId(callbackQuery.getId())
                .text("피드백이 저장되었습니다.")
                .build();
            // execute(answer);

        } catch (IllegalArgumentException e) {
            log.error("Invalid callback data: {}", callbackData, e);
            sendErrorMessage(chatId, "피드백 처리 중 오류가 발생했습니다.");
        } catch (Exception e) {
            log.error("Failed to process callback: {}", callbackData, e);
            sendErrorMessage(chatId, "피드백 처리 중 오류가 발생했습니다.");
        }
    }

    private void sendErrorMessage(Long chatId, String text) {
        // 에러 메시지 전송 로직
    }
}
```
**역할:** 버튼 클릭 시 Callback 처리

**처리 흐름:**
```
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│ 사용자 클릭 │ →  │ Callback 수신 │ →  │  데이터 파싱  │ →  │  DB 저장    │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
                                                                ↓
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│  완료 응답   │ ←  │ 메시지 수정   │ ←  │ 감사 메시지  │ ←  │ Telegram API │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
```

**학습 포인트:**
- URL 디코딩으로 특수문자 복원
- Enum 변환 시 IllegalArgumentException 처리
- EditMessageText로 기존 메시지 수정
- AnswerCallbackQuery로 Telegram에 응답 전송

---

### Phase 5: Bot 연동

**목표:** 기존 Bot에 피드백 기능 통합

**수정해야 할 것:**

**1. `LibraryTelegramBot`에 의존성 추가**
- CallbackQueryHandler 주입
- TelegramKeyboardFactory 주입

**2. `onUpdateReceived` 메서드 수정**
- Callback Query 처리를 최우선으로 분기
- 일반 메시지는 기존 로직대로 처리
- 우선순위: Callback → 일반 메시지

**3. 검색 결과 전송 메서드 수정**
- 도서 정보 전송 시 Keyboard 생성
- SendMessage.builder()에 .replyMarkup(keyboard) 추가
- 각 도서마다 개별 Keyboard 부착

**처리 흐름:**
```
Update 수신 → Callback 확인? → YES: CallbackHandler 처리
                          → NO: 기존 메시지 처리
검색 결과 전송 → Keyboard 생성 → replyMarkup 설정 → 전송
```

**학습 포인트:**
- 기존 코드에 새 기능 통합 방법
- 우선순위 기반 분기 처리
- replyMarkup으로 Keyboard 메시지에 부착

---

### Phase 6: Admin API

**목표:** 관리자용 조회/통계 API 만들기

**구현해야 할 것:**

**`FeedbackAdminController` 클래스 (@RestController)**
- `GET /api/admin/feedback/stats?query=해리포터`
  - 특정 검색어의 피드백 통계 조회
  - @RequestParam으로 query 수신

- `GET /api/admin/feedback/recent?days=7`
  - 최근 N일간 피드백 목록 조회
  - @RequestParam(defaultValue="7")로 days 수신

- `GET /api/admin/feedback/user/{chatId}`
  - 특정 사용자의 피드백 목록 조회
  - @PathVariable으로 chatId 수신

- `GET /api/admin/feedback/book/{bookId}`
  - 특정 도서의 피드백 통계 조회
  - @PathVariable으로 bookId 수신

**API 응답 예시:**
```json
GET /api/admin/feedback/stats?query=해리포터

{
  "goodCount": 15,
  "badCount": 2,
  "totalCount": 17,
  "goodRatio": 0.882,
  "feedbackScore": 0.764
}
```

**처리 흐름:**
```
HTTP 요청 → Controller → Service → Repository → DB
                 ↓
           ResponseEntity ← Stats DTO ← 변환
```

**학습 포인트:**
- @GetMapping, @RequestParam, @PathVariable 활용
- ResponseEntity로 JSON 응답
- REST API 설계 원칙

**목표:** 관리자용 조회/통계 API 만들기

**구현해야 할 것:**

**`FeedbackAdminController` 클래스**
```java
@RestController
@RequestMapping("/api/admin/feedback")
@RequiredArgsConstructor
public class FeedbackAdminController {

    private final FeedbackService feedbackService;

    /**
     * 특정 검색어의 피드백 통계 조회
     * GET /api/admin/feedback/stats?query=해리포터
     */
    @GetMapping("/stats")
    public ResponseEntity<FeedbackStats> getQueryStats(@RequestParam String query) {
        FeedbackStats stats = feedbackService.getQueryFeedbackStats(query);
        return ResponseEntity.ok(stats);
    }

    /**
     * 최근 N일간 피드백 목록 조회
     * GET /api/admin/feedback/recent?days=7
     */
    @GetMapping("/recent")
    public ResponseEntity<List<SearchFeedback>> getRecentFeedback(
            @RequestParam(defaultValue = "7") int days) {
        List<SearchFeedback> feedbacks = feedbackService.getRecentFeedback(days);
        return ResponseEntity.ok(feedbacks);
    }

    /**
     * 특정 사용자의 피드백 목록 조회
     * GET /api/admin/feedback/user/{chatId}
     */
    @GetMapping("/user/{chatId}")
    public ResponseEntity<List<SearchFeedback>> getUserFeedback(
            @PathVariable Long chatId) {
        List<SearchFeedback> feedbacks = feedbackService.getUserFeedback(chatId);
        return ResponseEntity.ok(feedbacks);
    }

    /**
     * 특정 도서의 피드백 통계 조회
     * GET /api/admin/feedback/book/{bookId}
     */
    @GetMapping("/book/{bookId}")
    public ResponseEntity<FeedbackStats> getBookStats(@PathVariable Long bookId) {
        FeedbackStats stats = feedbackService.getBookFeedbackStats(bookId);
        return ResponseEntity.ok(stats);
    }
}
```
**역할:** 관리자용 피드백 조회/통계 API 제공

**API 사용 예시:**
```bash
# 통계 조회
curl "http://localhost:8080/api/admin/feedback/stats?query=해리포터"

# 최근 7일 피드백
curl "http://localhost:8080/api/admin/feedback/recent?days=7"

# 사용자 피드백
curl "http://localhost:8080/api/admin/feedback/user/123456789"
```

**학습 포인트:**
- @GetMapping, @RequestParam, @PathVariable
- ResponseEntity로 응답
- REST API 설계

---

## 피드백 활용: AI 개선 연계

수집된 피드백을 실제 AI 개선에 활용하는 방법입니다.

---

### 피드백 집계 기준: **도서(book_id) 기준**

**핵심 원칙:** 피드백은 도서 ID 기준으로 집계합니다. 같은 도서에 대한 피드백은 검색어가 달라도 모두 통합하여 반영합니다.

**왜 book_id인가?**

1. **실용성**: 사용자가 "좋아요" 누른 건 검색어가 아니라 **도서**임
2. **단순함**: query 벡터 저장 없이 바로 집계 가능
3. **정확성**: 같은 도서는 어떤 검색어로 찾든 동일한 품질을 가짐

**실제 예시:**
```
도서 101이 총 100번 검색됨

- "해리포터" 검색 → GOOD 80건, BAD 5건
- "마법사 돌" 검색 → GOOD 10건, BAD 2건
- "Harry Potter" 검색 → GOOD 2건, BAD 1건

집계 결과:
- 총 GOOD: 92건, BAD: 8건
- 피드백 점수: (92 - 8) / 100 = 0.84
- 보너스 점수: 0.84 × 0.5 = +0.42점
```

**query는 언제 사용하나요?**
- 검색어별 품질 분석 (관리자 대시보드)
- "어떤 검색어가 결과가 좋은지/안좋은지" 확인용
- DB에서 `GROUP BY query`로 분석

**구현 방법:**
```java
// 특정 도서의 모든 피드백을 통합 (query 무시)
FeedbackStats stats = feedbackService.getBookFeedbackStats(bookId);
double bonusScore = stats.feedbackScore() * 0.5;  // 최대 ±0.5
```

---

## 피드백 반영 기준

### 현재 시스템 구조

```
┌─────────────────────────────────────────────────────┐
│          검색 요청 (query: "해리포터")           │
└────────────────────┬────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────┐
│     1단계: 하이브리드 검색                         │
│  • Vector 유사도 검색 (80%)                       │
│  • Keyword 검색 (20%)                            │
│  • RRF(Reciprocal Rank Fusion)로 점수 결합      │
│  결과: [A: 75점, B: 70점, C: 65점, D: 60점]      │
└────────────────────┬────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────┐
│     2단계: LLM 검증 (RAG)                           │
│  • 상위 N권 도서에 대해 AI 추천 사유 생성        │
│  • 사용자에게 도서 추천                            │
└─────────────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────┐
│     3단계: 피드백 반영 (추가)                    │
│  • 수집된 피드백 점수를 계산                     │
│  • 검색 결과에 반영                                 │
└─────────────────────────────────────────────────────�
```

---

### 피드백 반영 시점과 방법

**시점 1: 검색 재정렬 (Reranking)**

**언제?** 하이브리드 검색 결과가 나온 직후
**방법:** 피드백 점수를 원래 점수에 합산

```
[원래 점수]    [피드백 보너스]    [최종 점수]
A: 75점   +   A: +0.3점      =   A: 78.2점
B: 70점   +   B: +0.0점      =   B: 70.0점
C: 65점   +   C: -0.2점      =   C: 64.8점
D: 60점   +   D: -0.5점      =   D: 59.5점

→ 재정렬: [A, B, C, D]
```

**구현:**
```java
// 피드백 점수 계산
feedbackScore = (긍정 피드백 수 - 부정 피드백 수) / 총 피드백 수
// 예: 15건 긍정, 2건 부정 → (15 - 2) / 17 = 0.76

// 보너스 점수 (최대 ±0.5점)
bonusScore = feedbackScore * 0.5

// 최종 점수
finalScore = originalScore + bonusScore
```

---

**시점 2: LLM 프롬프트에 피드백 정보 포함**

**언제?** LLM에 추천 요청할 때
**방법:** 프롬프트에 피드백 통계 추가

```
프롬프트 예시:
"""
사용자가 "해리포터" 검색했습니다.

검색 결과 도서:
1. 해리포터와 마법사의 돌 (긍정 피드백: 88%)
2. 해리포터와 비밀의 방 (긍정 피드백: 45%)
3. ...

**중요**: 사용자들이 긍정적으로 평가한 도서를 우선적으로 추천해주세요.
"""
```

---

### 피드백 점수 계산 기준

#### 1. 개별 도서 피드백 점수

```
피드백 점수 = (긍정 피드백 수 - 부정 피드백 수) / 총 피드백 수

예시:
도서 1: 👍 15건, 👎 2건 → (15 - 2) / 17 = +0.76
도서 2: 👍 5건,  👎 5건 → (5 - 5) / 10 =   0.00
도서 3: 👍 2건, 👎 8건 → (2 - 8) / 10 = -0.60
```

#### 2. 보너스 점수 범위

| 피드백 점수 | 보너스 | 최종 점수 변화 |
|------------|-------|---------------|
| +1.0 (100% 긍정) | +0.5 | 75점 → 75.5점 |
| +0.5 (50% 긍정)  | +0.25 | 70점 → 70.25점 |
| 0.0 (긍정=부정) | 0 | 65점 → 65점 |
| -0.5 (50% 부정) | -0.25 | 60점 → 59.75점 |
| -1.0 (100% 부정) | -0.5 | 55점 → 54.5점 |

**이유:** 너무 큰 보너스는 원래 검색 결과를 무시할 수 있음

#### 3. 최소 피드백 수 기준

```
피드백이 5건 미만인 도서는 반영하지 않음
이유: 통계적으로 유의미한 데이터가 부족함
```

---

### 전체 흐름도

```
1. 사용자 검색
   ↓
2. 하이브리드 검색 (Vector + Keyword + RRF)
   결과: [A: 75점, B: 70점, C: 65점, D: 60점]
   ↓
3. 피드백 점수 계산 (각 도서별)
   - 도서 A: +0.3점 (피드백 88%)
   - 도서 B: +0.0점 (피드백 50%)
   - 도서 C: -0.2점 (피드백 20%)
   - 도서 D: -0.5점 (피드백 -20%)
   ↓
4. 최종 점수 합산
   결과: [A: 78.2점, B: 70.0점, C: 64.8점, D: 59.5점]
   ↓
5. 재정렬: [A, B, C, D]
   ↓
6. LLM 추천 (피드백 정보 포함)
```

---

### 학습 포인트

1. **피드백은 보조 수단**: 원래 검색 결과를 완전히 뒤집지 않음
2. **점수 범위 제한**: 너무 큰 영향을 주지 않도록 최대 ±0.5점
3. **최소 데이터 기준**: 5건 미만은 반영하지 않아 신뢙성 확보
4. **단계별 반영**: 1차 검색 → 피드백 보너스 → 최종 결과

---

### 활용 시나리오 개요

| 시나리오 | 설명 | 활용 분야 |
|----------|------|----------|
| **Learning to Rank** | 피드백 기반 검색 결과 재정렬 | 검색 엔진 |
| **개인화** | 사용자 선호도 학습 | 추천 시스템 |
| **프롬프트 개선** | 피드백 통계를 AI에 전달 | LLM 활용 |
| **품질 분석** | 검색 품질 보고서 생성 | 데이터 분석 |
| **A/B 테스트** | 개선 효과 측정 | 실험 설계 |

---

### 1. Learning to Rank

**개념:** 사용자가 "도움이 됨" 피드백을 많이 준 도서를 상위에 표시

**구현 흐름:**
```
1. 기존 검색: [A, B, C, D]
2. 피드백 점수 계산
   - A: 0.8 (긍정 80%)
   - B: 0.6
   - C: 0.4
   - D: 0.2
3. 재정렬: 피드백 점수 순으로 정렬
```

**핵심 메서드:**
- 피드백 점수 계산
- 재정렬

---

### 2. 개인화

**개념:** 사용자가 좋아한 도서 패턴을 학습

**활용 예시:**
```
사용자 A: "해리포터" → 👍, "마법사" → 👍
          → 추천 시 "판타지", "마법" 키워드 강조

사용자 B: "주식" → 👍, "투자" → 👍
          → 추천 시 "경제", "재테크" 키워드 강조
```

**핵심 메서드:**
- 선호 도서 목록 조회
- 개인화된 프롬프트 생성

---

### 3. AI 프롬프트 개선

**개념:** 피드백 통계를 LLM에게 전달

**프롬프트 예시:**
```
검색어 "해리포터"에 대한 사용자 피드백 통계:
- 도움이 됨: 15건 (88%)
- 도움이 안됨: 2건 (12%)
- 관련 있음: 18건 (95%)
- 관련 없음: 1건 (5%)

이 통계를 참고하여 추천 사유를 설명하세요.
```

**핵심 메서드:**
- 통계 포함 프롬프트 생성

---

### 4. 품질 분석

**개념:** 검색어별 품질 보고서 생성

**활용:**
- 어떤 검색어가 결과가 좋은지/안좋은지 분석
- 개선이 필요한 검색어 식별
- 시스템 품질 모니터링

**핵심 메서드:**
- 품질 보고서 생성
- 전체 긍정률, 검색어별 그룹화, 긍정률이 낮은 검색어 TOP 5

---

### 5. A/B 테스트

**개념:** 피드백 반영 전/후 효과 측정

**그룹 할당:**
```
사용자 A (chatId=123) → 해시값 → 짝수 → 피드백 반영 그룹
사용자 B (chatId=456) → 해시값 → 홀수 → 통제 그룹
```

**핵심 메서드:**
- 그룹 할당 (50:50)
- A/B 그룹별 긍정률 비교

---

## 피드백 루프 아키텍처

```
┌─────────────────────────────────────────────────────────┐
│                    사용자                                │
│  ┌──────────┐                                          │
│  │ 검색 요청 │                                          │
│  └─────┬────┘                                          │
│        │                                                │
│        ▼                                                │
│  ┌──────────────────────────────────────────────┐      │
│  │        검색 결과 + Inline Keyboard            │      │
│  │  [도서 목록]                                  │      │
│  │  [👍 도움이 됨] [👎 도움이 안됨]              │      │
│  └───────────────┬──────────────────────────────┘      │
│                  │                                      │
│                  ▼                                      │
│  ┌──────────────────────────────────────────────┐      │
│  │           버튼 클릭 (피드백)                  │      │
│  └───────────────┬──────────────────────────────┘      │
└──────────────────┼─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│              피드백 데이터 수집                          │
│  CallbackQueryHandler → FeedbackService → Repository    │
└──────────────────────────┬──────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                 피드백 분석                             │
│  • 긍정/부정 비율 계산  • 검색어별 품질 분석            │
│  • 사용자별 선호도 분석                                 │
└──────────────────────────┬──────────────────────────────┘
                           │
           ┌───────────────┼───────────────┐
           │               │               │
           ▼               ▼               ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  재정렬      │  │  개인화      │  │  프롬프트    │
│  (Ranking)   │  │  (Personal)  │  │  개선       │
│              │  │              │  │              │
│ [긍정 피드백 │  │ [사용자가    │  │ [통계를 LLM  │
│  많은 도서   │  │  좋아하는    │  │  에 전달]    │
│  상위 표시]  │  │  도서 추천]  │  │              │
└──────┬───────┘  └──────┬───────┘  └──────┬───────┘
       │                 │                 │
       └─────────────────┼─────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│               개선된 검색 결과                           │
│  • 더 관련성 높은 도서  • 개인화된 추천                 │
│  • 더 정확한 AI 추천 사유                               │
└──────────────────────────┬──────────────────────────────┘
                           │
                           ▼
                    ┌──────┴──────┐
                    │   사용자     │ (루프 계속)
                    └─────────────┘
```

---

## 구현 단계

### Phase 1: 데이터 계층 (1시간)

- [ ] SearchFeedback Entity 작성
- [ ] SearchFeedbackRepository 인터페이스 정의
- [ ] DDL로 테이블 생성 확인

**학습 포인트:**
- JPA 어노테이션 (@Entity, @Table, @Index)
- Enum 처리 (@Enumerated)
- 생명주기 콜백 (@PrePersist)

---

### Phase 2: 비즈니스 계층 (1시간)

- [ ] FeedbackRequest, FeedbackStats DTO 작성
- [ ] FeedbackService 인터페이스 설계
- [ ] FeedbackServiceImpl 구현

**학습 포인트:**
- record 활용
- Validation 어노테이션
- @Transactional 트랜잭션 관리

---

### Phase 3: UI 계층 (1.5시간)

- [ ] TelegramKeyboardFactory 작성
- [ ] CallbackQueryHandler 작성
- [ ] LibraryTelegramBot 수정

**학습 포인트:**
- Inline Keyboard 구조
- Callback 데이터 파싱
- EditMessageText 활용

---

### Phase 4: 관리자 API (30분)

- [ ] FeedbackAdminController 작성
- [ ] API 테스트

**학습 포인트:**
- REST API 설계
- @RequestParam, @PathVariable

---

### Phase 5: AI 활용 연동 (1시간)

- [ ] 피드백 기반 재정렬 Service 설계
- [ ] 개인화 Service 설계
- [ ] 프롬프트 개선 Service 설계
- [ ] 품질 분석 Service 설계
- [ ] A/B 테스트 Service 설계

**학습 포인트:**
- 피드백 루프 설계
- 데이터 기반 AI 개선
- A/B 테스트 설계

---

### Phase 6: 통합 테스트 (30분)

- [ ] 전체 플로우 테스트
- [ ] 에러 처리 확인
- [ ] 로그 확인

**총 예상 시간: 약 5시간**

---

## 패키지 구조

```
src/main/java/com/.../telegram/
├── entity/
│   └── SearchFeedback.java
├── repository/
│   └── SearchFeedbackRepository.java
├── dto/
│   ├── FeedbackRequest.java
│   └── FeedbackStats.java
├── service/
│   ├── FeedbackService.java
│   ├── FeedbackServiceImpl.java
│   ├── FeedbackAwareRankingService.java
│   ├── PersonalizedRecommendationService.java
│   ├── FeedbackEnhancedAiPromptService.java
│   ├── SearchQualityAnalyticsService.java
│   └── FeedbackAbTestService.java
├── keyboard/
│   └── TelegramKeyboardFactory.java
├── handler/
│   └── CallbackQueryHandler.java
└── api/
    └── FeedbackAdminController.java
```

---

## 사용 예시

### 1. 피드백 요청

```
User: 해리포터

Bot: 📚 "해리포터" 검색 결과

     🤖 AI 추천 사유
     💬 해리포터 시리즈의 첫 번째 책으로...

     검색된 도서 (3개)

     💡 검색 결과가 도움이 되셨나요?
     아래 버튼으로 피드백을 주시면 검색 품질 개선에 참고하겠습니다!

     1. 해리포터와 마법사의 돌
     📖 조앤 K. 롤링
     🎯 유사도: 85.50%

     [👍 좋았음] [👎 별로였음]
```

### 2. 피드백 제출

```
User: [👍 좋았음] 클릭

Bot: ✅ 소중한 피드백 감사합니다!

     검색 품질 개선에 활용하겠습니다.
```

### 3. 관리자 API

```bash
# 통계 조회
curl "http://localhost:8080/api/admin/feedback/stats?query=해리포터"

응답:
{
  "goodCount": 15,
  "badCount": 2,
  "totalCount": 17,
  "goodRatio": 0.882,
  "feedbackScore": 0.764
}
```

---

## 학습 체크리스트

### 필수 구현 사항

- [ ] JPA Entity 설계
- [ ] Repository 인터페이스 정의
- [ ] Service 인터페이스 및 구현
- [ ] DTO 설계
- [ ] Inline Keyboard 생성
- [ ] Callback Query 처리
- [ ] Bot 연동
- [ ] Admin API 설계 및 구현

### 도전 과제

#### 기본 과제
- [ ] 피드백 중복 방지
- [ ] 피드백 익명화
- [ ] 피드백 내보내기 (CSV)

#### AI 활용 과제 (추천)
- [ ] 피드백 기반 검색 재정렬
- [ ] 사용자 선호 기반 개인화
- [ ] 피드백 통계를 AI 프롬프트에 포함
- [ ] 검색 품질 분석 보고서
- [ ] A/B 테스트로 효과 측정

---

## 트러블슈팅

### 1. Inline Keyboard가 표시되지 않음

**원인:** `replyMarkup` 설정 누락
**해결:** `SendMessage.builder().replyMarkup(keyboard).build()` 확인

### 2. Callback 데이터 파싱 오류

**원인:** 특수문자(`:`) 처리 미흡
**해결:** URL 인코딩/디코딩 사용

### 3. JPA Entity 생성 오류

**원인:** 기본 생성자 누락
**해결:** `@NoArgsConstructor(access = AccessLevel.PROTECTED)` 추가

### 4. 트랜잭션 롤백 문제

**원인:** `@Transactional` 누락
**해결:** Service 메서드에 `@Transactional` 추가

---

## Step 5 완료

이제 다음 기능이 완료되었습니다:

- ✅ Telegram Bot 기본 설정
- ✅ RAG 검색 연동
- ✅ 사용자 피드백 수집
- ✅ **피드백 기반 AI 개선 루프**

**축하합니다!** AI 기반 검색 시스템에 사용자 피드백 기능을 구축하고, 피드백 데이터를 활용하여 AI를 지속적으로 개선하는 **피드백 루프(Feedback Loop)**를 완성했습니다.

### AI 시스템 개선의 핵심: 피드백 루프

```
사용자 → 검색 → 피드백 → 분석 → AI 개선 → 더 나은 검색 → 사용자
   ↑                                              ↓
   └──────────────── 더 나은 경험 ←────────────────┘
```

이 피드백 루프는 다음과 같은 AI 시스템의 핵심 원칙을 체험합니다:

1. **데이터 기반 의사결정**: 피드백 데이터를 분석하여 시스템 개선
2. **지속적 학습**: 사용자 피드백을 통해 시스템이 계속 발전
3. **개인화**: 사용자별 선호도를 학습하여 맞춤형 추천
4. **측정 가능성**: A/B 테스트로 개선 효과를 정량적으로 측정

---

## 다음 단계

- [Step 6: MCP 및 외부 서비스 연계](../step-6/01.understanding-mcp.md)
