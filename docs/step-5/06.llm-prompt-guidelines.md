# LLM 프롬프트 가이드라인

## 개요

수집된 피드백 데이터를 LLM 프롬프트에 효과적으로 통합하여 AI 추천 품질을 개선하는 방법을 설명합니다.

## 학습 목표

- LLM 프롬프트 설계 기본 원칙 이해
- 피드백 정보를 프롬프트에 통합하는 방법
- Relevance 우선, 피드백 보조의 올바른 접근법
- 피드백 편향(Bias) 방지 전략

---

### 3. AI 프롬프트 개선

**개념:** 피드백 정보를 LLM에게 **참고 자료(Context)**로 제공하여 지능적인 추천 가능하게 함

**⚠️ 중요: LLM에게 단순히 "피드백이 높은 순서대로 추천해달라"고 하면 안 됩니다!**

```
❌ 나쁜 예시:
"피드백이 높은 도서를 무조건 상위에 배치하세요."
→ LLM이 relevance 판단을 포기하고 피드백 순서대로 반환
→ 신간 도서(피드백 없음)은 영원히 기회를 얻지 못함
→ 피드백 편향(Bias)이 강화되어 검색 품질 저하

✅ 좋은 예시:
"피드백 정보를 참고하여 추천하되, relevance(관련성)을 최우선으로 고려하세요."
→ LLM이 피드백을 하나의 참고 자료로 활용
→ 여전히 relevance를 기반으로 지능적으로 판단
→ 피드백이 없는 신간 도서도 기회를 얻을 수 있음
```

---

#### 올바른 프롬프트 전략

**핵심 원칙: Relevance 우선, 피드백은 보조 정보**

```java
String template = """
    [규칙 - 기본]
    - 사용자 query와 가장 관련 있는 도서를 선별하세요.
    - 각 도서에 relevance 점수(0~100)를 부여하세요.
    - **relevance를 점수의 최우선 기준으로 삼으세요.**
    - relevance가 50 미만인 도서는 출력에서 제외하세요.

    [규칙 - 피드백 정보 활용]
    - 피드백 정보는 **참고 자료**로 활용하세요.
    - 피드백이 있는 도서는 **검증된 도서**로 판단할 수 있습니다.
    - 하지만 피드백이 없다고 해서 relevance가 높은 도서를 배제하지 마세요.
    - 특히 신간 도서는 피드백이 없더라도 내용의 관련성을 중요하게 평가하세요.

    [피드백 정보 해석 가이드]
    - 긍정 피드백 80% 이상: "사용자들이 만족한 검증된 도서"
    - 긍정 피드백 50~79%: "대체로 긍정적인 평가"
    - 긍정 피드백 20~49%: "평가가 엇갈리는 도서"
    - 긍정 피드백 20% 미만: "부정적인 평가가 많음"

    [규칙 - 피드백 유의사항]
    - 피드백이 너무 적은 도서(3건 미만)는 "데이터 부족"으로 간주하세요.
    - 피드백 없는 도서는 "신간 또는 리뷰가 적은 도서"로 간주하세요.
    - 피드백 수가 적더라도 relevance가 높으면 추천하세요.

    [추천 사유 작성 가이드]
    - relevance가 높은 도서: "query와 직접적으로 관련 있음" 강조
    - 피드백이 좋은 도서: "사용자들이 만족한 도서" 추가 언급 가능
    - 피드백이 없는 신간: "최신 도서로 아직 피드백이 적지만 내용이 적합함" 언급

    [도서 데이터]
    %s

    query: %s
    """;
```

---

#### 실제 프롬프트 예시

```java
// 피드백 정보를 도서 데이터에 포함
StringBuilder context = new StringBuilder();
for (BookSearchResponse book : books) {
    // 기본 정보
    bookContext.append(String.format(
        "ID: %d, 제목: %s, 저자: %s, 출판일: %s, 내용: %s",
        book.getId(), book.getTitle(), book.getAuthorName(),
        book.getEditionPublishDate(), book.getBookContent()
    ));

    // 피드백 정보가 있으면 추가 (필수 아님)
    if (book.getFeedbackStats() != null && book.getFeedbackStats().getTotalCount() >= 3) {
        bookContext.append(String.format(
            ", 피드백: 긍정 %d건/부정 %d건 (긍정률 %.0f%%)",
            book.getFeedbackStats().getGoodCount(),
            book.getFeedbackStats().getBadCount(),
            book.getFeedbackStats().getGoodRatio() * 100
        ));
    }
    // 피드백이 없으면 추가하지 않음 (LLLM이 판단하도록 남김)
}
```

---

#### 프롬프트 작성 시 주의사항

| 항목 | ❌ 피해야 할 것 | ✅ 권장하는 것 |
|------|----------------|---------------|
| **목표 설정** | "피드백 순으로 추천" | "Relevance 우선, 피드백 참고" |
| **피드백 없는 도서** | "제외" 또는 "최하위 배치" | "내용 기반으로 평가, 신간 우려" |
| **피드백 해석** | "점수가 높으면 무조건 상위" | "검증된 도서로 신뢰도 가중" |
| **강조 정도** | "무조건", "반드시", "항상" | "참고", "고려", "가능하면" |

---

#### LLM의 역할과 한계 인식

**LLM이 잘하는 것:**
- ✅ Query와 도서 내용의 관련성(relevance) 판단
- ✅ 사용자의 의도를 이해하고 맞춤형 설명
- ✅ 피드백 정보를 문맥(context)으로 활용한 균형 잡힌 추천

**LLM이 잘 못하는 것 (단순 정렬):**
- ❌ 피드백 순서대로 나열 (이건 자바 코드로 하는 게 낫음)
- ❌ 피드백 수치만 보고 기계적인 판단
- ❌ 신간 도서 배제 (피드백이 없다는 이유로)

---

#### 구현 예시: 실제 코드 기반 전체 프롬프트

실제 프로젝트의 `AiRecommendationService` 코드를 분석한 전체 프롬프트 예시입니다.

---

##### 전체 프롬프트 템플릿

```java
String template = """
    [규칙]
    - 사용자가 제공하는 query와 가장 관련 있는 도서를 선별하세요.
    - 각 도서에 대해 relevance 점수(0~100)를 부여하세요:
      - 90–100: query와 직접적으로 강하게 연관, 주제 적합성이 매우 높음
      - 70–89: query와 밀접하게 관련 있지만 일부 범위가 제한적임
      - 50–69: query와 간접적으로 관련, 배경 지식에 도움이 됨
      - 50 미만: 관련성이 낮으므로 출력에서 제외
    - 추천 사유("why")에는 점수를 포함하지 말고, 순수하게 이유만 설명하세요.
    - 추천 사유("why")는 사용자에게 친절하고 공손한 어투(예: "~입니다", "~를 추천해 드립니다")로 작성하세요.
    - 추천 사유를 명확히 알 수 없는 경우에는 "추천 사유를 모름" 또는 "추천 사유를 명확히 알 수 없습니다"와 같이 명확하게 모른다는 표현을 사용하세요.
    - 최신 출간일과 query와의 직접적인 관련성을 함께 고려하세요.

    [규칙 - 리뷰 정보 반영]
    - 평점과 리뷰 수를 relevance 점수에 반영하세요:
      - 평점 4.5 이상 + 리뷰 20개 이상: relevance +5점 (검증된 인기 도서)
      - 평점 4.0 이상 + 리뷰 20개 이상: relevance +3점 (검증된 도서)
      - 평점 3.5 미만: relevance -10점 (부정적 평가)
      - 리뷰 없음: relevance ±0점 (변동 없음)

    - 평점이 4.0 이상인 도서를 우선적으로 고려하세요.
    - 리뷰가 20개 이상인 도서는 검증된 도서로 판단하고 신뢰도를 높게 평가하세요.
    - 리뷰 요약이 있는 경우, 요약의 내용을 참고하여 구체적인 추천 사유를 작성하세요.
      - 예: "리뷰어들이 '설명이 쉽고 실전 예제가 많다'고 평가했습니다."
    - 평점이 3.5 미만인 도서는 주의를 권장하세요.
      - 예: "평점이 3.2/5.0로 평가가 엇갈립니다. 리뷰 내용을 확인해보세요."
    - 리뷰가 없는 신간 도서는 "신간 도서로 아직 리뷰가 없습니다"라고 언급하고, 최신성과 내용의 관련성을 더 중요하게 평가하세요.

    [출력 형식]
    - 출력은 반드시 순수 JSON만 포함하세요.
    - 마크다운 코드 블록(```json ... ```)이나 추가 설명 텍스트는 절대 포함하지 마세요.
    - 언어는 반드시 한국어를 사용하세요.

    [JSON STRUCTURE]
     [
        {
          "id": 123,
          "relevance": 95,
          "why": "추천 사유"
        }
     ]

    - 결과는 relevance 기준 내림차순으로 정렬하세요.
    - 입력 데이터에 없는 필드는 추측하지 마세요.

    query: {question}

    도서 데이터:
    {context}
    """;
```

---

##### 실제 데이터 포맷팅 로직

```java
/**
 * 도서 정보를 LLM 프롬프트용으로 포맷팅
 */
private String buildBookContext(BookSearchResponse book) {
    StringBuilder bookContext = new StringBuilder();

    // 1. 기본 정보 (항상 포함)
    bookContext.append(String.format("ID: %d, 제목: %s, 저자: %s",
        book.getId(), book.getTitle(), book.getAuthorName()));

    // 2. 평점 정보 (조건부 포함)
    String ratingInfo = formatRatingInfo(book);
    if (!ratingInfo.isEmpty()) {
        bookContext.append(", ").append(ratingInfo);
    }
    // 리뷰 없으면 아무것도 추가하지 않음

    // 3. 리뷰 요약 (조건부 포함, 100자 제한)
    String summaryInfo = formatReviewSummary(book.getReviewSummary());
    if (!summaryInfo.isEmpty()) {
        bookContext.append(", ").append(summaryInfo);
    }
    // 요약 없으면 아무것도 추가하지 않음

    // 4. 출판일과 내용 (항상 포함)
    bookContext.append(String.format(", 출판일: %s, 내용: %s",
        book.getEditionPublishDate() != null ? book.getEditionPublishDate().toString() : "알 수 없음",
        book.getBookContent() != null ? book.getBookContent() : "내용 없음"));

    return bookContext.toString();
}

/**
 * 평점 정보 포맷팅
 * @return "평점: 4.8/5.0(127개 리뷰)" 또는 빈 문자열
 */
private String formatRatingInfo(BookSearchResponse book) {
    if (book.getAverageRating() != null
            && book.getReviewCount() != null
            && book.getReviewCount() > 0) {
        return String.format("평점: %.1f/5.0(%d개 리뷰)",
            book.getAverageRating(),
            book.getReviewCount());
    }
    return "";  // 리뷰 없으면 빈 문자열
}

/**
 * 리뷰 요약 포맷팅
 * @return "요약: '리뷰 내용...'" 또는 빈 문자열
 */
private String formatReviewSummary(String summary) {
    if (summary == null || summary.isBlank()) {
        return "";  // 요약 없으면 빈 문자열
    }

    // 100자 제한
    String truncated = summary.length() > 100
        ? summary.substring(0, 100) + "..."
        : summary;

    return String.format("요약: \"%s\"", truncated);
}
```

---

##### 실제 프롬프트 예시 (검색어: "해리포터")

```
[규칙]
- 사용자가 제공하는 query와 가장 관련 있는 도서를 선별하세요.
- 각 도서에 대해 relevance 점수(0~100)를 부여하세요:
  - 90–100: query와 직접적으로 강하게 연관, 주제 적합성이 매우 높음
  - 70–89: query와 밀접하게 관련 있지만 일부 범위가 제한적임
  - 50–69: query와 간접적으로 관련, 배경 지식에 도움이 됨
  - 50 미만: 관련성이 낮으므로 출력에서 제외
- 추천 사유("why")에는 점수를 포함하지 말고, 순수하게 이유만 설명하세요.
- 추천 사유("why")는 사용자에게 친절하고 공손한 어투(예: "~입니다", "~를 추천해 드립니다")로 작성하세요.
- 추천 사유를 명확히 알 수 없는 경우에는 "추천 사유를 모름" 또는 "추천 사유를 명확히 알 수 없습니다"와 같이 명확하게 모른다는 표현을 사용하세요.
- 최신 출간일과 query와의 직접적인 관련성을 함께 고려하세요.

[규칙 - 리뷰 정보 반영]
- 평점과 리뷰 수를 relevance 점수에 반영하세요:
  - 평점 4.5 이상 + 리뷰 20개 이상: relevance +5점 (검증된 인기 도서)
  - 평점 4.0 이상 + 리뷰 20개 이상: relevance +3점 (검증된 도서)
  - 평점 3.5 미만: relevance -10점 (부정적 평가)
  - 리뷰 없음: relevance ±0점 (변동 없음)

- 평점이 4.0 이상인 도서를 우선적으로 고려하세요.
- 리뷰가 20개 이상인 도서는 검증된 도서로 판단하고 신뢰도를 높게 평가하세요.
- 리뷰 요약이 있는 경우, 요약의 내용을 참고하여 구체적인 추천 사유를 작성하세요.
  - 예: "리뷰어들이 '설명이 쉽고 실전 예제가 많다'고 평가했습니다."
- 평점이 3.5 미만인 도서는 주의를 권장하세요.
  - 예: "평점이 3.2/5.0로 평가가 엇갈립니다. 리뷰 내용을 확인해보세요."
- 리뷰가 없는 신간 도서는 "신간 도서로 아직 리뷰가 없습니다"라고 언급하고, 최신성과 내용의 관련성을 더 중요하게 평가하세요.

[출력 형식]
- 출력은 반드시 순수 JSON만 포함하세요.
- 마크다운 코드 블록(```json ... ```)이나 추가 설명 텍스트는 절대 포함하지 마세요.
- 언어는 반드시 한국어를 사용하세요.

[JSON STRUCTURE]
 [
    {
      "id": 123,
      "relevance": 95,
      "why": "추천 사유"
    }
 ]

- 결과는 relevance 기준 내림차순으로 정렬하세요.
- 입력 데이터에 없는 필드는 추측하지 마세요.

query: 해리포터

도서 데이터:
ID: 101, 제목: 해리포터와 마법사의 돌, 저자: J.K. 롤링, 평점: 4.8/5.0(127개 리뷰), 요약: "초보자에게 정말 좋습니다. 설명이 쉽고...", 출판일: 2020-01-01, 내용: 해리포터의 첫 번째 이야기...
ID: 102, 제목: 해리포터와 비밀의 방, 저자: J.K. 롤링, 평점: 4.6/5.0(89개 리뷰), 요약: "전개가 좋고 미스터리가 심도 있습니다.", 출판일: 2020-05-01, 내용: 해리포터의 두 번째 이야기...
ID: 103, 제목: 해리포터와 아즈카반의 죄수, 저자: J.K. 롤링, 출판일: 2021-03-01, 내용: 해리포터의 세 번째 이야기...
ID: 104, 제목: 주식 투자를 위한 기초 분석, 저자: 김철수, 출판일: 2023-07-15, 내용: 주식의 기본 개념을 설명합니다...
ID: 105, 제목: 신간 SQL 완전 정복, 저자: 박민수, 출판일: 2024-10-10, 내용: 최신 SQL 기능을 다룹니다...
```

---

##### LLM이 수신하는 실제 데이터 분석

**리뷰 있는 도서 (ID: 101, 102)**
- 평점/리뷰 수/요약 정보가 모두 포함됨
- LLM이 구체적인 사용자 피드백을 참고 가능
- +5점 또는 +3점 보너스를 relevance 점수에 반영할 수 있음

**리뷰 없는 도서 (ID: 103)**
- 평점/요약 정보가 없음
- LLM이 내용 기반으로만 relevance 판단
- "신간 도서"로 간주되거나 무관하게 판단

**검색어와 무관한 도서 (ID: 104, 105)**
- "해리포터" 검색인데 주책 관련 도서도 포함됨 (하이브리드 검색 결과)
- LLM이 relevance를 낮게 판단하고 제외할 가능성 높음
- 피드백 정보가 있어도 relevance 50 미만이면 제외됨

---

##### 핵심 설계 포인트

1. **조건부 포함**: 리뷰 정보가 있을 때만 프롬프트에 추가
2. **데이터 누락 방지**: 리뷰가 없는 도서를 "불완전한 데이터"로 표시하지 않음
3. **토큰 최적화**: 요약을 100자로 제한하여 프롬프트 길이 관리
4. **명시적 점수 규칙**: "+5점", "+3점", "-10점"으로 LLM에 가이드라인 제공
5. **우선순위 명시**: "평점 4.0 이상인 도서를 우선적으로 고려"로 신뢰도 강조

---

**핵심 메서드:**
- 피드백 정보를 프롬프트에 자연스럽게 통합
- "무조건 우선" 지양, "참고 자료"로 활용
- 피드백 없는 도서의 기회 보장

---

## 다음 단계

- [Step 5-4: 피드백 UI & Callback Handler](./04.feedback-ui-callback-handler.md)
- [Step 5-5: 피드백 검색 통합 전략](./05.feedback-search-integration.md)

---

## 참고 자료

- [OpenAI Prompt Engineering Guide](https://platform.openai.com/docs/guides/prompt-engineering)
- [Anthropic Prompt Library](https://docs.anthropic.com/claude/prompt-library)
