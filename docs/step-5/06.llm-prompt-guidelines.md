### 3. AI 프롬프트 개선

**개념:** 피드백 정보를 LLM에게 **참고 자료(Context)**로 제공하여 지능적인 추천 가능하게 함

**⚠️ 중요: LLM에게 단순히 "피드백이 높은 순서대로 추천해달라"고 하면 안 됩니다!**

```
❌ 나쁜 예시:
"피드백이 높은 도서를 무조건 상위에 배치하세요."
→ LLM이 relevance 판단을 포기하고 피드백 순서대로 반환
→ 신간 도서(피드백 없음)은 영원히 기회를 얻지 못함
→ 피드백 편향(Bias)이 강화되어 검색 품질 저하

✅ 좋은 예시:
"피드백 정보를 참고하여 추천하되, relevance(관련성)을 최우선으로 고려하세요."
→ LLM이 피드백을 하나의 참고 자료로 활용
→ 여전히 relevance를 기반으로 지능적으로 판단
→ 피드백이 없는 신간 도서도 기회를 얻을 수 있음
```

---

#### 올바른 프롬프트 전략

**핵심 원칙: Relevance 우선, 피드백은 보조 정보**

```java
String template = """
    [규칙 - 기본]
    - 사용자 query와 가장 관련 있는 도서를 선별하세요.
    - 각 도서에 relevance 점수(0~100)를 부여하세요.
    - **relevance를 점수의 최우선 기준으로 삼으세요.**
    - relevance가 50 미만인 도서는 출력에서 제외하세요.

    [규칙 - 피드백 정보 활용]
    - 피드백 정보는 **참고 자료**로 활용하세요.
    - 피드백이 있는 도서는 **검증된 도서**로 판단할 수 있습니다.
    - 하지만 피드백이 없다고 해서 relevance가 높은 도서를 배제하지 마세요.
    - 특히 신간 도서는 피드백이 없더라도 내용의 관련성을 중요하게 평가하세요.

    [피드백 정보 해석 가이드]
    - 긍정 피드백 80% 이상: "사용자들이 만족한 검증된 도서"
    - 긍정 피드백 50~79%: "대체로 긍정적인 평가"
    - 긍정 피드백 20~49%: "평가가 엇갈리는 도서"
    - 긍정 피드백 20% 미만: "부정적인 평가가 많음"

    [규칙 - 피드백 유의사항]
    - 피드백이 너무 적은 도서(3건 미만)는 "데이터 부족"으로 간주하세요.
    - 피드백 없는 도서는 "신간 또는 리뷰가 적은 도서"로 간주하세요.
    - 피드백 수가 적더라도 relevance가 높으면 추천하세요.

    [추천 사유 작성 가이드]
    - relevance가 높은 도서: "query와 직접적으로 관련 있음" 강조
    - 피드백이 좋은 도서: "사용자들이 만족한 도서" 추가 언급 가능
    - 피드백이 없는 신간: "최신 도서로 아직 피드백이 적지만 내용이 적합함" 언급

    [도서 데이터]
    %s

    query: %s
    """;
```

---

#### 실제 프롬프트 예시

```java
// 피드백 정보를 도서 데이터에 포함
StringBuilder context = new StringBuilder();
for (BookSearchResponse book : books) {
    // 기본 정보
    bookContext.append(String.format(
        "ID: %d, 제목: %s, 저자: %s, 출판일: %s, 내용: %s",
        book.getId(), book.getTitle(), book.getAuthorName(),
        book.getEditionPublishDate(), book.getBookContent()
    ));

    // 피드백 정보가 있으면 추가 (필수 아님)
    if (book.getFeedbackStats() != null && book.getFeedbackStats().getTotalCount() >= 3) {
        bookContext.append(String.format(
            ", 피드백: 긍정 %d건/부정 %d건 (긍정률 %.0f%%)",
            book.getFeedbackStats().getGoodCount(),
            book.getFeedbackStats().getBadCount(),
            book.getFeedbackStats().getGoodRatio() * 100
        ));
    }
    // 피드백이 없으면 추가하지 않음 (LLLM이 판단하도록 남김)
}
```

---

#### 프롬프트 작성 시 주의사항

| 항목 | ❌ 피해야 할 것 | ✅ 권장하는 것 |
|------|----------------|---------------|
| **목표 설정** | "피드백 순으로 추천" | "Relevance 우선, 피드백 참고" |
| **피드백 없는 도서** | "제외" 또는 "최하위 배치" | "내용 기반으로 평가, 신간 우려" |
| **피드백 해석** | "점수가 높으면 무조건 상위" | "검증된 도서로 신뢰도 가중" |
| **강조 정도** | "무조건", "반드시", "항상" | "참고", "고려", "가능하면" |

---

#### LLM의 역할과 한계 인식

**LLM이 잘하는 것:**
- ✅ Query와 도서 내용의 관련성(relevance) 판단
- ✅ 사용자의 의도를 이해하고 맞춤형 설명
- ✅ 피드백 정보를 문맥(context)으로 활용한 균형 잡힌 추천

**LLM이 잘 못하는 것 (단순 정렬):**
- ❌ 피드백 순서대로 나열 (이건 자바 코드로 하는 게 낫음)
- ❌ 피드백 수치만 보고 기계적인 판단
- ❌ 신간 도서 배제 (피드백이 없다는 이유로)

---

#### 구현 예시: 실제 코드 기반 전체 프롬프트

실제 프로젝트의 `AiRecommendationService` 코드를 분석한 전체 프롬프트 예시입니다.

---

##### 전체 프롬프트 템플릿

```java
String template = """
    [규칙]
    - 사용자가 제공하는 query와 가장 관련 있는 도서를 선별하세요.
    - 각 도서에 대해 relevance 점수(0~100)를 부여하세요:
      - 90–100: query와 직접적으로 강하게 연관, 주제 적합성이 매우 높음
      - 70–89: query와 밀접하게 관련 있지만 일부 범위가 제한적임
      - 50–69: query와 간접적으로 관련, 배경 지식에 도움이 됨
      - 50 미만: 관련성이 낮으므로 출력에서 제외
    - 추천 사유("why")에는 점수를 포함하지 말고, 순수하게 이유만 설명하세요.
    - 추천 사유("why")는 사용자에게 친절하고 공손한 어투(예: "~입니다", "~를 추천해 드립니다")로 작성하세요.
    - 추천 사유를 명확히 알 수 없는 경우에는 "추천 사유를 모름" 또는 "추천 사유를 명확히 알 수 없습니다"와 같이 명확하게 모른다는 표현을 사용하세요.
    - 최신 출간일과 query와의 직접적인 관련성을 함께 고려하세요.

    [규칙 - 리뷰 정보 반영]
    - 평점과 리뷰 수를 relevance 점수에 반영하세요:
      - 평점 4.5 이상 + 리뷰 20개 이상: relevance +5점 (검증된 인기 도서)
      - 평점 4.0 이상 + 리뷰 20개 이상: relevance +3점 (검증된 도서)
      - 평점 3.5 미만: relevance -10점 (부정적 평가)
      - 리뷰 없음: relevance ±0점 (변동 없음)

    - 평점이 4.0 이상인 도서를 우선적으로 고려하세요.
    - 리뷰가 20개 이상인 도서는 검증된 도서로 판단하고 신뢰도를 높게 평가하세요.
    - 리뷰 요약이 있는 경우, 요약의 내용을 참고하여 구체적인 추천 사유를 작성하세요.
      - 예: "리뷰어들이 '설명이 쉽고 실전 예제가 많다'고 평가했습니다."
    - 평점이 3.5 미만인 도서는 주의를 권장하세요.
      - 예: "평점이 3.2/5.0로 평가가 엇갈립니다. 리뷰 내용을 확인해보세요."
    - 리뷰가 없는 신간 도서는 "신간 도서로 아직 리뷰가 없습니다"라고 언급하고, 최신성과 내용의 관련성을 더 중요하게 평가하세요.

    [출력 형식]
    - 출력은 반드시 순수 JSON만 포함하세요.
    - 마크다운 코드 블록(```json ... ```)이나 추가 설명 텍스트는 절대 포함하지 마세요.
    - 언어는 반드시 한국어를 사용하세요.

    [JSON STRUCTURE]
     [
        {
          "id": 123,
          "relevance": 95,
          "why": "추천 사유"
        }
     ]

    - 결과는 relevance 기준 내림차순으로 정렬하세요.
    - 입력 데이터에 없는 필드는 추측하지 마세요.

    query: {question}

    도서 데이터:
    {context}
    """;
```

---

##### 실제 데이터 포맷팅 로직

```java
/**
 * 도서 정보를 LLM 프롬프트용으로 포맷팅
 */
private String buildBookContext(BookSearchResponse book) {
    StringBuilder bookContext = new StringBuilder();

    // 1. 기본 정보 (항상 포함)
    bookContext.append(String.format("ID: %d, 제목: %s, 저자: %s",
        book.getId(), book.getTitle(), book.getAuthorName()));

    // 2. 평점 정보 (조건부 포함)
    String ratingInfo = formatRatingInfo(book);
    if (!ratingInfo.isEmpty()) {
        bookContext.append(", ").append(ratingInfo);
    }
    // 리뷰 없으면 아무것도 추가하지 않음

    // 3. 리뷰 요약 (조건부 포함, 100자 제한)
    String summaryInfo = formatReviewSummary(book.getReviewSummary());
    if (!summaryInfo.isEmpty()) {
        bookContext.append(", ").append(summaryInfo);
    }
    // 요약 없으면 아무것도 추가하지 않음

    // 4. 출판일과 내용 (항상 포함)
    bookContext.append(String.format(", 출판일: %s, 내용: %s",
        book.getEditionPublishDate() != null ? book.getEditionPublishDate().toString() : "알 수 없음",
        book.getBookContent() != null ? book.getBookContent() : "내용 없음"));

    return bookContext.toString();
}

/**
 * 평점 정보 포맷팅
 * @return "평점: 4.8/5.0(127개 리뷰)" 또는 빈 문자열
 */
private String formatRatingInfo(BookSearchResponse book) {
    if (book.getAverageRating() != null
            && book.getReviewCount() != null
            && book.getReviewCount() > 0) {
        return String.format("평점: %.1f/5.0(%d개 리뷰)",
            book.getAverageRating(),
            book.getReviewCount());
    }
    return "";  // 리뷰 없으면 빈 문자열
}

/**
 * 리뷰 요약 포맷팅
 * @return "요약: '리뷰 내용...'" 또는 빈 문자열
 */
private String formatReviewSummary(String summary) {
    if (summary == null || summary.isBlank()) {
        return "";  // 요약 없으면 빈 문자열
    }

    // 100자 제한
    String truncated = summary.length() > 100
        ? summary.substring(0, 100) + "..."
        : summary;

    return String.format("요약: \"%s\"", truncated);
}
```

---

##### 실제 프롬프트 예시 (검색어: "해리포터")

```
[규칙]
- 사용자가 제공하는 query와 가장 관련 있는 도서를 선별하세요.
- 각 도서에 대해 relevance 점수(0~100)를 부여하세요:
  - 90–100: query와 직접적으로 강하게 연관, 주제 적합성이 매우 높음
  - 70–89: query와 밀접하게 관련 있지만 일부 범위가 제한적임
  - 50–69: query와 간접적으로 관련, 배경 지식에 도움이 됨
  - 50 미만: 관련성이 낮으므로 출력에서 제외
- 추천 사유("why")에는 점수를 포함하지 말고, 순수하게 이유만 설명하세요.
- 추천 사유("why")는 사용자에게 친절하고 공손한 어투(예: "~입니다", "~를 추천해 드립니다")로 작성하세요.
- 추천 사유를 명확히 알 수 없는 경우에는 "추천 사유를 모름" 또는 "추천 사유를 명확히 알 수 없습니다"와 같이 명확하게 모른다는 표현을 사용하세요.
- 최신 출간일과 query와의 직접적인 관련성을 함께 고려하세요.

[규칙 - 리뷰 정보 반영]
- 평점과 리뷰 수를 relevance 점수에 반영하세요:
  - 평점 4.5 이상 + 리뷰 20개 이상: relevance +5점 (검증된 인기 도서)
  - 평점 4.0 이상 + 리뷰 20개 이상: relevance +3점 (검증된 도서)
  - 평점 3.5 미만: relevance -10점 (부정적 평가)
  - 리뷰 없음: relevance ±0점 (변동 없음)

- 평점이 4.0 이상인 도서를 우선적으로 고려하세요.
- 리뷰가 20개 이상인 도서는 검증된 도서로 판단하고 신뢰도를 높게 평가하세요.
- 리뷰 요약이 있는 경우, 요약의 내용을 참고하여 구체적인 추천 사유를 작성하세요.
  - 예: "리뷰어들이 '설명이 쉽고 실전 예제가 많다'고 평가했습니다."
- 평점이 3.5 미만인 도서는 주의를 권장하세요.
  - 예: "평점이 3.2/5.0로 평가가 엇갈립니다. 리뷰 내용을 확인해보세요."
- 리뷰가 없는 신간 도서는 "신간 도서로 아직 리뷰가 없습니다"라고 언급하고, 최신성과 내용의 관련성을 더 중요하게 평가하세요.

[출력 형식]
- 출력은 반드시 순수 JSON만 포함하세요.
- 마크다운 코드 블록(```json ... ```)이나 추가 설명 텍스트는 절대 포함하지 마세요.
- 언어는 반드시 한국어를 사용하세요.

[JSON STRUCTURE]
 [
    {
      "id": 123,
      "relevance": 95,
      "why": "추천 사유"
    }
 ]

- 결과는 relevance 기준 내림차순으로 정렬하세요.
- 입력 데이터에 없는 필드는 추측하지 마세요.

query: 해리포터

도서 데이터:
ID: 101, 제목: 해리포터와 마법사의 돌, 저자: J.K. 롤링, 평점: 4.8/5.0(127개 리뷰), 요약: "초보자에게 정말 좋습니다. 설명이 쉽고...", 출판일: 2020-01-01, 내용: 해리포터의 첫 번째 이야기...
ID: 102, 제목: 해리포터와 비밀의 방, 저자: J.K. 롤링, 평점: 4.6/5.0(89개 리뷰), 요약: "전개가 좋고 미스터리가 심도 있습니다.", 출판일: 2020-05-01, 내용: 해리포터의 두 번째 이야기...
ID: 103, 제목: 해리포터와 아즈카반의 죄수, 저자: J.K. 롤링, 출판일: 2021-03-01, 내용: 해리포터의 세 번째 이야기...
ID: 104, 제목: 주식 투자를 위한 기초 분석, 저자: 김철수, 출판일: 2023-07-15, 내용: 주식의 기본 개념을 설명합니다...
ID: 105, 제목: 신간 SQL 완전 정복, 저자: 박민수, 출판일: 2024-10-10, 내용: 최신 SQL 기능을 다룹니다...
```

---

##### LLM이 수신하는 실제 데이터 분석

**리뷰 있는 도서 (ID: 101, 102)**
- 평점/리뷰 수/요약 정보가 모두 포함됨
- LLM이 구체적인 사용자 피드백을 참고 가능
- +5점 또는 +3점 보너스를 relevance 점수에 반영할 수 있음

**리뷰 없는 도서 (ID: 103)**
- 평점/요약 정보가 없음
- LLM이 내용 기반으로만 relevance 판단
- "신간 도서"로 간주되거나 무관하게 판단

**검색어와 무관한 도서 (ID: 104, 105)**
- "해리포터" 검색인데 주책 관련 도서도 포함됨 (하이브리드 검색 결과)
- LLM이 relevance를 낮게 판단하고 제외할 가능성 높음
- 피드백 정보가 있어도 relevance 50 미만이면 제외됨

---

##### 핵심 설계 포인트

1. **조건부 포함**: 리뷰 정보가 있을 때만 프롬프트에 추가
2. **데이터 누락 방지**: 리뷰가 없는 도서를 "불완전한 데이터"로 표시하지 않음
3. **토큰 최적화**: 요약을 100자로 제한하여 프롬프트 길이 관리
4. **명시적 점수 규칙**: "+5점", "+3점", "-10점"으로 LLM에 가이드라인 제공
5. **우선순위 명시**: "평점 4.0 이상인 도서를 우선적으로 고려"로 신뢰도 강조

---

**핵심 메서드:**
- 피드백 정보를 프롬프트에 자연스럽게 통합
- "무조건 우선" 지양, "참고 자료"로 활용
- 피드백 없는 도서의 기회 보장

---

### 4. 품질 분석

**개념:** 검색어별 품질 보고서 생성

**활용:**
- 어떤 검색어가 결과가 좋은지/안좋은지 분석
- 개선이 필요한 검색어 식별
- 시스템 품질 모니터링

**핵심 메서드:**
- 품질 보고서 생성
- 전체 긍정률, 검색어별 그룹화, 긍정률이 낮은 검색어 TOP 5

---

### 5. A/B 테스트

**개념:** 피드백 반영 전/후 효과 측정

**그룹 할당:**
```
사용자 A (chatId=123) → 해시값 → 짝수 → 피드백 반영 그룹
사용자 B (chatId=456) → 해시값 → 홀수 → 통제 그룹
```

**핵심 메서드:**
- 그룹 할당 (50:50)
- A/B 그룹별 긍정률 비교

---

## 피드백 루프 아키텍처

```
┌─────────────────────────────────────────────────────────┐
│                    사용자                                │
│  ┌──────────┐                                          │
│  │ 검색 요청 │                                          │
│  └─────┬────┘                                          │
│        │                                                │
│        ▼                                                │
│  ┌──────────────────────────────────────────────┐      │
│  │        검색 결과 + Inline Keyboard            │      │
│  │  [도서 목록]                                  │      │
│  │  [👍 도움이 됨] [👎 도움이 안됨]              │      │
│  └───────────────┬──────────────────────────────┘      │
│                  │                                      │
│                  ▼                                      │
│  ┌──────────────────────────────────────────────┐      │
│  │           버튼 클릭 (피드백)                  │      │
│  └───────────────┬──────────────────────────────┘      │
└──────────────────┼─────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│              피드백 데이터 수집                          │
│  CallbackQueryHandler → FeedbackService → Repository    │
└──────────────────────────┬──────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                 피드백 분석                             │
│  • 긍정/부정 비율 계산  • 검색어별 품질 분석            │
│  • 사용자별 선호도 분석                                 │
└──────────────────────────┬──────────────────────────────┘
                           │
           ┌───────────────┼───────────────┐
           │               │               │
           ▼               ▼               ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  재정렬      │  │  개인화      │  │  프롬프트    │
│  (Ranking)   │  │  (Personal)  │  │  개선       │
│              │  │              │  │              │
│ [긍정 피드백 │  │ [사용자가    │  │ [통계를 LLM  │
│  많은 도서   │  │  좋아하는    │  │  에 전달]    │
│  상위 표시]  │  │  도서 추천]  │  │              │
└──────┬───────┘  └──────┬───────┘  └──────┬───────┘
       │                 │                 │
       └─────────────────┼─────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│               개선된 검색 결과                           │
│  • 더 관련성 높은 도서  • 개인화된 추천                 │
│  • 더 정확한 AI 추천 사유                               │
└──────────────────────────┬──────────────────────────────┘
                           │
                           ▼
                    ┌──────┴──────┐
                    │   사용자     │ (루프 계속)
                    └─────────────┘
```

---

## 구현 단계

### Phase 1: 데이터 계층 (1시간)

- [ ] SearchFeedback Entity 작성
- [ ] SearchFeedbackRepository 인터페이스 정의
- [ ] DDL로 테이블 생성 확인

**학습 포인트:**
- JPA 어노테이션 (@Entity, @Table, @Index)
- Enum 처리 (@Enumerated)
- 생명주기 콜백 (@PrePersist)

---

### Phase 2: 비즈니스 계층 (1시간)

- [ ] FeedbackRequest, FeedbackStats DTO 작성
- [ ] FeedbackService 인터페이스 설계
- [ ] FeedbackServiceImpl 구현

**학습 포인트:**
- record 활용
- Validation 어노테이션
- @Transactional 트랜잭션 관리

---

### Phase 3: UI 계층 (1.5시간)

- [ ] TelegramKeyboardFactory 작성
- [ ] CallbackQueryHandler 작성
- [ ] LibraryTelegramBot 수정

**학습 포인트:**
- Inline Keyboard 구조
- Callback 데이터 파싱
- EditMessageText 활용

---

### Phase 4: 관리자 API (30분)

- [ ] FeedbackAdminController 작성
- [ ] API 테스트

**학습 포인트:**
- REST API 설계
- @RequestParam, @PathVariable

---

### Phase 5: AI 활용 연동 (1시간)

- [ ] 피드백 기반 재정렬 Service 설계
- [ ] 개인화 Service 설계
- [ ] 프롬프트 개선 Service 설계
- [ ] 품질 분석 Service 설계
- [ ] A/B 테스트 Service 설계

**학습 포인트:**
- 피드백 루프 설계
- 데이터 기반 AI 개선
- A/B 테스트 설계

---

### Phase 6: 통합 테스트 (30분)

- [ ] 전체 플로우 테스트
- [ ] 에러 처리 확인
- [ ] 로그 확인

**총 예상 시간: 약 5시간**

---

## 패키지 구조

```
src/main/java/com/.../telegram/
├── entity/
│   └── SearchFeedback.java
├── repository/
│   └── SearchFeedbackRepository.java
├── dto/
│   ├── FeedbackRequest.java
│   └── FeedbackStats.java
├── service/
│   ├── FeedbackService.java
│   ├── FeedbackServiceImpl.java
│   ├── FeedbackAwareRankingService.java
│   ├── PersonalizedRecommendationService.java
│   ├── FeedbackEnhancedAiPromptService.java
│   ├── SearchQualityAnalyticsService.java
│   └── FeedbackAbTestService.java
├── keyboard/
│   └── TelegramKeyboardFactory.java
├── handler/
│   └── CallbackQueryHandler.java
└── api/
    └── FeedbackAdminController.java
```

---

## 사용 예시

### 1. 피드백 요청

```
User: 해리포터

Bot: 📚 "해리포터" 검색 결과

     🤖 AI 추천 사유
     💬 해리포터 시리즈의 첫 번째 책으로...

     검색된 도서 (3개)

     💡 검색 결과가 도움이 되셨나요?
     아래 버튼으로 피드백을 주시면 검색 품질 개선에 참고하겠습니다!

     1. 해리포터와 마법사의 돌
     📖 조앤 K. 롤링
     🎯 유사도: 85.50%

     [👍 좋았음] [👎 별로였음]
```

### 2. 피드백 제출

```
User: [👍 좋았음] 클릭

Bot: ✅ 소중한 피드백 감사합니다!

     검색 품질 개선에 활용하겠습니다.
```

### 3. 관리자 API

```bash
# 통계 조회
curl "http://localhost:8080/api/admin/feedback/stats?query=해리포터"

응답:
{
  "goodCount": 15,
  "badCount": 2,
  "totalCount": 17,
  "goodRatio": 0.882,
  "feedbackScore": 0.764
}
```

---

## 학습 체크리스트

### 필수 구현 사항

- [ ] JPA Entity 설계
- [ ] Repository 인터페이스 정의
- [ ] Service 인터페이스 및 구현
- [ ] DTO 설계
- [ ] Inline Keyboard 생성
- [ ] Callback Query 처리
- [ ] Bot 연동
- [ ] Admin API 설계 및 구현

### 도전 과제

#### 기본 과제
- [ ] 피드백 중복 방지
- [ ] 피드백 익명화
- [ ] 피드백 내보내기 (CSV)

#### AI 활용 과제 (추천)
- [ ] 피드백 기반 검색 재정렬
- [ ] 사용자 선호 기반 개인화
- [ ] 피드백 통계를 AI 프롬프트에 포함
- [ ] 검색 품질 분석 보고서
- [ ] A/B 테스트로 효과 측정

---

## 트러블슈팅

### 1. Inline Keyboard가 표시되지 않음

**원인:** `replyMarkup` 설정 누락
**해결:** `SendMessage.builder().replyMarkup(keyboard).build()` 확인

### 2. Callback 데이터 파싱 오류

**원인:** 특수문자(`:`) 처리 미흡
**해결:** URL 인코딩/디코딩 사용

### 3. JPA Entity 생성 오류

**원인:** 기본 생성자 누락
**해결:** `@NoArgsConstructor(access = AccessLevel.PROTECTED)` 추가

### 4. 트랜잭션 롤백 문제

**원인:** `@Transactional` 누락
**해결:** Service 메서드에 `@Transactional` 추가

---

## Step 5 완료

이제 다음 기능이 완료되었습니다:

- ✅ Telegram Bot 기본 설정
- ✅ RAG 검색 연동
- ✅ 사용자 피드백 수집
- ✅ **피드백 기반 AI 개선 루프**

**축하합니다!** AI 기반 검색 시스템에 사용자 피드백 기능을 구축하고, 피드백 데이터를 활용하여 AI를 지속적으로 개선하는 **피드백 루프(Feedback Loop)**를 완성했습니다.

### AI 시스템 개선의 핵심: 피드백 루프

```
사용자 → 검색 → 피드백 → 분석 → AI 개선 → 더 나은 검색 → 사용자
   ↑                                              ↓
   └──────────────── 더 나은 경험 ←────────────────┘
```

이 피드백 루프는 다음과 같은 AI 시스템의 핵심 원칙을 체험합니다:

1. **데이터 기반 의사결정**: 피드백 데이터를 분석하여 시스템 개선
2. **지속적 학습**: 사용자 피드백을 통해 시스템이 계속 발전
3. **개인화**: 사용자별 선호도를 학습하여 맞춤형 추천
4. **측정 가능성**: A/B 테스트로 개선 효과를 정량적으로 측정

---

## 다음 단계

- [Step 6: MCP 및 외부 서비스 연계](../step-6/01.understanding-mcp.md)
