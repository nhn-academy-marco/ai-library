# Telegram Bot 설정

## 개요

Step 1~4에서 구축한 하이브리드 검색 시스템을 Telegram Bot을 통해 사용할 수 있도록 구현합니다.

## 학습 목표

- Telegram Bot 기본 설정 이해
- Spring Boot와 외부 서비스 연동 경험
- Message Handling 기초

## 아키텍처

```
┌─────────────┐     ┌─────────────────────┐     ┌─────────────┐
│  Telegram   │ ──▶ │   Telegram Bot       │ ──▶ │  Search     │
│    User     │     │   (external/telegram)│     │  Service    │
└─────────────┘     └─────────────────────┘     └─────────────┘
                          │
                          ▼
                   ┌─────────────┐
                   │Redis Cache  │
                   │(범용 설정)  │
                   └─────────────┘
```

### 패키지 구조

```
com.nhnacademy.library
├── core/
│   └── config/
│       └── RedisConfig.java          # 범용 Redis 설정
└── external/                         # 외부 API 연동
    └── telegram/
        ├── bot/
        │   └── LibraryTelegramBot.java
        └── config/
            ├── TelegramBotConfig.java
            └── TelegramBotProperties.java
```

---

## Telegram Bot이란?

Telegram Bot은 Telegram 메신저 플랫폼에서 동작하는 자동화된 프로그램입니다.

### 특징
- **Long Polling**: Bot이 주기적으로 서버에 새 메시지를 요청
- **Webhook**: Telegram이 새 메시지가 올 때 지정한 URL로 호출
- **Inline Keyboard**: 버튼 형태의 사용자 인터페이스
- **Callback Query**: 버튼 클릭 등의 이벤트 처리

### 사용 이유
- 별도의 UI/UX 개발 불필요
- 사용자가 이미 익숙한 채팅 인터페이스
- 모바일 친화적
- 실시간 상호작용 가능

---

## Telegram 메시지 수신 방식

Telegram Bot에서 메시지를 수신하는 방식은 크게 **Long Polling**과 **Webhook** 두 가지가 있습니다.

### 1. Long Polling (롱 폴링)

**개념:**
- Bot이 **주기적으로** Telegram 서버에 "새 메시지가 있나요?"라고 요청하는 방식
- Telegram 서버는 새 메시지가 있으면 즉시 응답, 없으면 일정 시간 대기 후 타임아웃

**동작 원리:**
```
┌─────────────┐                  ┌─────────────┐
│  Bot App    │                  │  Telegram   │
│             │  ──[요청]──────▶  │   Server    │
│             │                  │             │
│  (대기중)   │                  │  (대기시작)  │
│             │  ◀──[응답]─────── │  (메시지)   │
│             │                  │   또는      │
│  (처리후)   │                  │  (타임아웃)  │
│             │  ──[요청]──────▶ │             │
└─────────────┘                  └─────────────┘
```

**장점:**
- 구현이 간단함 (공개 URL 불필요)
- 방화벽/네트워크 제약 없음
- 로컬 개발 환경에서 바로 사용 가능
- 서버 재시작이 용이함

**단점:**
- 메시지가 없어도 주기적으로 요청 전송 (리소스 낭비)
- 실시간성이 떨어질 수 있음 (폴링 간격에 따라)
- 대량의 트래픽 발생 가능

**구현 예시:**
```java
// telegrambots 라이브러리의 TelegramLongPollingBot 사용
public class LibraryTelegramBot extends TelegramLongPollingBot {
    @Override
    public void onUpdateReceived(Update update) {
        // 새 메시지가 도착하면 자동 호출됨
    }
}
```

---

### 2. Webhook (웹훅)

**개념:**
- Telegram 서버가 **새 메시지가 발생할 때마다** 미리 설정된 Bot의 URL로 호출해주는 방식
- 이벤트 기반 (Event-Driven) 아키텍처

**동작 원리:**
```
┌─────────────┐                  ┌─────────────┐
│  User       │                  │  Telegram   │
│  Message    │  ──[메시지]───▶  │   Server    │
└─────────────┘                  │             │
                                 │  ──[POST]──▶ ┌─────────────┐
                                 │   (Webhook)  │  Bot App     │
                                 │              │  (/telegram) │
                                 │              │             │
                                 │              │  (처리)      │
                                 │  ◀──[200]──── │             │
                                 └─────────────┘└─────────────┘
```

**장점:**
- 실시간 처리 (메시지 도착 즉시 전송)
- 불필요한 요청 없음 (리소스 효율적)
- 대규모 트래픽 처리에 적합
- 응답 시간 빠름

**단점:**
- 공개 URL (HTTPS) 필요
- SSL 인증서 요구 (Telegram 보안 정책)
- 방화벽/네트워크 설정 필요
- 로컬 개발 시 ngtm 등 터널링 도구 필요
- 서버 다운 시 메시지 유실 가능

**구현 예시:**
```java
@RestController
@RequestMapping("/telegram")
public class TelegramWebhookController {

    @PostMapping
    public ResponseEntity<Void> handleUpdate(@RequestBody Update update) {
        // Webhook으로 받은 Update 처리
        telegramBotService.processUpdate(update);
        return ResponseEntity.ok().build();
    }
}
```

**Webhook 설정:**
```bash
# Webhook 등록 API 호출
curl -X POST "https://api.telegram.org/bot<TOKEN>/setWebhook" \
     -d "url=https://your-domain.com/telegram"
```

---

### 3. Long Polling vs Webhook 비교

| 비교 항목 | Long Polling | Webhook |
|-----------|-------------|---------|
| **동작 방식** | Bot이 주기적으로 요청 | Telegram이 푸시 |
| **실시간성** | 보통 (폴링 간격에 따름) | 높음 (즉시 전송) |
| **구현 난이도** | 쉬움 | 어려움 (HTTPS/SSL) |
| **인프라 요구사항** | 없음 | 공개 URL, SSL 인증서 |
| **리소스 효율** | 낮음 (불필요한 요청) | 높음 (이벤트 기반) |
| **로컬 개발** | 가능 | 어려움 (터널링 필요) |
| **서버 재시용** | 쉬움 | Webhook 재설정 필요 |
| **대규모 트래픽** | 부적합 | 적합 |

---

## Long Polling 내부 동작 원리

### 별도 스레드에서 실행

**중요:** Long Polling은 스케줄러가 아닙니다! `TelegramLongPollingBot` 내부에 **별도 스레드**가 자동 생성됩니다.

```
┌─────────────────────────────────────────────────────────────┐
│                  LibraryTelegramBot                         │
│                  (TelegramLongPollingBot 상속)               │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  내부 Long Polling 스레드 (telegrambots 라이브러리) │   │
│  │                                                      │   │
│  │  while (running) {                                  │   │
│  │      1. Telegram 서버에 getUpdates() 요청           │   │
│  │      2. 새 메시지가 있으면 즉시 응답               │   │
│  │      3. 없으면 timeout까지 대기 (기본값)           │   │
│  │      4. onUpdateReceived(update) 호출              │   │
│  │  }                                                  │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### Bot 등록 시점

```java
// 애플리케이션 시작 시
@EventListener(ApplicationReadyEvent.class)
public void startBot() {
    TelegramBotsApi botsApi = new TelegramBotsApi(DefaultBotSession.class);
    botsApi.registerBot(bot);  // ← 이 시점에서 내부 스레드 시작!
}
```

**스레드 관리 주의사항:**
- telegrambots 라이브러리가 스레드 풀을 자동 생성
- `ExecutorService` 기반으로 동작
- 명시적으로 종료하지 않으면 **Zombie Thread** 발생 가능

### 생명주기 관리 (필수!)

애플리케이션 종료 시 Bot 스레드를 안전하게 정리해야 합니다:

```java
@Configuration
public class TelegramBotConfig {

    private BotSession botSession;  // Bot 세션 참조 유지

    @EventListener(ApplicationReadyEvent.class)
    public void startBot() {
        TelegramBotsApi botsApi = new TelegramBotsApi(DefaultBotSession.class);
        botSession = botsApi.registerBot(bot);  // 세션 저장
    }

    @PreDestroy
    public void stopBot() {
        if (botSession != null && botSession.isRunning()) {
            botSession.stop();  // 스레드 안전 종료
        }
    }
}
```

**`@PreDestroy` 없으면:**
```
애플리케이션 종료 (SIGTERM)
    ↓
Spring Bean 파괴
    ↓
Tomcat 종료
    ↓
❌ Telegram Bot 스레드는 여전히 실행 중! (Zombie Thread)
```

---

### 4. Long Polling 선택 이유

**교육적 관점:**
1. **빠른 시작**: 복잡한 인프라 설정 없이 즉시 구현 가능
2. **집중도 핵심**: Telegram Bot API와 메시지 처리 로직에 집중
3. **로컬 개발**: 학습 환경에서 바로 테스트 가능
4. **단순성**: Webhook보다 코드가 간결하고 이해하기 쉬움

**실무적 관점:**
- 소규모 프로젝트에는 Long Polling으로 충분
- 나중에 확장이 필요하면 Webhook로 전환 가능
- Spring Boot의 `@ConditionalOnProperty`로 환경별 분기 가능

**확장 가능성:**
```java
// 프로퍼티로 메시지 수신 방식 전환 가능
telegram.update-receiver.type=polling  // 또는 webhook

@ConditionalOnProperty(name = "telegram.update-receiver.type", havingValue = "polling")
public class LongPollingBotConfig { ... }

@ConditionalOnProperty(name = "telegram.update-receiver.type", havingValue = "webhook")
public class WebhookBotConfig { ... }
```

---

## 사전 준비

### 1. Telegram Bot 생성

1. Telegram에서 `@BotFather` 검색
2. `/newbot` Command로 새 Bot 생성
3. Bot 이름과 사용자명 입력
4. **API Token** 저장 (이후 사용)

### 2. 의존성 추가

`pom.xml`에 Telegram Bot API 의존성 추가:

```xml
<dependency>
    <groupId>org.telegram</groupId>
    <artifactId>telegrambots</artifactId>
    <version>6.8.0</version>
</dependency>
```

---

## 구현 가이드

### 1. 설정 프로퍼티

`application.properties`:

```properties
telegram.bot.token=YOUR_BOT_TOKEN_HERE
telegram.bot.username=ai_library_bot
```

### 2. Bot 설정 클래스

**구현 포인트:**
- Telegram Bots API 초기화
- Bot 등록 및 생명주기 관리
- 의존성 주입 (BookSearchService, SemanticCacheService)

```java
@Configuration
public class TelegramBotConfig {

    private BotSession botSession;  // Bot 세션 관리

    /**
     * Telegram Bot Bean 등록
     * TODO: BookSearchService, SemanticCacheService 주입
     */
    @Bean
    public LibraryTelegramBot libraryTelegramBot(
            BookSearchService bookSearchService,
            SemanticCacheService semanticCacheService) {
        // TODO: LibraryTelegramBot 생성 및 반환
        return null;
    }

    /**
     * 애플리케이션 시작 후 Bot 실행
     * TODO: ApplicationReadyEvent 사용하여 Bot 등록
     */
    @EventListener(ApplicationReadyEvent.class)
    public void startBot(ApplicationReadyEvent event) {
        // TODO: TelegramBotsApi 생성 및 Bot 등록
        // 힌트: botSession 참조 유지
    }

    /**
     * 애플리케이션 종료 시 Bot 정리
     * TODO: @PreDestroy 사용하여 Bot 스레드 안전 종료
     */
    @PreDestroy
    public void stopBot() {
        // TODO: botSession.stop() 호출
    }
}
```

### 3. Redis 설정 (범용)

**중요:** Redis는 Telegram 전용이 아니라 **프로젝트 전체에서 사용**하는 범용 설정입니다.

```properties
# application.properties
# Redis 설정이 있으면 자동으로 RedisConfig가 활성화됨
spring.data.redis.host=localhost
spring.data.redis.port=6379
```

```java
@Configuration
@ConditionalOnProperty(name = "spring.data.redis.host")
public class RedisConfig {

    /**
     * RedisTemplate Bean 등록
     * TODO: 직렬화 설정 (Key: String, Value: JSON)
     */
    @Bean
    public RedisTemplate<String, Object> redisTemplate(
            RedisConnectionFactory connectionFactory) {
        // TODO: RedisTemplate 생성 및 설정
        return null;
    }
}
```

### 3. Bot 프로퍼티 클래스

```java
@Component
@ConfigurationProperties(prefix = "telegram.bot")
public class TelegramBotProperties {
    private String token;
    private String username;

    // Getters and Setters
    // TODO: Lombok 사용 가능 (@Data)
}
```

### 4. Bot Component

**인터페이스:**

```java
/**
 * Telegram Update 수신 처리
 */
public interface TelegramUpdateConsumer {
    void consume(Update update);
}
```

**구현 가이드:**

```java
@Slf4j
@Component
@RequiredArgsConstructor
public class LibraryTelegramBot implements LongPollingSingleThreadUpdateConsumer {

    private final TelegramBotProperties properties;
    private final TelegramClient telegramClient;

    @Override
    public void consume(Update update) {
        // TODO: Update 수신 처리

        // 1. 메시지 타입 확인
        if (update.hasMessage() && update.getMessage().hasText()) {
            String messageText = update.getMessage().getText();
            Long chatId = update.getMessage().getChatId();

            // 2. 로깅
            log.info("Received: {} from {}", messageText, chatId);

            // 3. 응답 전송
            SendMessage response = SendMessage.builder()
                .chatId(chatId)
                .text("안녕하세요! AI Library Bot입니다.\n\n" +
                      "사용 가능한 Command:\n" +
                      "/start - Bot 시작\n" +
                      "/help - 도움말")
                .build();

            telegramClient.execute(response);
        }
    }
}
```

### 5. Message Handler 구조

**Command 패턴 적용:**

```java
/**
 * Command Handler 인터페이스
 */
public interface CommandHandler {
    boolean canHandle(String command);
    void handle(Update update);
}

/**
 * 시작 Command Handler
 */
@Component
public class StartCommandHandler implements CommandHandler {
    @Override
    public boolean canHandle(String command) {
        return "/start".equals(command);
    }

    @Override
    public void handle(Update update) {
        // TODO: 환영 메시지 전송
    }
}
```

---

## 구현 순서

### Phase 1: 기본 Bot 동작 확인

1. Telegram Bot 생성 및 Token 획득
2. `application.properties`에 Token 설정
3. 간단한 응답 Bot 구현
4. Telegram에서 메시지 전송 테스트

### Phase 2: Command 처리 구현

1. Command 구조 설계 (`/{command}`)
2. Command Handler 구현
3. Command 분배 로직 구현

### Phase 3: 에러 처리

1. 예외 상황 정의
2. 에러 메시지 포맷 정의
3. 예외 처리 구현

---

## 테스트

### 1. 단위 테스트

```java
@DisplayName("Telegram Bot 테스트")
class LibraryTelegramBotTest {

    @Test
    @DisplayName("Update 수신 처리")
    void consumeUpdate() {
        // TODO: given-when-then 구조로 테스트 작성
    }
}
```

### 2. 통합 테스트

```bash
# 1. 애플리케이션 실행
mvn spring-boot:run

# 2. Telegram에서 Bot 테스트
# Bot 검색: @ai_library_bot
# START 버튼 클릭
# /start Command 전송
# 응답 확인
```

---

## 학습 과제

### 필수 구현 사항

1. [ ] `TelegramBotConfig` 클래스 작성
2. [ ] `TelegramBotProperties` 프로퍼티 클래스 작성
3. [ ] `LibraryTelegramBot` 기본 구현
4. [ ] `/start`, `/help` Command 처리
5. [ ] 메시지 수신 및 응답 전송

### 도전 과제

1. [ ] Command Handler 전략 패턴 적용
2. [ ] 에러 메시지 포맷 정의
3. [ ] 알 수 없는 Command 처리

---

## 참고 자료

- [Telegram Bot API 공식 문서](https://core.telegram.org/bots/api)
- [telegrambots 라이브러리](https://github.com/rubenlagus/TelegramBots)

---

## 다음 단계

- [Step 5-2: Telegram을 통한 하이브리드 검색](./02.hybrid-search-via-telegram.md)
