# Telegram Bot 설정

## 개요

Step 1~4에서 구축한 RAG 검색 시스템을 Telegram Bot을 통해 사용할 수 있도록 구현합니다.

## 학습 목표

- Telegram Bot 기본 설정 이해
- Spring Boot와 외부 서비스 연동 경험
- Message Handling 기초
- 환경별 설정 분리 (local/dev/prod)
- Long Polling 내부 동작 원리 이해

## 아키텍처

```
┌─────────────┐     ┌─────────────────────┐     ┌─────────────┐
│  Telegram   │ ──▶ │   Telegram Bot       │ ──▶ │  RAG        │
│    User     │     │   (external/telegram)│     │  Search     │
└─────────────┘     └─────────────────────┘     └─────────────┘
                          │
                          ▼
                   ┌─────────────┐
                   │Redis Cache  │
                   │(범용 설정)  │
                   └─────────────┘
```

### 패키지 구조

```
com.nhnacademy.library
├── core/
│   └── config/
│       ├── RedisConfig.java          # 범용 Redis 설정
│       └── ObjectMapperConfig.java   # Jackson JavaTimeModule 설정
└── external/                         # 외부 API 연동
    └── telegram/
        ├── bot/
        │   └── LibraryTelegramBot.java
        └── config/
            ├── TelegramBotConfig.java
            └── TelegramBotProperties.java
```

---

## Telegram Bot이란?

Telegram Bot은 Telegram 메신저 플랫폼에서 동작하는 자동화된 프로그램입니다.

### 특징
- **Long Polling**: Bot이 주기적으로 서버에 새 메시지를 요청
- **Webhook**: Telegram이 새 메시지가 올 때 지정한 URL로 호출
- **Inline Keyboard**: 버튼 형태의 사용자 인터페이스
- **Callback Query**: 버튼 클릭 등의 이벤트 처리

### 사용 이유
- 별도의 UI/UX 개발 불필요
- 사용자가 이미 익숙한 채팅 인터페이스
- 모바일 친화적
- 실시간 상호작용 가능

---

## Telegram 메시지 수신 방식

Telegram Bot에서 메시지를 수신하는 방식은 크게 **Long Polling**과 **Webhook** 두 가지가 있습니다.

### 1. Long Polling (롱 폴링)

**개념:**
- Bot이 **주기적으로** Telegram 서버에 "새 메시지가 있나요?"라고 요청하는 방식
- Telegram 서버는 새 메시지가 있으면 즉시 응답, 없으면 일정 시간 대기 후 타임아웃

**동작 원리:**
```
┌─────────────┐                  ┌─────────────┐
│  Bot App    │                  │  Telegram   │
│             │  ──[요청]──────▶  │   Server    │
│             │                  │             │
│  (대기중)   │                  │  (대기시작)  │
│             │  ◀──[응답]─────── │  (메시지)   │
│             │                  │   또는      │
│  (처리후)   │                  │  (타임아웃)  │
│             │  ──[요청]──────▶ │             │
└─────────────┘                  └─────────────┘
```

**장점:**
- 구현이 간단함 (공개 URL 불필요)
- 방화벽/네트워크 제약 없음
- 로컬 개발 환경에서 바로 사용 가능
- 서버 재시작이 용이함

**단점:**
- 메시지가 없어도 주기적으로 요청 전송 (리소스 낭비)
- 실시간성이 떨어질 수 있음 (폴링 간격에 따름)
- 대량의 트래픽 발생 가능

**구현 예시:**
```java
// telegrambots 라이브러리의 TelegramLongPollingBot 사용
public class LibraryTelegramBot extends TelegramLongPollingBot {
    @Override
    public void onUpdateReceived(Update update) {
        // 새 메시지가 도착하면 자동 호출됨
    }
}
```

---

### 2. Webhook (웹훅)

**개념:**
- Telegram 서버가 **새 메시지가 발생할 때마다** 미리 설정된 Bot의 URL로 호출해주는 방식
- 이벤트 기반 (Event-Driven) 아키텍처

**동작 원리:**
```
┌─────────────┐                  ┌─────────────┐
│  User       │                  │  Telegram   │
│  Message    │  ──[메시지]───▶  │   Server    │
└─────────────┘                  │             │
                                 │  ──[POST]──▶ ┌─────────────┐
                                 │   (Webhook)  │  Bot App     │
                                 │              │  (/telegram) │
                                 │              │             │
                                 │              │  (처리)      │
                                 │  ◀──[200]──── │             │
                                 └─────────────┘└─────────────┘
```

**장점:**
- 실시간 처리 (메시지 도착 즉시 전송)
- 불필요한 요청 없음 (리소스 효율적)
- 대규모 트래픽 처리에 적합
- 응답 시간 빠름

**단점:**
- 공개 URL (HTTPS) 필요
- SSL 인증서 요구 (Telegram 보안 정책)
- 방화벽/네트워크 설정 필요
- 로컬 개발 시 ngtm 등 터널링 도구 필요
- 서버 다운 시 메시지 유실 가능

**구현 예시:**
```java
@RestController
@RequestMapping("/telegram")
public class TelegramWebhookController {

    @PostMapping
    public ResponseEntity<Void> handleUpdate(@RequestBody Update update) {
        // Webhook으로 받은 Update 처리
        telegramBotService.processUpdate(update);
        return ResponseEntity.ok().build();
    }
}
```

**Webhook 설정:**
```bash
# Webhook 등록 API 호출
curl -X POST "https://api.telegram.org/bot<TOKEN>/setWebhook" \
     -d "url=https://your-domain.com/telegram"
```

---

### 3. Long Polling vs Webhook 비교

| 비교 항목 | Long Polling | Webhook |
|-----------|-------------|---------|
| **동작 방식** | Bot이 주기적으로 요청 | Telegram이 푸시 |
| **실시간성** | 보통 (폴링 간격에 따름) | 높음 (즉시 전송) |
| **구현 난이도** | 쉬움 | 어려움 (HTTPS/SSL) |
| **인프라 요구사항** | 없음 | 공개 URL, SSL 인증서 |
| **리소스 효율** | 낮음 (불필요한 요청) | 높음 (이벤트 기반) |
| **로컬 개발** | 가능 | 어려움 (터널링 필요) |
| **서버 재시용** | 쉬움 | Webhook 재설정 필요 |
| **대규모 트래픽** | 부적합 | 적합 |

---

## Long Polling 내부 동작 원리

### 별도 스레드에서 실행

**중요:** Long Polling은 스케줄러가 아닙니다! `TelegramLongPollingBot` 내부에 **별도 스레드**가 자동 생성됩니다.

```
┌─────────────────────────────────────────────────────────────┐
│                  LibraryTelegramBot                         │
│                  (TelegramLongPollingBot 상속)               │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  내부 Long Polling 스레드 (telegrambots 라이브러리) │   │
│  │                                                      │   │
│  │  while (running) {                                  │   │
│  │      1. Telegram 서버에 getUpdates() 요청           │   │
│  │      2. 새 메시지가 있으면 즉시 응답               │   │
│  │      3. 없으면 timeout까지 대기 (기본값)           │   │
│  │      4. onUpdateReceived(update) 호출              │   │
│  │  }                                                  │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### Bot 등록 시점

```java
// 애플리케이션 시작 시
@EventListener(ApplicationReadyEvent.class)
public void startBot() {
    TelegramBotsApi botsApi = new TelegramBotsApi(DefaultBotSession.class);
    botsApi.registerBot(bot);  // ← 이 시점에서 내부 스레드 시작!
}
```

**스레드 관리 주의사항:**
- telegrambots 라이브러리가 스레드 풀을 자동 생성
- `ExecutorService` 기반으로 동작
- 명시적으로 종료하지 않으면 **Zombie Thread** 발생 가능

### 생명주기 관리 (필수!)

애플리케이션 종료 시 Bot 스레드를 안전하게 정리해야 합니다:

```java
@Configuration
public class TelegramBotConfig {

    private BotSession botSession;  // Bot 세션 참조 유지

    @EventListener(ApplicationReadyEvent.class)
    public void startBot() {
        TelegramBotsApi botsApi = new TelegramBotsApi(DefaultBotSession.class);
        botSession = botsApi.registerBot(bot);  // 세션 저장
    }

    @PreDestroy
    public void stopBot() {
        if (botSession != null && botSession.isRunning()) {
            botSession.stop();  // 스레드 안전 종료
        }
    }
}
```

**`@PreDestroy` 없으면:**
```
애플리케이션 종료 (SIGTERM)
    ↓
Spring Bean 파괴
    ↓
Tomcat 종료
    ↓
❌ Telegram Bot 스레드는 여전히 실행 중! (Zombie Thread)
```

---

### 4. Long Polling 선택 이유

**교육적 관점:**
1. **빠른 시작**: 복잡한 인프라 설정 없이 즉시 구현 가능
2. **집중도 핵심**: Telegram Bot API와 메시지 처리 로직에 집중
3. **로컬 개발**: 학습 환경에서 바로 테스트 가능
4. **단순성**: Webhook보다 코드가 간결하고 이해하기 쉬움

**실무적 관점:**
- 소규모 프로젝트에는 Long Polling으로 충분
- 나중에 확장이 필요하면 Webhook로 전환 가능
- Spring Boot의 `@ConditionalOnProperty`로 환경별 분기 가능

**확장 가능성:**
```java
// 프로퍼티로 메시지 수신 방식 전환 가능
telegram.update-receiver.type=polling  // 또는 webhook

@ConditionalOnProperty(name = "telegram.update-receiver.type", havingValue = "polling")
public class LongPollingBotConfig { ... }

@ConditionalOnProperty(name = "telegram.update-receiver.type", havingValue = "webhook")
public class WebhookBotConfig { ... }
```

---

## 사전 준비

### 1. Telegram Bot 생성

1. Telegram에서 `@BotFather` 검색
2. `/newbot` Command로 새 Bot 생성
3. Bot 이름과 사용자명 입력
4. **API Token** 저장 (이후 사용)

### 2. 의존성 추가

`pom.xml`에 Telegram Bot API 의존성 추가:

```xml
<dependency>
    <groupId>org.telegram</groupId>
    <artifactId>telegrambots</artifactId>
    <version>6.8.0</version>
</dependency>
```

---

## 환경별 설정 분리

### 설정 파일 구조

```
src/main/resources/
├── application.properties          # 기본 설정
├── application-local.properties    # 로컬 환경 (Telegram 활성화)
├── application-dev.properties      # 개발 환경 (Telegram 비활성화)
├── application-prod.properties     # 운영 환경 (Telegram 활성화)
├── telegram.properties             # Telegram 설정 (공통)
└── redis.properties                # Redis 설정 (공통)
```

### 1. Telegram 설정 (telegram.properties)

```properties
# ===============================
# Telegram Bot Settings
# ===============================
telegram.bot.enabled=true
telegram.bot.token=YOUR_BOT_TOKEN_HERE
telegram.bot.username=your_bot_username
```

### 2. Redis 설정 (redis.properties)

```properties
# ===============================
# Redis Settings
# ===============================
spring.data.redis.host=localhost
spring.data.redis.port=6379
# spring.data.redis.password=YOUR_PASSWORD
spring.data.redis.database=0
```

### 3. 환경별 설정

**application-local.properties** (로컬):
```properties
# Import external configurations
spring.config.import=optional:file:./telegram.properties,optional:file:./redis.properties

# Thymeleaf cache disabled
spring.thymeleaf.cache=false
```

**application-dev.properties** (개발):
```properties
# Telegram Bot Disabled in Dev
telegram.bot.enabled=false

# Import external configurations
spring.config.import=optional:file:./telegram.properties,optional:file:./redis.properties

# Thymeleaf cache disabled
spring.thymeleaf.cache=false
```

**application-prod.properties** (운영):
```properties
# Import external configurations
spring.config.import=optional:file:./telegram.properties,optional:file:./redis.properties

# Thymeleaf cache enabled
spring.thymeleaf.cache=true
```

### 4. Bot 활성화/비활성화 설정

**TelegramBotConfig.java:**
```java
@Configuration
@ConditionalOnProperty(name = "telegram.bot.enabled", havingValue = "true", matchIfMissing = false)
public class TelegramBotConfig {
    // Bot 설정
}
```

**TelegramBotProperties.java:**
```java
@Component
@ConfigurationProperties(prefix = "telegram.bot")
public class TelegramBotProperties {
    private boolean enabled = false;  // 기본값: 비활성화
    private String token;
    private String username;

    // getters and setters
}
```

---

## 구현 가이드

### 1. Bot 설정 클래스

**구현 포인트:**
- Telegram Bots API 초기화
- Bot 등록 및 생명주기 관리
- 의존성 주입 (BookSearchService, SemanticCacheService)

```java
@Configuration
@ConditionalOnProperty(name = "telegram.bot.enabled", havingValue = "true", matchIfMissing = false)
public class TelegramBotConfig {

    private BotSession botSession;  // Bot 세션 관리

    @Bean
    public LibraryTelegramBot libraryTelegramBot(
            BookSearchService bookSearchService,
            SemanticCacheService semanticCacheService) {
        DefaultBotOptions options = new DefaultBotOptions();
        return new LibraryTelegramBot(properties, options, bookSearchService, semanticCacheService);
    }

    @EventListener(ApplicationReadyEvent.class)
    public void startBot(ApplicationReadyEvent event) {
        LibraryTelegramBot bot = event.getApplicationContext().getBean(LibraryTelegramBot.class);
        try {
            TelegramBotsApi botsApi = new TelegramBotsApi(DefaultBotSession.class);
            botSession = botsApi.registerBot(bot);
            log.info("[Telegram] Bot registered successfully: @{}", properties.getUsername());
        } catch (TelegramApiException e) {
            log.error("[Telegram] Failed to register bot", e);
        }
    }

    @PreDestroy
    public void stopBot() {
        if (botSession != null && botSession.isRunning()) {
            try {
                botSession.stop();
                log.info("[Telegram] Bot stopped successfully");
            } catch (Exception e) {
                log.error("[Telegram] Failed to stop bot", e);
            }
        }
    }
}
```

### 2. Redis 설정 (범용)

**중요:** Redis는 Telegram 전용이 아니라 **프로젝트 전체에서 사용**하는 범용 설정입니다.

```properties
# application.properties
# Redis 설정이 있으면 자동으로 RedisConfig가 활성화됨
spring.data.redis.host=localhost
spring.data.redis.port=6379
```

```java
@Configuration
@ConditionalOnProperty(name = "spring.data.redis.host")
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        // Key 직렬화 (String)
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());

        // Value 직렬화 (JSON with JavaTimeModule)
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer(objectMapper);
        template.setValueSerializer(serializer);
        template.setHashValueSerializer(serializer);

        template.afterPropertiesSet();
        return template;
    }
}
```

### 3. Bot 프로퍼티 클래스

```java
@Component
@ConfigurationProperties(prefix = "telegram.bot")
public class TelegramBotProperties {
    private boolean enabled = false;
    private String token;
    private String username;

    // Getters and Setters
    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
}
```

### 4. Bot Component

```java
@Slf4j
@Component
@RequiredArgsConstructor
public class LibraryTelegramBot extends TelegramLongPollingBot {

    private final TelegramBotProperties properties;
    private final BookSearchService bookSearchService;
    private final SemanticCacheService semanticCacheService;

    @Override
    public void onUpdateReceived(Update update) {
        if (update.hasMessage() && update.getMessage().hasText()) {
            String messageText = update.getMessage().getText();
            Long chatId = update.getMessage().getChatId();

            log.info("[Telegram] Received: {} from {}", messageText, chatId);

            // Command 분기 처리
            if (messageText.startsWith("/")) {
                handleCommand(update, messageText);
            } else {
                // 일반 텍스트도 검색으로 처리
                handleSearch(update, messageText);
            }
        }
    }

    @Override
    public String getBotUsername() {
        return properties.getUsername();
    }

    @Override
    public String getBotToken() {
        return properties.getToken();
    }

    private void handleCommand(Update update, String command) {
        // Command 처리 로직
    }

    private void handleSearch(Update update, String keyword) {
        // RAG 검색 처리
    }
}
```

---

## 구현 순서

### Phase 1: 기본 Bot 동작 확인

1. Telegram Bot 생성 및 Token 획득
2. `application.properties`에 Token 설정
3. 간단한 응답 Bot 구현
4. Telegram에서 메시지 전송 테스트

### Phase 2: RAG 검색 연동

1. `BookSearchService` 연동 (SearchType.RAG)
2. 검색 결과 포맷팅
3. 이미지 전송

### Phase 3: 환경별 설정 분리

1. `telegram.properties`, `redis.properties` 생성
2. 환경별 프로퍼티 설정
3. `@ConditionalOnProperty`로 Bot 활성화/비활성화

---

## 테스트

### 1. 단위 테스트

```java
@DisplayName("Telegram Bot 테스트")
class LibraryTelegramBotTest {

    @Test
    @DisplayName("Bot Username과 Token 반환 확인")
    void testBotCredentials() {
        assertThat(bot.getBotUsername()).isEqualTo("test_bot");
        assertThat(bot.getBotToken()).isEqualTo("test-token");
    }

    @Test
    @DisplayName("/start Command 수신 시 메시지 처리 로직 확인")
    void testStartCommandProcessing() {
        // Given
        Update update = createUpdateWithMessage("/start", 12345L);

        // When
        bot.onUpdateReceived(update);

        // Then
        assertThat(update.getMessage().getText()).isEqualTo("/start");
    }
}
```

### 2. 통합 테스트

```bash
# 1. 애플리케이션 실행 (local profile)
mvn spring-boot:run -Dspring-boot.run.profiles=local

# 2. Telegram에서 Bot 테스트
# Bot 검색: @nhnacademy_library_bot
# START 버튼 클릭
# /start Command 전송
# 응답 확인

# 3. 검색 테스트
# 키워드 입력: 해리포터
# RAG 검색 결과 확인
```

---

## 학습 과제

### 필수 구현 사항

1. [ ] `TelegramBotConfig` 클래스 작성
2. [ ] `TelegramBotProperties` 프로퍼티 클래스 작성
3. [ ] `LibraryTelegramBot` 기본 구현
4. [ ] `/start`, `/help` Command 처리
5. [ ] 메시지 수신 및 응답 전송
6. [ ] 환경별 설정 분리 (local/dev/prod)

### 도전 과제

1. [ ] `@ConditionalOnProperty`를 활용한 Bot 활성화/비활성화
2. [ ] 에러 메시지 포맷 정의
3. [ ] 알 수 없는 Command 처리
4. [ ] Jackson JavaTimeModule 설정

---

## 참고 자료

- [Telegram Bot API 공식 문서](https://core.telegram.org/bots/api)
- [telegrambots 라이브러리](https://github.com/rubenlagus/TelegramBots)

---

## 다음 단계

- [Step 5-2: Telegram을 통한 RAG 검색](./02.rag-search-via-telegram.md)
