# 사용자 피드백 수집

## 개요

사용자로부터 검색 결과에 대한 피드백을 수집하고, 이를 통해 AI 검색 품질을 개선합니다. 수집된 피드백 데이터는 **지속적인 AI 시스템 개선의 핵심 자산**으로 활용됩니다.

## 학습 목표

- **JPA Entity 설계**: 도메인 모델을 데이터베이스 스키마로 매핑
- **계층형 아키텍처**: Controller → Service → Repository 구조 이해
- **사용자 인터랙션**: Inline Keyboard와 Callback Query 처리 흐름
- **데이터 설계**: 피드백 데이터를 AI 학습에 활용할 수 있는 구조 설계
- **피드백 루프**: 수집 → 분석 → 개선의 전체 사이클 이해

---

## 왜 피드백인가?

### AI 시스템의 성장 루프

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   사용자 검색 ──▶ 결과 표시 ──▶ 피드백 수집              │
│       ▲                                    │            │
│       │                                    ▼            │
│   더 나은 경험 ◀── AI 모델 개선 ◀── 데이터 분석          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**피드백이 중요한 이유:**
1. **객관적 품질 지표**: 사용자가 실제로 만족하는지 측정
2. **지속적 개선**: 시스템을 사용할수록 더 똑똑해짐
3. **개인화 기반**: 사용자별 선호도 학습 가능
4. **A/B 테스트**: 개선 효과를 정량적으로 검증

### 실무 사례

| 서비스 | 피드백 활용 |
|--------|-------------|
| **Netflix** | 시청 여부로 추천 알고리즘 개선 |
| **YouTube** | 클릭률, 시청 시간으로 추천 최적화 |
| **Google 검색** | 클릭 여부로 검색 순위 개선 |
| **Amazon** | 구매 여부로 상품 추천 개선 |

---

## 전체 아키텍처

### 시스템 구조도

```
┌─────────────────────────────────────────────────────────────┐
│                      Telegram User                         │
│                    (검색 결과 확인 후)                      │
└────────────────────────┬────────────────────────────────────┘
                         │ 클릭: 👍 도움이 됨
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                 Inline Keyboard (버튼 UI)                   │
│  [👍 도움이 됨] [👎 도움이 안됨]  [✅ 관련 있음] [❌ 관련 없음]│
└────────────────────────┬────────────────────────────────────┘
                         │ Callback Query 전송
                         ▼
┌─────────────────────────────────────────────────────────────┐
│              CallbackQueryHandler                          │
│  1. Callback 데이터 수신                                   │
│  2. 데이터 파싱 (query, bookId, type)                     │
│  3. FeedbackService 호출                                   │
│  4. 감사 메시지 전송                                       │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                FeedbackService                             │
│  • 피드백 저장                                             │
│  • 통계 계산                                               │
│  • 사용자별 조회                                           │
└──────────────────┬────────────────┬────────────────────────┘
                   │                │
                   ▼                ▼
        ┌──────────────────┐  ┌──────────────────┐
        │  Repository      │  │  AI Improvement  │
        │  (DB 저장)       │  │  Services        │
        └──────────────────┘  │  • 검색 재정렬    │
                               │  • 개인화        │
                               │  • 프롬프트 개선 │
                               │  • 품질 분석     │
                               │  • A/B 테스트     │
                               └──────────────────┘
```

### 데이터 흐름도

```
1. 사용자가 검색 → 결과 표시 + Inline Keyboard
                    ↓
2. 사용자가 버튼 클릭 → Callback Query 전송
                    ↓
3. CallbackHandler 수신 → 데이터 파싱
                    ↓
4. FeedbackService → DB 저장
                    ↓
5. 저장된 피드백 → 분석 및 AI 개선에 활용
                    ↓
6. 다음 검색 시 → 개선된 결과 제공
```

### 계층별 역할

```
┌─────────────────────────────────────────────────────┐
│  Presentation Layer                                │
│  • Inline Keyboard: 사용자 버튼 UI                 │
│  • CallbackQueryHandler: Callback 처리             │
│  • Admin API: 관리자용 조회/통계                   │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│  Business Layer                                    │
│  • FeedbackService: 피드백 비즈니스 로직           │
│  • FeedbackAwareRankingService: 재정렬            │
│  • PersonalizedRecommendationService: 개인화      │
│  • FeedbackEnhancedAiPromptService: 프롬프트 개선 │
│  • SearchQualityAnalyticsService: 품질 분석       │
│  • FeedbackAbTestService: A/B 테스트               │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│  Data Access Layer                                 │
│  • SearchFeedbackRepository: DB CRUD               │
│  • SearchFeedback Entity: 데이터 모델              │
│  • FeedbackRequest/Stats: 데이터 전송 객체         │
└─────────────────────────────────────────────────────┘
```

---

## 핵심 개념

### 1. 피드백 데이터 모델

**수집할 정보:**
- **누가**: Chat ID (사용자 식별)
- **무엇을**: 검색어, 도서 ID
- **어떻게**: 피드백 타입 (긍정/부정)
- **언제**: 타임스탬프

**피드백 타입:**
```
👍 좋았음 (GOOD)   → 검색 결과가 마음에 들음  (+1점)
👎 별로였음 (BAD)  → 검색 결과가 별로였음    (-1점)
```

**설계 이유:**
- 단순명료: 사용자가 고민할 필요 없이 바로 클릭
- 명확한 점수화: 긍정 +1, 부정 -1로 계산 단순
- 실무 표준: Reddit, Hacker News 등 많은 서비스가 이 방식 사용

### 2. Inline Keyboard

**Inline Keyboard란 무엇인가요?**

Telegram의 **버튼 형태 UI**로, 사용자가 클릭하면 Bot에 Callback(콜백) 신호가 전달됩니다.

웹사이트의 버튼을 생각하면 쉽습니다:
- 웹사이트: `<button onclick="handleClick()">클릭</button>`
- Telegram: `InlineKeyboardButton(callbackData="feedback:123")`

**왜 Inline Keyboard를 사용하나요?**

1. **사용자 친화적**: 텍스트를 직접 입력할 필요 없이 버튼 클릭만으로 동작
2. **입력 오류 방지**: "/search 해리포터" 같은 명령어를 틀리지 않고 버튼으로 정확하게 전달
3. **실시간 피드백**: 클릭 즉시 Bot이 응답하고 메시지를 수정 가능

---

**Markdown 링크 vs Inline Keyboard 비교**

현재 Bot에서 이미 사용 중인 Markdown 링크와 비교해보겠습니다:

| 구분 | Markdown 링크 | Inline Keyboard |
|------|---------------|-----------------|
| **용도** | 웹사이트로 이동 | Bot에 신호 전달 |
| **예시** | `🔗 상세 보기: [링크](https://...)` | `[👍 도움이 됨] 버튼` |
| **동작** | 외부 브라우저 열림 | Bot 내에서 처리 |
| **Bot 수신** | 수신 불가 (사용자가 브라우저로 이동) | `hasCallbackQuery()`로 감지 |
| **사용 사례** | 도서 상세 페이지 보기 | 피드백 전송, 명령 실행 |

**실제 코드 예시:**

```java
// 1. Markdown 링크 (현재 사용 중)
String message = "🔗 상세 보기: https://library.java21.net/books/123";
SendMessage(msg).text(message).build();
// → 사용자가 클릭하면 웹브라우저가 열림

// 2. Inline Keyboard (이번에 추가)
InlineKeyboardButton button = InlineKeyboardButton.builder()
    .text("👍 도움이 됨")
    .callbackData("feedback:해리포터:123:HELPFUL")
    .build();
// → 사용자가 클릭하면 Bot이 callbackData를 수신
```

---

**Inline Keyboard 작동 방식**

```
┌─────────────────────────────────────────────┐
│         사용자 화면 (Telegram App)          │
│                                             │
│  Bot: 검색 결과가 도움이 되셨나요?           │
│                                             │
│  [👍 도움이 됨] [👎 도움이 안됨]  ← 버튼    │
│  [✅ 관련 있음] [❌ 관련 없음]  ← Inline     │
│           Keyboard                          │
└─────────────────┬───────────────────────────┘
                  │
                  │ 사용자가 버튼 클릭
                  ▼
┌─────────────────────────────────────────────┐
│           Telegram 서버                      │
│  callbackData: "feedback:해리포터:123:HELPUL" │
└─────────────────┬───────────────────────────┘
                  │
                  │ Callback Query 전송
                  ▼
┌─────────────────────────────────────────────┐
│           LibraryTelegramBot                │
│  onUpdateReceived(Update) 호출              │
│  update.hasCallbackQuery() == true          │
└─────────────────┬───────────────────────────┘
                  │
                  │ CallbackQueryHandler 처리
                  ▼
┌─────────────────────────────────────────────┐
│         데이터 파싱 및 저장                  │
│  query = "해리포터"                         │
│  bookId = 123                               │
│  type = HELPFUL                             │
│  → DB 저장                                  │
└─────────────────────────────────────────────┘
```

---

**일반 메시지와의 차이**

| 구분 | 일반 메시지 | Inline Keyboard |
|------|-------------|-----------------|
| **사용자 입력** | 텍스트 직접 입력 | 버튼 클릭 |
| **Bot 수신 메서드** | `hasMessage()` | `hasCallbackQuery()` |
| **응답 방식** | `SendMessage` (새 메시지) | `EditMessageText` (기존 메시지 수정) |
| **예시** | User: "해리포터" 입력 | User: [👍 좋았음] 클릭 |

---

**참고 자료**

Telegram Bot 공식 문서:
- [Inline Keyboards](https://core.telegram.org/bots/features#inline-keyboards)
- [InlineKeyboardMarkup](https://core.telegram.org/bots/api#inlinekeyboardmarkup)
- [Callback Query](https://core.telegram.org/bots/api#callbackquery)

Java 라이브러리 (telegram-bot):
- [TelegramBots GitHub](https://github.com/rubenlagus/TelegramBots)

### 3. Callback 데이터 설계

버튼 식별을 위한 데이터 포맷:

**포맷:**
```
feedback:{query}:{bookId}:{type}

예: feedback:해리포터:123:GOOD
```

**고려사항:**
- 특수문자 처리 (`:` → URL 인코딩 필요)
- 파싱 용이성
- 확장성 (다른 타입의 Callback 추가 가능)

---

### 4. 피드백 UI 설계

**중요한 설계 결정: 개별 도서별 피드백**

각 검색 결과 도서마다 별도의 피드백 버튼을 제공합니다:

```
Bot: 📚 "해리포터" 검색 결과 (5권)

     1. 해리포터와 마법사의 돌
        [👍 좋았음] [👎 별로였음]

     2. 해리포터와 비밀의 방
        [👍 좋았음] [👎 별로였음]
```

**왜 개별 도서별인가?**
1. **더 정밀한 피드백**: "첫 번째 책은 좋았는데, 두 번째 책은 별로였어"
2. **AI 개선에 활용**: 피드백이 많은 도서를 상위 표시 (Learning to Rank)
3. **개인화 가능**: 사용자가 "판타지" 좋아하는 패턴 학습

**데이터 저장 예시:**
```
도서 1에 👍 클릭 → bookId = 1, type = GOOD
도서 2에 👎 클릭 → bookId = 2, type = BAD
```

---

## 데이터베이스 설계

### ERD

```
┌─────────────────────────────────────────────┐
│             search_feedbacks                │
├─────────────────────────────────────────────┤
│  id           (PK)          BIGINT          │
│  chat_id      (NOT NULL)   BIGINT           │
│  query        (NOT NULL)   VARCHAR(500)     │
│  book_id                    BIGINT          │
│  type         (NOT NULL)   VARCHAR(20)      │
│  created_at   (NOT NULL)   TIMESTAMP        │
├─────────────────────────────────────────────┤
│  INDEX: idx_chat_id                         │
│  INDEX: idx_created_at                      │
└─────────────────────────────────────────────┘
```

### 필드 상세 설명

| 컬럼명 | 타입 | NULL | 설명 | 예시 |
|--------|------|------|------|------|
| **id** | BIGINT | NOT NULL | 기본키 (PK) | 1, 2, 3, ... |
| **chat_id** | BIGINT | NOT NULL | Telegram 사용자 식별자 | 123456789, 987654321 |
| **query** | VARCHAR(500) | NOT NULL | 사용자 검색어 | "해리포터", "주식 투자" |
| **book_id** | BIGINT | NULL | 피드백 대상 도서 ID | 101, 205, NULL (전체 피드백) |
| **type** | VARCHAR(20) | NOT NULL | 피드백 유형 | GOOD, BAD |
| **created_at** | TIMESTAMP | NOT NULL | 피드백 생성 시간 | 2025-01-15 14:30:25 |

**필드별 상세 설명:**

| 필드 | 의미 | 사용 예시 |
|------|------|----------|
| **id** | 피드백 고유 번호 (자동 증가) | DB가 자동 부여 |
| **chat_id** | Telegram 사용자 고유 ID. 같은 사용자인지 식별 | 123456789 = 철수, 987654321 = 영희 |
| **query** | 사용자가 입력한 검색어. URL 인코딩된 상태로 저장 | "해리포터", "Java%20%EB%B0%B1%EC%97%94%EB%93%9C" |
| **book_id** | 피드백을 준 도서 ID. 특정 도서를 지정 | 101 = "해리포터와 마법사의 돌" |
| **type** | 피드백 종류. 긍정/부정 유형 | GOOD = 좋았음(+1점), BAD = 별로였음(-1점) |
| **created_at** | 피드백이 저장된 시간. 자동 생성 | "2025-01-15 14:30:25" |

---

### SQL DDL

**PostgreSQL:**
```sql
-- PostgreSQL 인덱스 문법 주의사항:
-- • MySQL과 달리 PostgreSQL은 CREATE TABLE 내부에서 INDEX 정의를 지원하지 않음
-- • 반드시 별도의 CREATE INDEX 문으로 인덱스를 생성해야 함

-- 1. 테이블 생성
CREATE TABLE search_feedbacks (
    id BIGSERIAL PRIMARY KEY,
    chat_id BIGINT NOT NULL,
    query VARCHAR(500) NOT NULL,
    book_id BIGINT,
    type VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 2. 인덱스 별도 생성
CREATE INDEX idx_search_feedbacks_chat_id ON search_feedbacks(chat_id);
CREATE INDEX idx_search_feedbacks_created_at ON search_feedbacks(created_at);
```

---

### 예시 데이터

**실제 저장되는 데이터 예시:**

```
┌────┬───────────┬──────────────┬─────────┬───────────────┬─────────────────────┐
│ id │  chat_id  │    query     │ book_id │     type      │     created_at      │
├────┼───────────┼──────────────┼─────────┼───────────────┼─────────────────────┤
│  1 │ 123456789 │ 해리포터     │     101 │ GOOD          │ 2025-01-15 14:30:25 │
│  2 │ 123456789 │ 해리포터     │     102 │ BAD           │ 2025-01-15 14:31:10 │
│  3 │ 987654321 │ 주식 투자    │     205 │ GOOD          │ 2025-01-15 15:20:05 │
│  4 │ 123456789 │ Java 백엔드  │     310 │ GOOD          │ 2025-01-15 16:45:30 │
│  5 │ 987654321 │ 주식 투자    │     205 │ BAD           │ 2025-01-15 17:10:15 │
└────┴───────────┴──────────────┴─────────┴───────────────┴─────────────────────┘
```

**데이터 분석 예시:**

| 질문 | SQL 예시 | 결과 |
|------|----------|------|
| "해리포터" 검색에 대한 긍정 피드백 수? | `SELECT COUNT(*) FROM search_feedbacks WHERE query='해리포터' AND type='GOOD'` | 1건 |
| 도서 ID 101에 대한 피드백 점수? | `(긍정 1건 - 부정 0건) / 1건 = 1.0 (100% 긍정)` | +0.5 보너스 |
| 철수(chatId=123456789)가 좋아한 도서? | `SELECT book_id FROM search_feedbacks WHERE chat_id=123456789 AND type='GOOD'` | 101, 310 |
| 최근 7일간 긍정 피드백 비율? | `긍정 3건 / 전체 5건 = 60%` | 60% |

**실제 사용 시나리오:**

```
시나리오: 철수가 "해리포터"를 검색하고 피드백을 남김

1. 검색: User(chatId=123456789) → "해리포터" 검색
2. 결과: 3권의 도서 표시 (ID: 101, 102, 103)
3. 피드백:
   - 도서 101: [👍 좋았음] 클릭
   - 도서 102: [👎 별로였음] 클릭
4. DB 저장:
   INSERT INTO search_feedbacks (chat_id, query, book_id, type, created_at)
   VALUES (123456789, '해리포터', 101, 'GOOD', '2025-01-15 14:30:25');

   INSERT INTO search_feedbacks (chat_id, query, book_id, type, created_at)
   VALUES (123456789, '해리포터', 102, 'BAD', '2025-01-15 14:31:10');
5. AI 활용:
   - 도서 101: 긍정 피드백 → 다음 검색 시 상위 표시
   - 도서 102: 부정 피드백 → 다음 검색 시 하위 표시
```

---

### JPA Entity 설계 포인트

**필요한 어노테이션:**
- `@Entity` - JPA Entity임을 명시
- `@Table` - 테이블명과 인덱스 설정
- `@Id` + `@GeneratedValue` - 기본키 설정
- `@Enumerated(EnumType.STRING)` - Enum을 문자열로 저장
- `@PrePersist` - 저장 전 자동으로 created_at 설정

**구현 가이드:**
- 인덱스: chat_id, created_at (조회 성능)
- Enum: String 타입으로 저장 (가독성)
- @PrePersist: 생성 시간 자동 설정

---

## 구현 가이드

### Phase 1: Entity와 Repository
### Phase 1: Entity와 Repository

**목표:** 피드백 데이터를 저장할 데이터베이스 구조 만들기

**구현해야 할 것:**

**1. `FeedbackType` Enum**
- GOOD(1, "좋았음"), BAD(-1, "별로였음") 정의
- `getScoreValue()` 메서드로 점수 반환 (+1, -1)

**2. `SearchFeedback` Entity**
- 필드: id, chatId, query, bookId, type(FeedbackType), createdAt
- 어노테이션: @Entity, @Table(name="search_feedbacks"), @Index
- @PrePersist: createdAt 자동 설정

**3. `SearchFeedbackRepository` 인터페이스**
- Spring Data JPA 상속
- 쿼리 메서드:
  - `findByChatIdOrderByCreatedAtDesc(Long chatId)` - 특정 사용자 피드백
  - `findByBookId(Long bookId)` - 특정 도서의 모든 피드백
  - `findByQuery(String query)` - 특정 검색어 피드백

**처리 흐름:**
```
피드백 생성 → Entity 매핑 → Repository → DB 저장
```

**학습 포인트:**
- JPA 어노테이션 (@Entity, @Table, @Index, @Enumerated)
- Enum을 String으로 저장하는 이유 (가독성)
- @PrePersist로 생성 시간 자동 설정
- Spring Data JPA 메서드 네이밍 규칙

---

### Phase 2: DTO와 Service

**목표:** 비즈니스 로직과 데이터 전송 객체 만들기

**구현해야 할 것:**

**1. `FeedbackRequest` DTO (record)**
- 필드: query(@NotBlank), bookId(@NotNull), type(@NotNull)
- 역할: 피드백 요청 데이터 전달, 유효성 검사

**2. `FeedbackStats` DTO (record)**
- 필드: goodCount, badCount, totalCount, goodRatio, feedbackScore
- 메서드: `from(List<SearchFeedback>)` - Stream API로 통계 계산
- 점수 계산: (긍정 - 부정) / 전체
- 예: GOOD 15건, BAD 2건 → (15-2)/17 = 0.76

**3. `FeedbackService` 인터페이스**
- `recordFeedback(FeedbackRequest)` - 피드백 저장
- `getUserFeedback(Long chatId)` - 사용자별 피드백 목록
- `getBookFeedbackStats(Long bookId)` - 도서별 통계
- `getQueryFeedbackStats(String query)` - 검색어별 통계
- `getRecentFeedback(int days)` - 최근 N일 피드백

**4. `FeedbackServiceImpl` 구현**
- @Transactional 트랜잭션 처리
- Repository 호출하여 DB 저장
- Stream API로 통계 계산

**처리 흐름:**
```
Request DTO → Service → Repository → DB
              ↓
         Stats 계산 → Stats DTO 반환
```

**학습 포인트:**
- record 활용 (불변 객체)
- Validation 어노테이션 (@NotNull, @NotBlank)
- @Transactional (readOnly 최적화)
- Stream API로 데이터 집계

---

### Phase 3: Inline Keyboard Factory

**목표:** 버튼 UI 생성 로직 만들기

**구현해야 할 것:**

**`TelegramKeyboardFactory` 클래스**
- `createFeedbackKeyboard(String query, Long bookId)` 메서드
  - 검색어 URL 인코딩 (공백, 한글 처리)
  - InlineKeyboardButton 2개 생성 (좋았음, 별로였음)
  - InlineKeyboardMarkup.builder()로 Keyboard 조립
  - callbackData 포맷: `feedback:{query}:{bookId}:{type}`
  - 예: `feedback:해리포터:123:GOOD`

**UI 레이아웃:**
```
┌─────────────────────────────────┐
│  [👍 좋았음] [👎 별로였음]       │
└─────────────────────────────────┘
```

**처리 흐름:**
```
검색어 입력 → URL 인코딩 → Keyboard 생성 → 버튼에 Callback 데이터 연결
```

**학습 포인트:**
- Builder 패턴으로 Keyboard 생성
- URL 인코딩으로 특수문자 처리
- Callback 데이터 포맷 설계 (콜론(:)으로 구분)

---

### Phase 4: Callback Handler

**목표:** 버튼 클릭 처리 로직 만들기

**구현해야 할 것:**

**`CallbackQueryHandler` 클래스**
- `handleCallback(Update update)` 메서드
  1. Callback 유형 확인 (hasCallbackQuery)
  2. Callback 데이터 파싱 (split(":"))
     - `feedback:해리포터:123:GOOD` → ["feedback", "해리포터", "123", "GOOD"]
  3. URL 디코딩으로 검색어 복원
  4. FeedbackRequest 생성
  5. FeedbackService로 저장
  6. EditMessageText로 메시지 수정 (감사 메시지)
  7. AnswerCallbackQuery로 Telegram에 응답
  8. 예외 처리 (IllegalArgumentException, 일반 Exception)

**처리 흐름:**
```
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│ 사용자 클릭 │ →  │ Callback 수신 │ →  │  데이터 파싱  │ →  │  DB 저장    │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
                                                                ↓
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│  완료 응답   │ ←  │ 메시지 수정   │ ←  │ 감사 메시지  │ ←  │ Telegram API │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
```

**학습 포인트:**
- URL 디코딩으로 특수문자 복원
- Enum 변환 시 IllegalArgumentException 처리
- EditMessageText로 기존 메시지 수정
- AnswerCallbackQuery로 Telegram에 응답 전송

```java
            // 3. 피드백 저장
            FeedbackRequest request = new FeedbackRequest(query, bookId, type);
            feedbackService.recordFeedback(request);

            // 4. 메시지 수정 (감사 메시지)
            EditMessageText editMessage = EditMessageText.builder()
                .chatId(chatId)
                .messageId(callbackQuery.getMessage().getMessageId())
                .text("✅ 소중한 피드백 감사합니다!\n검색 품질 개선에 활용하겠습니다.")
                .build();

            // execute(editMessage);

            // 5. Callback 응답 (Telegram에 전송 완료 알림)
            AnswerCallbackQuery answer = AnswerCallbackQuery.builder()
                .callbackQueryId(callbackQuery.getId())
                .text("피드백이 저장되었습니다.")
                .build();
            // execute(answer);

        } catch (IllegalArgumentException e) {
            log.error("Invalid callback data: {}", callbackData, e);
            sendErrorMessage(chatId, "피드백 처리 중 오류가 발생했습니다.");
        } catch (Exception e) {
            log.error("Failed to process callback: {}", callbackData, e);
            sendErrorMessage(chatId, "피드백 처리 중 오류가 발생했습니다.");
        }
    }

    private void sendErrorMessage(Long chatId, String text) {
        // 에러 메시지 전송 로직
    }
}
```
**역할:** 버튼 클릭 시 Callback 처리

**처리 흐름:**
```
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│ 사용자 클릭 │ →  │ Callback 수신 │ →  │  데이터 파싱  │ →  │  DB 저장    │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
                                                                ↓
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│  완료 응답   │ ←  │ 메시지 수정   │ ←  │ 감사 메시지  │ ←  │ Telegram API │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
```

**학습 포인트:**
- URL 디코딩으로 특수문자 복원
- Enum 변환 시 IllegalArgumentException 처리
- EditMessageText로 기존 메시지 수정
- AnswerCallbackQuery로 Telegram에 응답 전송

---

### Phase 5: Bot 연동

**목표:** 기존 Bot에 피드백 기능 통합

**수정해야 할 것:**

**1. `LibraryTelegramBot`에 의존성 추가**
- CallbackQueryHandler 주입
- TelegramKeyboardFactory 주입

**2. `onUpdateReceived` 메서드 수정**
- Callback Query 처리를 최우선으로 분기
- 일반 메시지는 기존 로직대로 처리
- 우선순위: Callback → 일반 메시지

**3. 검색 결과 전송 메서드 수정**
- 도서 정보 전송 시 Keyboard 생성
- SendMessage.builder()에 .replyMarkup(keyboard) 추가
- 각 도서마다 개별 Keyboard 부착

**처리 흐름:**
```
Update 수신 → Callback 확인? → YES: CallbackHandler 처리
                          → NO: 기존 메시지 처리
검색 결과 전송 → Keyboard 생성 → replyMarkup 설정 → 전송
```

**학습 포인트:**
- 기존 코드에 새 기능 통합 방법
- 우선순위 기반 분기 처리
- replyMarkup으로 Keyboard 메시지에 부착

---

### Phase 6: 관리자 API & Telegram Bot 통계 기능 ✅ 구현 완료

**REST API 구현 완료:**

**`FeedbackAdminController` 클래스 (@RestController)**
- `GET /api/admin/feedback/book/{bookId}/stats` - 도서별 피드백 통계
- `GET /api/admin/feedback/stats?query=해리포터` - 검색어별 피드백 통계
- `GET /api/admin/feedback/recent?days=7` - 최근 N일간 피드백 목록 (1~30일)
- `GET /api/admin/feedback/user/{chatId}` - 사용자별 피드백 목록

**API 응답 예시:**
```json
GET /api/admin/feedback/stats?query=해리포터

{
  "goodCount": 15,
  "badCount": 2,
  "totalCount": 17,
  "goodRatio": 0.882,
  "feedbackScore": 0.764
}
```

**Telegram Bot 명령어 확장:**

| 명령어 | 설명 | 사용 예시 |
|--------|------|----------|
| `/stats <검색어>` | 검색어별 피드백 통계 조회 | `/stats 해리포터` |
| `/mystats` | 내 피드백 내역 조회 (최대 10개) | `/mystats` |

**명령어 응답 예시:**
```
User: /stats 해리포터

Bot: 📊 "해리포터" 피드백 통계

    👍 좋았음: 15건
    👎 별로였음: 3건
    📈 전체: 18건
    💯 긍정 비율: 83.3%
    ⭐ 피드백 점수: 0.666
```

**학습 포인트:**
- @GetMapping, @RequestParam, @PathVariable 활용
- ResponseEntity로 JSON 응답
- REST API 설계 원칙
- Telegram Bot Command 확장

**구현 파일:**
- `FeedbackAdminController.java` - REST API 컨트롤러
- `LibraryTelegramBot.java` - /stats, /mystats 명령어 처리
- `TelegramBotConfig.java` - FeedbackService 주입

---

## 구현 완료 체크리스트

### Phase 1: Entity와 Repository ✅
- [x] `FeedbackType` Enum
- [x] `SearchFeedback` Entity
- [x] `SearchFeedbackRepository` 인터페이스

### Phase 2: DTO와 Service ✅
- [x] `FeedbackRequest` DTO (record)
- [x] `FeedbackStats` DTO (record)
- [x] `FeedbackService` 인터페이스
- [x] `FeedbackServiceImpl` 구현

### Phase 3: Inline Keyboard Factory ✅
- [x] `TelegramKeyboardFactory` 클래스
- [x] URL 인코딩 처리
- [x] Inline Keyboard 생성

### Phase 4: Callback Handler ✅
- [x] `CallbackQueryHandler` 클래스
- [x] Callback 데이터 파싱
- [x] URL 디코딩
- [x] AnswerCallbackQuery로 응답

### Phase 5: Bot 연동 ✅
- [x] `LibraryTelegramBot` 수정
- [x] Callback Query 처리 분기
- [x] 피드백 Keyboard 도서별 부착

### Phase 6: Admin API & Bot 명령어 ✅
- [x] `FeedbackAdminController` REST API
- [x] `/stats <검색어>` 명령어
- [x] `/mystats` 명령어
- [x] 통계 처리 로직

---

## 참고 자료

- [Spring Data JPA 공식 문서](https://spring.io/projects/spring-data-jpa)
- [JPA Entity 어노테이션](https://docs.jboss.org/hibernate/orm/6.2/javadocs/org/hibernate/jpa/package-summary.html)
- [PostgreSQL 인덱스 문법](https://www.postgresql.org/docs/current/sql-createindex.html)

---

## 다음 단계

- [Step 5-4: 피드백 UI & Callback Handler](./04.feedback-ui-callback-handler.md)

