# 피드백 활용: AI 개선 연계

## 개요

수집된 피드백 데이터를 활용하여 검색 결과를 개선하는 방법을 설명합니다.

## 학습 목표

- 피드백 기반 검색 재정렬 알고리즘 이해
- 사용자 개인화 추천 시스템 설계
- 검색 품질 분석 및 보고서 생성 방법
- A/B 테스트를 통한 효과 측정

---

수집된 피드백을 실제 AI 개선에 활용하는 방법입니다.

> **⚠️ 중요**: 피드백 데이터를 검색에 반영하는 방식(집계 기준, 가중치, 적용 시점 등)은 **프로젝트 요구사항, 데이터 수집 상황, 실험 결과에 따라 적절히 변경**할 수 있습니다. 본 문서에 제시된 전략은 참고용 가이드라인으로, 실제 구현에서는 A/B 테스트를 통해 최적의 방식을 찾아보시기를 권장합니다.

**고려해볼 수 있는 변형 전략:**
- **집계 기준**: 검색어별(query), 도서별(book_id), 사용자별(chatId) 또는 이들의 조합
- **가중치 방식**: 선형 가중치, 지수 가중치, 계단 함수 등
- **적용 시점**: RRF 계산 직후, 최종 정렬 전, LLM 프롬프트에만 반영 등
- **최소 데이터门槛**: 3건, 5건, 10건 등 (통계적 유의성에 따라 조정)
- **시간 감쇠**: 최근 피드백 가중치 부여, 전체 기간 평균 등

**데이터 분석 기반 의사결정:**
- 충분한 피드백이 쌓인 후 집계 방식 변경
- A/B 테스트로 효과 측정 후 가중치 조정
- 검색어별 피드백 패턴 분석으로 전략 수정

---

**핵심 원칙:** 피드백은 도서 ID 기준으로 집계합니다. 같은 도서에 대한 피드백은 검색어가 달라도 모두 통합하여 반영합니다.

**왜 book_id인가?**

1. **실용성**: 사용자가 "좋아요" 누른 건 검색어가 아니라 **도서**임
2. **단순함**: query 벡터 저장 없이 바로 집계 가능
3. **정확성**: 같은 도서는 어떤 검색어로 찾든 동일한 품질을 가짐

**실제 예시:**
```
도서 101이 총 100번 검색됨

- "해리포터" 검색 → GOOD 80건, BAD 5건
- "마법사 돌" 검색 → GOOD 10건, BAD 2건
- "Harry Potter" 검색 → GOOD 2건, BAD 1건

집계 결과:
- 총 GOOD: 92건, BAD: 8건
- 피드백 점수: (92 - 8) / 100 = 0.84
- 보너스 점수: 0.84 × 0.5 = +0.42점
```

**query는 언제 사용하나요?**
- 검색어별 품질 분석 (관리자 대시보드)
- "어떤 검색어가 결과가 좋은지/안좋은지" 확인용
- DB에서 `GROUP BY query`로 분석

**구현 방법:**
```java
// 특정 도서의 모든 피드백을 통합 (query 무시)
FeedbackStats stats = feedbackService.getBookFeedbackStats(bookId);
double bonusScore = stats.feedbackScore() * 0.5;  // 최대 ±0.5
```

---

## 피드백 반영 기준

### 현재 시스템 구조

```
┌─────────────────────────────────────────────────────┐
│          검색 요청 (query: "해리포터")           │
└────────────────────┬────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────┐
│     1단계: 하이브리드 검색                         │
│  • Vector 유사도 검색 (80%)                       │
│  • Keyword 검색 (20%)                            │
│  • RRF(Reciprocal Rank Fusion)로 점수 결합      │
│  결과: [A: 75점, B: 70점, C: 65점, D: 60점]      │
└────────────────────┬────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────┐
│     2단계: LLM 검증 (RAG)                           │
│  • 상위 N권 도서에 대해 AI 추천 사유 생성        │
│  • 사용자에게 도서 추천                            │
└─────────────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────┐
│     3단계: 피드백 반영 (추가)                    │
│  • 수집된 피드백 점수를 계산                     │
│  • 검색 결과에 반영                                 │
└─────────────────────────────────────────────────────�
```

---

### 피드백 반영 시점과 방법

**시점 1: 검색 재정렬 (Reranking)**

**언제?** 하이브리드 검색 결과가 나온 직후
**방법:** 피드백 점수를 원래 점수에 합산

```
[원래 점수]    [피드백 보너스]    [최종 점수]
A: 75점   +   A: +0.3점      =   A: 78.2점
B: 70점   +   B: +0.0점      =   B: 70.0점
C: 65점   +   C: -0.2점      =   C: 64.8점
D: 60점   +   D: -0.5점      =   D: 59.5점

→ 재정렬: [A, B, C, D]
```

**구현:**
```java
// 피드백 점수 계산
feedbackScore = (긍정 피드백 수 - 부정 피드백 수) / 총 피드백 수
// 예: 15건 긍정, 2건 부정 → (15 - 2) / 17 = 0.76

// 보너스 점수 (최대 ±0.5점)
bonusScore = feedbackScore * 0.5

// 최종 점수
finalScore = originalScore + bonusScore
```

---

**시점 2: LLM 프롬프트에 피드백 정보 포함**

**언제?** LLM에 추천 요청할 때
**방법:** 프롬프트에 피드백 통계 추가

```
프롬프트 예시:
"""
사용자가 "해리포터" 검색했습니다.

검색 결과 도서:
1. 해리포터와 마법사의 돌 (긍정 피드백: 88%)
2. 해리포터와 비밀의 방 (긍정 피드백: 45%)
3. ...

**중요**: 사용자들이 긍정적으로 평가한 도서를 우선적으로 추천해주세요.
"""
```

---

### 피드백 점수 계산 기준

#### 1. 개별 도서 피드백 점수

```
피드백 점수 = (긍정 피드백 수 - 부정 피드백 수) / 총 피드백 수

예시:
도서 1: 👍 15건, 👎 2건 → (15 - 2) / 17 = +0.76
도서 2: 👍 5건,  👎 5건 → (5 - 5) / 10 =   0.00
도서 3: 👍 2건, 👎 8건 → (2 - 8) / 10 = -0.60
```

#### 2. 보너스 점수 범위

| 피드백 점수 | 보너스 | 최종 점수 변화 |
|------------|-------|---------------|
| +1.0 (100% 긍정) | +0.5 | 75점 → 75.5점 |
| +0.5 (50% 긍정)  | +0.25 | 70점 → 70.25점 |
| 0.0 (긍정=부정) | 0 | 65점 → 65점 |
| -0.5 (50% 부정) | -0.25 | 60점 → 59.75점 |
| -1.0 (100% 부정) | -0.5 | 55점 → 54.5점 |

**이유:** 너무 큰 보너스는 원래 검색 결과를 무시할 수 있음

#### 3. 최소 피드백 수 기준

```
피드백이 5건 미만인 도서는 반영하지 않음
이유: 통계적으로 유의미한 데이터가 부족함
```

---

### 전체 흐름도

```
1. 사용자 검색
   ↓
2. 하이브리드 검색 (Vector + Keyword + RRF)
   결과: [A: 75점, B: 70점, C: 65점, D: 60점]
   ↓
3. 피드백 점수 계산 (각 도서별)
   - 도서 A: +0.3점 (피드백 88%)
   - 도서 B: +0.0점 (피드백 50%)
   - 도서 C: -0.2점 (피드백 20%)
   - 도서 D: -0.5점 (피드백 -20%)
   ↓
4. 최종 점수 합산
   결과: [A: 78.2점, B: 70.0점, C: 64.8점, D: 59.5점]
   ↓
5. 재정렬: [A, B, C, D]
   ↓
6. LLM 추천 (피드백 정보 포함)
```

---

### 학습 포인트

1. **피드백은 보조 수단**: 원래 검색 결과를 완전히 뒤집지 않음
2. **점수 범위 제한**: 너무 큰 영향을 주지 않도록 최대 ±0.5점
3. **최소 데이터 기준**: 5건 미만은 반영하지 않아 신뢙성 확보
4. **단계별 반영**: 1차 검색 → 피드백 보너스 → 최종 결과

---

### 활용 시나리오 개요

| 시나리오 | 설명 | 활용 분야 |
|----------|------|----------|
| **Learning to Rank** | 피드백 기반 검색 결과 재정렬 | 검색 엔진 |
| **개인화** | 사용자 선호도 학습 | 추천 시스템 |
| **프롬프트 개선** | 피드백 통계를 AI에 전달 | LLM 활용 |
| **품질 분석** | 검색 품질 보고서 생성 | 데이터 분석 |
| **A/B 테스트** | 개선 효과 측정 | 실험 설계 |

---

### 1. Learning to Rank

**개념:** 사용자가 "도움이 됨" 피드백을 많이 준 도서를 상위에 표시

**구현 흐름:**
```
1. 기존 검색: [A, B, C, D]
2. 피드백 점수 계산
   - A: 0.8 (긍정 80%)
   - B: 0.6
   - C: 0.4
   - D: 0.2
3. 재정렬: 피드백 점수 순으로 정렬
```

**핵심 메서드:**
- 피드백 점수 계산
- 재정렬

---

### 1-A. 검색어별 피드백 반영 (Query-Aware Feedback) ⭐ **추천**

**개념:** 동일한 검색어에 대한 과거 피드백을 해당 도서에 가중치로 부여

**핵심 아이디어:**
- "해리포터" 검색에 대한 긍정 피드백이 많은 도서 → 다음 "해리포터" 검색 시 상위 표시
- 검색어 컨텍스트를 반영한 가장 직관적인 피드백 활용 방식
- 사용자가 실제로 만족한 검색 결과를 학습

---

#### 전략 비교: 도서 기반 vs 검색어 기반

| 구분 | 도서(book_id) 기반 | 검색어(query) 기반 ⭐ |
|------|-------------------|---------------------|
| **집계 단위** | 도서별 전체 피드백 | (검색어, 도서)별 피드백 |
| **장점** | 데이터 수집 용이 | 검색 컨텍스트 반영 |
| **단점** | 검색어 무시 | 데이터가 쌓여야 효과 있음 |
| **적용 예시** | 인기 도서 우선 | "해리포터"에 좋은 평가 받은 책 |

---

#### 구현 방법

**1. 피드백 점수 계산 (검색어 + 도서 기반)**

```java
/**
 * 특정 검색어와 도서 조합에 대한 피드백 점수 계산
 *
 * @param query 검색어 (예: "해리포터")
 * @param bookId 도서 ID
 * @return 피드백 점수 (0.0 ~ 1.0)
 */
public float calculateQueryFeedbackScore(String query, Long bookId) {
    // 1. (query, bookId) 조합으로 피드백 조회
    List<SearchFeedback> feedbacks = repository
        .findByQueryAndBookId(query, bookId);

    if (feedbacks.isEmpty()) {
        return 0.0f;  // 피드백 없으면 0점
    }

    // 2. 최소 피드백 수 확인 (안정성 확보)
    if (feedbacks.size() < 3) {
        return 0.0f;  // 3건 미만은 반영하지 않음
    }

    // 3. 피드백 점수 계산
    long goodCount = feedbacks.stream()
        .filter(f -> f.getType() == FeedbackType.GOOD)
        .count();

    long badCount = feedbacks.stream()
        .filter(f -> f.getType() == FeedbackType.BAD)
        .count();

    // (긍정 - 부정) / 전체
    float feedbackScore = (goodCount - badCount) / (float) feedbacks.size();

    return Math.max(-1.0f, Math.min(1.0f, feedbackScore));  // -1.0 ~ 1.0 클램프
}
```

**2. RRF 점수에 피드백 가중치 반영**

```java
/**
 * 피드백 점수를 RRF 점수에 반영
 *
 * @param rrfScore 기존 RRF 점수
 * @param feedbackScore 피드백 점수
 * @return 최종 점수
 */
public float applyFeedbackToScore(float rrfScore, float feedbackScore) {
    // 가중치: 최대 +0.5점
    float BONUS_WEIGHT = 0.5f;

    // 최종 점수 = RRF + (피드백 점수 * 가중치)
    return rrfScore + (feedbackScore * BONUS_WEIGHT);
}
```

---

#### 실제 적용 시나리오

**시나리오: 사용자가 "해리포터" 검색**

```
[1단계] 기존 RRF 검색 결과
┌──────────┬───────────┬─────────┐
│ 도서     │ RRF 점수 │ 순위    │
├──────────┼───────────┼─────────┤
│ 도서 A   │ 0.85      │ 1위     │
│ 도서 B   │ 0.72      │ 2위     │
│ 도서 C   │ 0.68      │ 3위     │
│ 도서 D   │ 0.55      │ 4위     │
└──────────┴───────────┴─────────┘

[2단계] "해리포터" 검색에 대한 과거 피드백
┌──────────┬─────────┬─────────┬───────────────┐
│ 도서     │ 긍정    │ 부정    │ 피드백 점수  │
├──────────┼─────────┼─────────┼───────────────┤
│ 도서 A   │ 10건    │ 1건     │ +0.82         │
│ 도서 B   │ 2건     │ 0건     │ +1.00         │
│ 도서 C   │ 0건     │ 0건     │  0.00         │
│ 도서 D   │ -        │ -       │  0.00 (없음)  │
└──────────┴─────────┴─────────┴───────────────┘

[3단계] 피드백 반영 후 최종 점수
┌──────────┬───────────┬─────────────┬───────────┬─────────┐
│ 도서     │ RRF 점수  │ 피드백 보너스│ 최종 점수 │ 순위    │
├──────────┼───────────┼─────────────┼───────────┼─────────┤
│ 도서 A   │ 0.85      │ +0.41       │ 1.26 ⬆️   │ 1위     │
│ 도서 B   │ 0.72      │ +0.50       │ 1.22 ⬆️   │ 2위     │
│ 도서 C   │ 0.68      │ +0.00       │ 0.68      │ 3위     │
│ 도서 D   │ 0.55      │ +0.00       │ 0.55      │ 4위     │
└──────────┴───────────┴─────────────┴───────────┴─────────┘

변화: 도서 B가 2위 → 1위로 상승 가능 (피드백 점수가 높음)
```

---

#### Repository 메서드 추가

```java
/**
 * QueryDSL을 사용한 (query, bookId) 조합 조회
 */
public interface SearchFeedbackRepository extends JpaRepository<SearchFeedback, Long> {

    /**
     * 특정 검색어와 도서 조합의 피드백 목록 조회
     */
    @Query("SELECT sf FROM SearchFeedback sf WHERE sf.query = :query AND sf.bookId = :bookId")
    List<SearchFeedback> findByQueryAndBookId(@Param("query") String query, @Param("bookId") Long bookId);

    /**
     * 특정 검색어의 모든 피드백을 도서별 그룹화하여 통계 조회
     */
    @Query("""
        SELECT new com.nhnacademy.library.feedback.dto.QueryBookFeedbackStats(
            sf.bookId,
            COUNT(CASE WHEN sf.type = 'GOOD' THEN 1 END),
            COUNT(CASE WHEN sf.type = 'BAD' THEN 1 END),
            COUNT(*)
        )
        FROM SearchFeedback sf
        WHERE sf.query = :query
        GROUP BY sf.bookId
        HAVING COUNT(*) >= 3
        """)
    List<QueryBookFeedbackStats> getGroupedStatsByQuery(@Param("query") String query);
}
```

---

#### 장단점 분석

**장점:**
1. ✅ **검색 컨텍스트 반영**: "해리포터" 검색에 좋은 평가를 받은 책이 실제로 상위
2. ✅ **사용자 의도 반영**: 사용자가 만족한 검색 결과를 학습
3. ✅ **직관적임**: 왜 이 도서가 상위인지 이해하기 쉬움
4. ✅ **지속적 개선**: 검색할수록 품질 향상

**단점:**
1. ⚠️ **콜드 스타트**: 초기에는 피드백이 없어 효과 없음
2. ⚠️ **데이터 편향**: 특정 검색어에만 피드백이 집중될 수 있음
3. ⚠️ **계산 비용**: 검색마다 피드백 조회 필요

---

#### 최소 피드백 수 기준

```
피드백이 3건 미만인 (query, bookId) 조합은 반영하지 않음

이유:
- 통계적으로 유의미하지 않음 (표본 부족)
- 1~2건의 피드백은 우연일 수 있음
- 너무 낮은门槛(Threshold)는 노이즈 유발

3건 기준:
- 긍정 3건: +1.0 → 최대 +0.5 보너스
- 긍정 2건, 부정 1건: +0.33 → +0.17 보너스
- 긍정 1건, 부정 2건: -0.33 → -0.17 페널티
```

---

#### 구현 체크리스트

- [ ] `SearchFeedbackRepository`에 `findByQueryAndBookId()` 메서드 추가
- [ ] `FeedbackService`에 `calculateQueryFeedbackScore()` 메서드 구현
- [ ] RRF 계산 로직에 피드백 가중치 반영
- [ ] 최소 피드백 수 (3건) 기준 적용
- [ ] 피드백 없는 경우 안전하게 처리 (return 0.0f)
- [ ] 단위 테스트로 점수 계산 로직 검증

---

#### 추가 고려사항

**1. 시간 가중치 (선택적 확장)**
```java
// 최근 피드백일수록 더 높은 가중치
float timeWeightedScore = calculateTimeWeightedScore(feedbacks);
// 예: 7일 이내 피드백 1.5배, 30일 이내 1.2배, 그 외 1.0배
```

**2. 사용자별 피드백 (개인화)**
```java
// 특정 사용자가 좋아한 도서 스타일 학습
List<Book> userFavorites = getUserFavorites(chatId);
// 추천 시 해당 스타일 가중치 부여
```

**3. 도서 전체 인기도와 결합**
```java
// 검색어 피드백 + 도서 전체 인기도 하이브리드
float queryScore = getQueryFeedbackScore(query, bookId);  // +0.5
float globalScore = getGlobalPopularityScore(bookId);      // +0.3
float finalBonus = queryScore + globalScore;
```

---

### 2. 개인화

**개념:** 사용자가 좋아한 도서 패턴을 학습

**활용 예시:**
```
사용자 A: "해리포터" → 👍, "마법사" → 👍
          → 추천 시 "판타지", "마법" 키워드 강조

사용자 B: "주식" → 👍, "투자" → 👍
          → 추천 시 "경제", "재테크" 키워드 강조
```

**핵심 메서드:**
- 선호 도서 목록 조회
- 개인화된 프롬프트 생성

---
### 3. 품질 분석

**개념:** 검색어별 품질 보고서 생성

**활용:**
- 어떤 검색어가 결과가 좋은지/안좋은지 분석
- 개선이 필요한 검색어 식별
- 시스템 품질 모니터링

**핵심 메서드:**
- 품질 보고서 생성
- 전체 긍정률, 검색어별 그룹화, 긍정률이 낮은 검색어 TOP 5

---

### 4. A/B 테스트

**개념:** 피드백 반영 전/후 효과 측정

**그룹 할당:**
```
사용자 A (chatId=123) → 해시값 → 짝수 → 피드백 반영 그룹
사용자 B (chatId=456) → 해시값 → 홀수 → 통제 그룹
```

**핵심 메서드:**
- 그룹 할당 (50:50)
- A/B 그룹별 긍정률 비교

---

## Callback Query Handler 구현

### CallbackQueryHandler 클래스

**역할:** 버튼 클릭 시 Callback 처리

**실제 구현 포인트:**

1. **순환 의존성 해결**: @Lazy 어노테이션 사용
   - CallbackQueryHandler → LibraryTelegramBot (순환 참조)
   - 생성자 파라미터에 @Lazy 적용하여 지연 로딩

2. **AnswerCallbackQuery**: Telegram 서버에 응답 전송
   - 버튼 클릭 후 로딩 애니메이션 중지
   - 사용자에게 알림 메시지 표시

**구현 예시:**
```java
@Slf4j
@Component
public class CallbackQueryHandler {

    private final FeedbackService feedbackService;
    @Lazy  // 순환 의존성 해결
    private final LibraryTelegramBot libraryTelegramBot;

    public CallbackQueryHandler(FeedbackService feedbackService,
                                 @Lazy LibraryTelegramBot libraryTelegramBot) {
        this.feedbackService = feedbackService;
        this.libraryTelegramBot = libraryTelegramBot;
    }

    public void handleCallback(Update update) {
        CallbackQuery callbackQuery = update.getCallbackQuery();
        String callbackData = callbackQuery.getData();
        Long chatId = callbackQuery.getMessage().getChatId();
        String callbackQueryId = callbackQuery.getId();

        try {
            // 1. Callback 데이터 파싱
            FeedbackRequest request = parseCallbackData(callbackData);

            // 2. 피드백 저장
            feedbackService.recordFeedback(chatId, request);

            // 3. Callback 응답 (로딩 애니메이션 중지 + 알림)
            AnswerCallbackQuery answerCallback = AnswerCallbackQuery.builder()
                    .callbackQueryId(callbackQueryId)
                    .text("✅ 피드백이 저장되었습니다!")
                    .showAlert(false)
                    .build();
            libraryTelegramBot.execute(answerCallback);

        } catch (IllegalArgumentException e) {
            log.error("Invalid callback data: {}", callbackData, e);
            answerCallbackWithError(callbackQueryId, "피드백 처리 중 오류가 발생했습니다.");
        }
    }

    private void answerCallbackWithError(String callbackQueryId, String text) {
        try {
            AnswerCallbackQuery answerCallback = AnswerCallbackQuery.builder()
                    .callbackQueryId(callbackQueryId)
                    .text(text)
                    .showAlert(true)
                    .build();
            libraryTelegramBot.execute(answerCallback);
        } catch (TelegramApiException e) {
            log.error("Failed to send error answer callback: {}", e.getMessage());
        }
    }

    private FeedbackRequest parseCallbackData(String callbackData) {
        // URL 디코딩
        String decodedData = URLDecoder.decode(callbackData, StandardCharsets.UTF_8);

        // 콜론(:)으로 분리
        String[] parts = decodedData.split(":");
        if (parts.length != 4 || !parts[0].equals("feedback")) {
            throw new IllegalArgumentException("Invalid callback data format: " + callbackData);
        }

        String query = parts[1];
        Long bookId = Long.parseLong(parts[2]);
        FeedbackType type = FeedbackType.valueOf(parts[3]);

        return new FeedbackRequest(query, bookId, type);
    }
}
```

**처리 흐름:**
```
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│ 사용자 클릭 │ →  │ Callback 수신 │ →  │  데이터 파싱  │ →  │  DB 저장    │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
                                                                ↓
┌─────────────┐    ┌──────────────┐    ┌─────────────┐    ┌─────────────┐
│  완료 응답   │ ←  │ AnswerCallback│ ←  │ 알림 메시지  │ ←  │ Telegram API │
└─────────────┘    └──────────────┘    └─────────────┘    └─────────────┘
```

**학습 포인트:**
- URL 디코딩으로 특수문자 복원
- Enum 변환 시 IllegalArgumentException 처리
- AnswerCallbackQuery로 Telegram에 응답 전송
- @Lazy로 순환 의존성 해결

---

## Telegram Bot 통계 기능

### 새로운 명령어 추가

**LibraryTelegramBot에 추가된 기능:**

| 명령어 | 설명 | 구현 메서드 |
|--------|------|------------|
| `/stats <검색어>` | 검색어별 피드백 통계 조회 | `handleFeedbackStats()` |
| `/mystats` | 내 피드백 내역 조회 | `handleUserStats()` |

**구현 예시:**
```java
private void handleFeedbackStats(Update update, String query) {
    Long chatId = update.getMessage().getChatId();

    FeedbackStats stats = feedbackService.getQueryFeedbackStats(query);

    StringBuilder message = new StringBuilder();
    message.append("📊 \"").append(escapeMarkdown(query)).append("\" 피드백 통계\n\n");
    message.append("👍 좋았음: ").append(stats.goodCount()).append("건\n");
    message.append("👎 별로였음: ").append(stats.badCount()).append("건\n");
    message.append("📈 전체: ").append(stats.totalCount()).append("건\n");
    message.append("💯 긍정 비율: ").append(String.format("%.1f%%", stats.goodRatio() * 100)).append("\n");
    message.append("⭐ 피드백 점수: ").append(String.format("%.3f", stats.feedbackScore())).append("\n");

    sendSimpleMessage(chatId, message.toString());
}

private void handleUserStats(Update update) {
    Long chatId = update.getMessage().getChatId();

    var feedbacks = feedbackService.getUserFeedback(chatId);

    if (feedbacks.isEmpty()) {
        sendSimpleMessage(chatId, "📊 아직 피드백 내역이 없습니다.");
        return;
    }

    StringBuilder message = new StringBuilder();
    message.append("📊 내 피드백 내역 (").append(feedbacks.size()).append("건)\n\n");

    int displayCount = Math.min(feedbacks.size(), 10);
    for (int i = 0; i < displayCount; i++) {
        var feedback = feedbacks.get(i);
        String emoji = feedback.getType().name().equals("GOOD") ? "👍" : "👎";
        message.append(emoji).append(" ").append(feedback.getQuery()).append("\n");
    }

    sendSimpleMessage(chatId, message.toString());
}
```

**명령어 응답 예시:**
```
User: /stats 해리포터

Bot: 📊 "해리포터" 피드백 통계

    👍 좋았음: 15건
    👎 별로였음: 3건
    📈 전체: 18건
    💯 긍정 비율: 83.3%
    ⭐ 피드백 점수: 0.666
```

---

## 참고 자료

- [Telegram Bot API: Inline Keyboards](https://core.telegram.org/bots/features#inline-keyboards)
- [Telegram Bot API: Callback Query](https://core.telegram.org/bots/api#callbackquery)
- [EditMessageText API](https://core.telegram.org/bots/api#editmessagetext)
- [telegrambots 라이브러리 GitHub](https://github.com/rubenlagus/TelegramBots)

---

## 다음 단계

- [Step 5-5: 피드백 검색 통합 전략](./05.feedback-search-integration.md)
- [Step 5-6: LLM 프롬프트 가이드라인](./06.llm-prompt-guidelines.md)

