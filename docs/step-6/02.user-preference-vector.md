# Phase 2: 사용자 선호도 벡터 계산

## 학습 개요

사용자가 과거에 **GOOD 피드백을 남긴 도서들의 임베딩 벡터**를 분석하여, **사용자의 선호도를 하나의 벡터로 표현**하는 방법을 학습합니다. 벡터 평균 계산을 통해 사용자가 어떤 주제와 장르를 선호하는지 수학적으로 모델링합니다.

## 학습 목표

1. **사용자 선호도의 벡터 표현 이해**
   - 왜 벡터 평균이 사용자 취향을 나타내는가
   - GOOD 피드백 도서들의 선정 기준
   - 콜드 스타트 문제와 최소 피드백 수

2. **데이터 추출 및 필터링**
   - chatId로 사용자 피드백 조회
   - GOOD 타입 피드백만 필터링
   - 최근 N개 제한 및 중복 제거

3. **벡터 평균 계산 구현**
   - BookRepository 쿼리 작성
   - 벡터 평균 계산 알고리즘
   - 캐싱 전략으로 성능 최적화

---

## 1. 사용자 선호도 벡터의 개념

### 1.1 직관적 이해

**핵심 아이디어:** "사용자가 좋아한 도서들의 평균이 곧 사용자의 취향"

```
사용자 A가 좋아한 도서:
1. "해리포터와 마법사의 돌"    → embedding1: [0.5, 0.8, 0.3, ...]
2. "해리포터와 비밀의 방"      → embedding2: [0.6, 0.7, 0.4, ...]
3. "판타지 소설 모음집"        → embedding3: [0.4, 0.9, 0.2, ...]

사용자 A의 선호 벡터:
(embedding1 + embedding2 + embedding3) / 3
= [0.5, 0.8, 0.3, ...]  → "판타지", "마법", "모험" 키워드를 선호
```

**왜 평균인가?**

- **중심 경향성**: 여러 데이터의 대표값
- **잡음 감소**: 특정 도서의 편향성을 줄임
- **일반화**: 새로운 도서와의 비교 용이

### 1.2 벡터 평균의 시각적 표현

```
       embedding2
          ↑
          │
          │
embedding1 └─→ avg_embedding ← ─ embedding3
          (선호도 중심)
```

**해석:**
- 세 벡터의 중심에 위치한 평균 벡터
- 이 평균 벡터에 가까운 도서 → 사용자가 좋아할 확률 높음
- 이 평균 벡터에서 먼 도서 → 사용자가 좋아할 확률 낮음

### 1.3 제약사항: 콜드 스타트 문제

**문제:** 신규 사용자는 피드백이 없어 선호도 계산 불가

```
신규 사용자: 피드백 0개
→ 평균 계산 불가
→ 개인화 제공 불가
```

**해결책: 최소 피드백 수 요구**

```java
if (좋아한 도서 수 < 3) {
    // 개인화 미적용 (일반 검색 결과 반환)
    return null;
}
```

**이유:**
- 1-2개는 우연성 가능성 높음
- 3개 이상부터 일정한 패턴 형성
- 너무 많으면 최근성 반영 어려움 → 최근 20개 제한

---

## 2. 데이터 추출 파이프라인

### 2.1 전체 흐름도

```
[Step 1] 사용자 피드백 조회
    ↓
[Step 2] GOOD 타입 필터링
    ↓
[Step 3] 도서 ID 추출 및 중복 제거
    ↓
[Step 4] 최신순 정렬 및 TOP N 제한
    ↓
[Step 5] 임베딩 조회
    ↓
[Step 6] 벡터 평균 계산
    ↓
[사용자 선호도 벡터 완성]
```

### 2.2 단계별 상세 설명

#### Step 1: 사용자 피드백 조회

```java
// chatId로 사용자의 모든 피드백 조회
List<SearchFeedback> feedbacks =
    feedbackRepository.findByChatIdOrderByCreatedAtDesc(chatId);
```

**결과 예시:**
```
[
  {chatId: 12345, bookId: 101, type: GOOD, query: "해리포터"},
  {chatId: 12345, bookId: 102, type: BAD,  query: "주식"},
  {chatId: 12345, bookId: 101, type: GOOD, query: "해리포터"},  // 중복
  {chatId: 12345, bookId: 305, type: GOOD, query: "판타지"},
  ...
]
```

#### Step 2: GOOD 타입 필터링

```java
List<Long> likedBookIds = feedbacks.stream()
    .filter(f -> f.getType() == FeedbackType.GOOD)  // GOOD만
    .map(SearchFeedback::getBookId)
    .collect(Collectors.toList());
```

**결과 예시:**
```
[101, 305, 407, 512, 620, ...]
```

#### Step 3: 중복 제거

```java
.distinct()  // 같은 도서 여러 번 GOOD → 1번만 계산
```

**이유:**
- 사용자가 같은 도서를 여러 번 좋아할 수 있음
- 중복 제거로 특정 도서의 가중치 과대 방지

#### Step 4: 최신순 정렬 및 TOP N 제한

```java
.limit(20)  // 최근 20개만 사용
```

**이유:**
- 사용자 취향은 시간에 따라 변화
- 오래된 피드백보다 최근 피드백이 더 중요
- 너무 많으면 계산 비용 증가

#### Step 5: 임베딩 조회

```java
List<float[]> embeddings =
    bookRepository.findEmbeddingsByIds(likedBookIds);
```

**SQL 변환:**
```sql
SELECT embedding
FROM books
WHERE id IN (101, 305, 407, 512, 620);
```

**결과 예시:**
```
[
  [0.12, -0.34, 0.56, ..., 0.45],  // bookId=101
  [0.23, -0.45, 0.67, ..., 0.56],  // bookId=305
  [0.34, -0.56, 0.78, ..., 0.67],  // bookId=407
  ...
]
```

#### Step 6: 벡터 평균 계산

```java
float[] userPreferenceVector = calculateAverageVector(embeddings);
```

**계산 과정:**
```
입력: [
  [0.12, -0.34, 0.56, ..., 0.45],  // 1024차원
  [0.23, -0.45, 0.67, ..., 0.56],
  [0.34, -0.56, 0.78, ..., 0.67]
]

각 차원별 평균 계산:
result[0] = (0.12 + 0.23 + 0.34) / 3 = 0.23
result[1] = (-0.34 + -0.45 + -0.56) / 3 = -0.45
result[2] = (0.56 + 0.67 + 0.78) / 3 = 0.67
...
result[1023] = ...

출력: [0.23, -0.45, 0.67, ..., 0.56]  // 1024차원 평균 벡터
```

---

## 3. 구현

### 3.1 BookRepository 쿼리 추가

```java
public interface BookRepository extends JpaRepository<Book, Long> {

    /**
     * 도서 ID 목록으로 임베딩을 조회합니다.
     *
     * @param bookIds 도서 ID 목록
     * @return 임베딩 리스트 (float[1024][])
     */
    @Query("SELECT b.embedding FROM Book b WHERE b.id IN :bookIds")
    List<float[]> findEmbeddingsByIds(@Param("bookIds") List<Long> bookIds);
}
```

**주의사항:**
- `IN` 쿼리는 목록 길이에 제약 있을 수 있음 (PostgreSQL 기본 제한 없음)
- `bookIds`가 비어 있으면 빈 리스트 반환
- 순서는 보장되지 않으므로 Map으로 매핑 필요할 수 있음

### 3.2 PersonalizationService 구현

```java
@Service
@Slf4j
public class PersonalizationService {

    private final FeedbackRepository feedbackRepository;
    private final BookRepository bookRepository;
    private final CacheManager cacheManager;

    // 캐싱: 같은 사용자의 선호도 벡터를 24시간 동안 캐싱
    @Cacheable(value = "userPreferenceVectors", key = "#chatId")
    public float[] calculateUserPreferenceVector(Long chatId) {
        log.debug("Calculating user preference vector for chatId: {}",
            PrivacyUtil.maskChatId(chatId));

        // [Step 1-4] 좋아한 도서 ID 추출
        List<Long> likedBookIds = getLikedBookIds(chatId);

        // [콜드 스타트 체크] 최소 3개 이상이어야 개인화
        if (likedBookIds.size() < 3) {
            log.info("Not enough feedbacks for personalization: {} (chatId: {})",
                likedBookIds.size(), PrivacyUtil.maskChatId(chatId));
            return null;
        }

        // [Step 5] 임베딩 조회
        List<float[]> embeddings = bookRepository.findEmbeddingsByIds(likedBookIds);

        if (embeddings.isEmpty()) {
            log.warn("No embeddings found for bookIds: {}", likedBookIds);
            return null;
        }

        // [Step 6] 평균 계산
        float[] userPreferenceVector = calculateAverageVector(embeddings);

        log.info("User preference vector calculated: chatId={}, likedBooks={}, dimensions={}",
            PrivacyUtil.maskChatId(chatId), likedBookIds.size(), userPreferenceVector.length);

        return userPreferenceVector;
    }

    /**
     * 사용자가 좋아한 도서 ID 목록을 추출합니다.
     * - GOOD 피드백만
     * - 중복 제거
     * - 최신순 20개 제한
     */
    private List<Long> getLikedBookIds(Long chatId) {
        return feedbackRepository.findByChatIdOrderByCreatedAtDesc(chatId)
            .stream()
            .filter(f -> f.getType() == FeedbackType.GOOD)
            .map(SearchFeedback::getBookId)
            .filter(Objects::nonNull)  // bookId가 null인 것 제외
            .distinct()
            .limit(20)
            .collect(Collectors.toList());
    }

    /**
     * 벡터 리스트의 평균을 계산합니다.
     *
     * @param vectors 벡터 리스트 (각각 1024차원)
     * @return 평균 벡터 (1024차원)
     */
    private float[] calculateAverageVector(List<float[]> vectors) {
        if (vectors.isEmpty()) {
            throw new IllegalArgumentException("벡터 리스트가 비어 있습니다.");
        }

        int dimensions = vectors.get(0).length;
        float[] avgVector = new float[dimensions];

        // 각 차원별로 합계 계산
        for (float[] vector : vectors) {
            for (int i = 0; i < dimensions; i++) {
                avgVector[i] += vector[i];
            }
        }

        // 평균 계산 (합계 / 개수)
        for (int i = 0; i < dimensions; i++) {
            avgVector[i] /= vectors.size();
        }

        return avgVector;
    }

    /**
     * 선호도 벡터 캐시를 무효화합니다.
     * 새로운 피드백이 저장될 때 호출합니다.
     */
    @CacheEvict(value = "userPreferenceVectors", key = "#chatId")
    public void evictUserPreferenceCache(Long chatId) {
        log.debug("Evicted user preference cache for chatId: {}",
            PrivacyUtil.maskChatId(chatId));
    }
}
```

### 3.3 캐싱 설정

**application.properties**
```properties
# Redis 캐시 설정 (이미 구성되어 있다고 가정)
spring.cache.type=redis
spring.cache.redis.time-to-live=86400000  # 24시간 (밀리초)
```

**또는 Ehcache 사용:**
```java
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .expireAfterWrite(24, TimeUnit.HOURS)  // 24시간 후 만료
            .maximumSize(1000));  // 최대 1000개 캐싱
        return cacheManager;
    }
}
```

---

## 4. 데이터베이스 조회 예시

### 4.1 사용자별 피드백 확인

```sql
-- chatId=12345 사용자의 피드백 확인
SELECT
    sf.id,
    sf.book_id,
    b.title,
    sf.type,
    sf.created_at
FROM search_feedbacks sf
JOIN books b ON sf.book_id = b.id
WHERE sf.chat_id = 12345
ORDER BY sf.created_at DESC;
```

**결과 예시:**
```
 id | book_id |        title        | type |      created_at
----+---------+---------------------+------+------------------------
  1 |      101 | 해리포터와 마법사의 돌  | GOOD  | 2024-02-26 10:23:45
  2 |      102 | 주식으로 돈 버는 법    | BAD   | 2024-02-26 11:12:33
  3 |      305 | 판타지 소설 모음집     | GOOD  | 2024-02-26 14:56:21
  4 |      407 | 마법사의 연금술       | GOOD  | 2024-02-26 15:34:12
```

### 4.2 GOOD 피드백 도서의 임베딩 조회

```sql
-- GOOD 피드백 도서의 임베딩 조회
SELECT
    b.id,
    b.title,
    b.embedding[1:5] as first_5_values
FROM books b
WHERE b.id IN (
    SELECT sf.book_id
    FROM search_feedbacks sf
    WHERE sf.chat_id = 12345
      AND sf.type = 'GOOD'
);
```

---

## 5. 테스트

### 5.1 단위 테스트

```java
@SpringBootTest
class PersonalizationServiceTest {

    @Autowired
    private PersonalizationService personalizationService;

    @Autowired
    private FeedbackRepository feedbackRepository;

    @Autowired
    private BookRepository bookRepository;

    @Test
    @Transactional
    void testCalculateUserPreferenceVector_EnoughFeedback() {
        // Given: chatId에 5개의 GOOD 피드백 생성
        Long chatId = 12345L;
        List<Long> bookIds = List.of(101L, 102L, 103L, 104L, 105L);

        for (Long bookId : bookIds) {
            SearchFeedback feedback = SearchFeedback.builder()
                .chatId(chatId)
                .query("test")
                .bookId(bookId)
                .type(FeedbackType.GOOD)
                .build();
            feedbackRepository.save(feedback);
        }

        // When: 선호도 벡터 계산
        float[] preferenceVector = personalizationService.calculateUserPreferenceVector(chatId);

        // Then: 1024차원 벡터 반환
        assertNotNull(preferenceVector);
        assertEquals(1024, preferenceVector.length);

        // 모든 값이 -1 ~ 1 사이 (임베딩 normalized 되었다고 가정)
        for (float value : preferenceVector) {
            assertTrue(value >= -1.0f && value <= 1.0f);
        }
    }

    @Test
    void testCalculateUserPreferenceVector_ColdStart() {
        // Given: 피드백이 없는 사용자
        Long chatId = 99999L;

        // When: 선호도 벡터 계산
        float[] preferenceVector = personalizationService.calculateUserPreferenceVector(chatId);

        // Then: null 반환 (콜드 스타트)
        assertNull(preferenceVector);
    }

    @Test
    @Transactional
    void testCalculateUserPreferenceVector_TwoFeedbacks() {
        // Given: 2개의 GOOD 피드백 (최소 3개 필요)
        Long chatId = 12346L;
        createFeedback(chatId, 101L, FeedbackType.GOOD);
        createFeedback(chatId, 102L, FeedbackType.GOOD);

        // When: 선호도 벡터 계산
        float[] preferenceVector = personalizationService.calculateUserPreferenceVector(chatId);

        // Then: null 반환 (피드백 부족)
        assertNull(preferenceVector);
    }

    @Test
    void testCalculateAverageVector() {
        // Given
        List<float[]> vectors = List.of(
            new float[]{1.0f, 2.0f, 3.0f},
            new float[]{4.0f, 5.0f, 6.0f},
            new float[]{7.0f, 8.0f, 9.0f}
        );

        // When
        float[] avg = personalizationService.calculateAverageVector(vectors);

        // Then
        assertArrayEquals(new float[]{4.0f, 5.0f, 6.0f}, avg, 0.001f);
    }

    private void createFeedback(Long chatId, Long bookId, FeedbackType type) {
        SearchFeedback feedback = SearchFeedback.builder()
            .chatId(chatId)
            .query("test")
            .bookId(bookId)
            .type(type)
            .build();
        feedbackRepository.save(feedback);
    }
}
```

---

## 6. 성능 최적화

### 6.1 캐싱 전략

**문제:** 매 검색마다 선호도 벡터 계산은 느림

**해결:** Redis에 24시간 캐싱

```java
@Cacheable(value = "userPreferenceVectors", key = "#chatId")
public float[] calculateUserPreferenceVector(Long chatId) {
    // ... 계산 로직
}
```

**캐시 무효화 조건:**
1. 새로운 피드백 저장 시
2. 24시간 경과 후 자동 만료

```java
// 피드백 저장 시 캐시 무효화
@CacheEvict(value = "userPreferenceVectors", key = #feedback.chatId")
public void recordFeedback(FeedbackRequest feedback) {
    // ... 저장 로직
}
```

### 6.2 비동기 계산 (선택 사항)

**문제:** 선호도 벡터 계산이 검색 응답 시간 지연

**해결:** 비동기로 백그라운드 계산

```java
@Async
public CompletableFuture<float[]> calculateUserPreferenceVectorAsync(Long chatId) {
    float[] vector = calculateUserPreferenceVector(chatId);
    return CompletableFuture.completedFuture(vector);
}
```

**사용 예시:**
```java
// 검색 결과 즉시 반환 (개인화 없이)
List<Book> results = bookSearchService.search(query);

// 백그라운드에서 선호도 계산
personalizationService.calculateUserPreferenceVectorAsync(chatId)
    .thenAccept(vector -> {
        // 다음 검색부터 반영
    });
```

---

## 학습 요약

### 핵심 개념

1. **사용자 선호도 벡터**
   - GOOD 피드백 도서들의 임베딩 평균
   - 사용자 취향의 중심을 나타내는 1024차원 벡터

2. **콜드 스타트 문제**
   - 신규 사용자는 피드백이 없어 개인화 불가
   - 해결: 최소 3개 GOOD 피드백 시 개인화 시작

3. **데이터 추출 파이프라인**
   - GOOD 필터링 → 중복 제거 → 최신 20개 제한
   - 최근성 반영으로 변화하는 취향 적용

4. **성능 최적화**
   - 캐싱: 24시간 동안 선호도 벡터 저장
   - 캐시 무효화: 새 피드백 시 갱신

### 구현 완료 항목

- [ ] BookRepository.findEmbeddingsByIds() 쿼리 추가
- [ ] PersonalizationService 클래스 생성
- [ ] calculateUserPreferenceVector() 메서드 구현
- [ ] getLikedBookIds() 헬퍼 메서드 구현
- [ ] calculateAverageVector() 벡터 평균 계산 구현
- [ ] 캐싱 설정 (@Cacheable)
- [ ] 단위 테스트 작성

### 다음 단계

이제 사용자의 선호도를 벡터로 표현할 수 있게 되었습니다. 다음 단계에서는:

**[03. 개인화 검색 결과 재정렬](./03.personalized-ranking.md)**

- 선호도 벡터와 각 도서의 유사도를 어떻게 계산할까요?
- RRF 점수와 유사도를 어떻게 조합할까요?
- 최종 순위는 어떻게 결정될까요?

---

**다음**: [03. 개인화 검색 결과 재정렬](./03.personalized-ranking.md) →
