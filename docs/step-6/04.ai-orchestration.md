# 04. AI 오케스트레이션: 다중 Function 조합

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- **Level 1 완료**: 단일 Function (내부 DB 검색)
- **Level 2 완료**: Fallback 패턴 (내부 DB → 외부 API)
- Spring AI Function Calling 기초
- 함수형 프로그래밍 기초

---

## 1. 개요

Level 1-2에서는 AI가 단일 함수를 호출했습니다. 이제 **여러 함수를 연속해서 호출**하는 오케스트레이션을 구현해 보겠습니다.

**학습 로드맵:**
```
✓ Level 1 (완료):   단일 Function - 내부 DB 검색
✓ Level 2 (완료):   Fallback 패턴 - 내부 DB → 외부 API
→ Level 3 (이 문서): 다중 Function 조합 & 오케스트레이션
```

**Level 3 학습 목표:**
- 오케스트레이션 개념과 원리 이해
- 여러 함수를 연속 호출하는 방법
- 함수 간 데이터 전달 메커니즘
- 시스템 프롬프트로 호출 순서 제어
- 복잡한 사용자 요청 처리 패턴

---

## 2. 오케스트레이션 이론

### 2.1. 오케스트레이션이란?

**정의**
```
오케스트레이션(Orchestration)이란 여러 컴포넌트나 서비스가
협력하여 복잡한 작업을 수행하도록 조정하는 프로세스입니다.

AI 컨텍스트에서: AI가 여러 Function을 순차적으로 호출하여
사용자의 복잡한 요청을 처리하는 패턴입니다.
```

**비유: 교향곡 지휘자**
```
🎼 오케스트레이션 = 교향곡 지휘자가 여러 악기 연주자를 조율하는 것

지휘자(AI)              악기부(Function들)
    ↓                        ↓
- 악보 해석            - 검색 Function
- 악기 선택            - 대출 확인 Function
- 연주 순서 지시        - 리뷰 Function
- 전체 조율            - 상세 조회 Function
```

### 2.2. 왜 오케스트레이션이 필요한가?

**문제: 현실의 사용자 요청은 복잡하다**

```
단순 요청:
"자바 책 찾아줘"
→ searchBooks() 함수 하나로 충분 ✓

복잡한 요청:
"자바의 정석 책 어때? 빌릴 수도 있어? 리뷰도 보여줘"
→ 책 검색
→ 대출 가능 확인 (ISBN 필요)
→ 리뷰 조회 (bookId 필요)
→ 세 가지 Function을 조합해야 함 ✗
```

**해결: 오케스트레이션 패턴**

```
복잡한 요청을 여러 단계로 분해:

[단계 1] 책 검색
    ↓ searchBooks("자바의 정석")
    결과: bookId=123, isbn="9788960777331"

[단계 2] 대출 가능 확인
    ↓ checkLoanAvailability("9788960777331")
    결과: 15개 도서관 대출 가능

[단계 3] 리뷰 조회
    ↓ getReviews(123)
    결과: 평점 4.7/5.0 (15개 리뷰)

[단계 4] 종합 응답 생성
```

### 2.3. 오케스트레이션 유형

**유형 1: 순차적 오케스트레이션 (Sequential)**
```
Function 1 → Function 2 → Function 3
   ↓            ↓            ↓
  데이터1      데이터2      최종 결과
```
- 각 함수의 출력이 다음 함수의 입력으로 사용
- 현재 Level 3에서 구현할 방식

**유형 2: 병렬 오케스트레이션 (Parallel)**
```
        → Function 1
       ↓
요청 → Function 2 → 결과 통합
       ↓
        → Function 3
```
- 독립적인 함수들을 동시에 호출
- 결과를 나중에 통합

**유형 3: 조건부 오케스트레이션 (Conditional)**
```
   요청
     ↓
   조건판단
    /  \
  참   거짓
  ↓     ↓
Func1  Func2
```
- 조건에 따라 다른 함수 호출

### 2.4. Spring AI에서의 오케스트레이션 메커니즘

**작동 원리**

```
┌─────────────────────────────────────────────────────────────┐
│                  Spring AI 오케스트레이션 과정              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 사용자 입력 분석                                        │
│     - 의도 파악 (NLU)                                       │
│     - 필요한 함수 식별                                      │
│     - 호출 순서 계획                                        │
│                                                             │
│  2. 함수 호출 순차 실행                                    │
│     ┌─────────┐    ┌─────────┐    ┌─────────┐             │
│     │ Func 1  │───→│ Func 2  │───→│ Func 3  │             │
│     └─────────┘    └─────────┘    └─────────┘             │
│          ↓              ↓              ↓                    │
│       결과1         결과2         결과3                   │
│                                                             │
│  3. 결과 통합 및 응답 생성                                  │
│     - 모든 결과 수집                                         │
│     - 자연어 응답 변환                                      │
│     - 사용자에게 반환                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**핵심 개념: 자동 파라미터 전달**
```
Function 1의 결과가 Function 2의 입력으로 자동 전달

예시:
searchBooks("자바의 정석")
  ↓ 결과: { bookId: 123, isbn: "9788960777331" }

getReviews(123)  ← AI가 bookId를 자동 추출하여 호출
  ↓ 결과: { reviews: [...] }

최종 응답 생성
```

---

## 3. 오케스트레이션 패턴

### 3.1. 함수 체이닝 (Function Chaining)

**개념**
```
함수 체이닝: 한 함수의 출력이 다음 함수의 입력이 되는 패턴

장점:
- 작업을 분해하여 관리
- 각 함수는 단일 책임을 가짐
- 재사용성 향상
```

**도서관 시스템 예시**

```
체인: 검색 → 대출 확인 → 리뷰 조회

searchBooks("자바의 정석")
  ↓ BookSearchResult {bookId: 123, isbn: "978..."}

checkLoanAvailability("978...")
  ↓ LoanCheckResult {available: true, count: 15}

getReviews(123)
  ↓ ReviewResult {reviews: [...]}

최종: "자바의 정석은 15개 도서관에서 대출 가능합니다.
       리뷰 평점은 4.7/5.0입니다."
```

### 3.2. 파이프라인 패턴 (Pipeline)

**개념**
```
파이프라인: 데이터가 여러 처리 단계를 통과하는 패턴

[입력] → [변환1] → [변환2] → [변환3] → [출력]

각 단계는 독립적이지만 순서가 중요함
```

**도서관 시스템 적용**

```
데이터 파이프라인:

원시 검색어      정규화      검색       보강       응답
"자바의   →   "자바의   →   검색   → 대출정보  →  "
 정석"       정석"                추가
```

### 3.3. 전략 패턴 (Strategy)

**개념**
```
전략 패턴: 상황에 따라 다른 알고리즘을 선택하는 패턴

if (상황 A) {
    전략1 실행
} else if (상황 B) {
    전략2 실행
}
```

**도서관 시스템 적용**

```
if (사용자가 ISBN 입력) {
    → 정확한 ISBN 검색
} else if (사용자가 제목 입력) {
    → 제목으로 검색 + 대출 확인
} else if (사용자가 지역 명시) {
    → 지역 기반 대출 가능 확인
}
```

---

## 4. Level 3: 오케스트레이션 구현

Level 2의 Fallback 패턴을 유지하면서, 리뷰 조회 함수를 추가하여 오케스트레이션을 구현해 보겠습니다.

### STEP 1: 리뷰 조회 Function 추가

**ReviewFunction.java** - 새로 추가
```java
package com.nhnacademy.library.ai.function;

import com.nhnacademy.library.core.review.service.ReviewService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Description;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.function.Function;

/**
 * Level 3: 리뷰 조회 Function
 *
 * 검색 → 리뷰 확인까지 연속 호출 가능
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class ReviewFunction {

    private final ReviewService reviewService;

    /**
     * 도서 리뷰 조회 함수
     *
     * 오케스트레이션에서는 searchBooks()의 결과로 얻은
     * bookId를 파라미터로 사용하게 됩니다.
     */
    @Description("도서의 리뷰 목록을 조회합니다. 평점과 리뷰 내용을 제공합니다.")
    public Function<Long, ReviewResult> getReviews() {
        return bookId -> {
            log.info("[Function] 리뷰 조회: bookId={}", bookId);

            try {
                var reviews = reviewService.getReviewsByBookId(bookId);

                return ReviewResult.builder()
                    .bookId(bookId)
                    .count(reviews.size())
                    .reviews(reviews.stream()
                        .map(r -> new ReviewItem(
                            r.content(),
                            r.rating()
                        ))
                        .toList())
                    .build();

            } catch (Exception e) {
                log.error("[Function] 리뷰 조회 실패", e);
                return ReviewResult.builder()
                    .bookId(bookId)
                    .count(0)
                    .reviews(List.of())
                    .build();
            }
        };
    }

    @Builder
    public record ReviewResult(
        long bookId,
        int count,
        List<ReviewItem> reviews
    ) {
        record ReviewItem(String content, int rating) {}
    }
}
```

### STEP 2: ChatClient에 여러 함수 등록

**AiConfig.java** - Level 3로 업그레이드
```java
package com.nhnacademy.library.core.config;

import com.nhnacademy.library.ai.function.BookSearchFunction;
import com.nhnacademy.library.ai.function.ReviewFunction;
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * AI 설정 - Level 3
 *
 * 여러 함수가 등록되어 있습니다.
 * AI가 필요에 따라 하나 또는 여러 함수를 연속 호출합니다.
 */
@Configuration
@RequiredArgsConstructor
public class AiConfig {

    private final ChatModel chatModel;
    private final BookSearchFunction bookSearchFunction;  // Level 2: Fallback 검색
    private final ReviewFunction reviewFunction;            // Level 3: 리뷰 조회

    @Bean
    public ChatClient chatClient() {
        return ChatClient.builder(chatModel)
            .defaultFunctions(
                // Level 2: 내부 DB → 도서관정보나루 (Fallback)
                bookSearchFunction.searchBooks(),

                // Level 3: 리뷰 조회
                reviewFunction.getReviews()
            )
            .build();
    }
}
```

### STEP 3: 오케스트레이션 서비스

여러 함수를 조합해서 사용하는 서비스를 만듭니다.

**AiOrchestrationService.java**
```java
package com.nhnacademy.library.ai.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.stereotype.Service;

/**
 * AI 오케스트레이션 서비스 - Level 3
 *
 * AI가 여러 함수를 연속해서 호출하여 복잡한 요청을 처리합니다.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AiOrchestrationService {

    private final ChatClient chatClient;

    /**
     * 기본 오케스트레이션
     * AI가 필요한 함수들을 자동으로 선택하고 호출합니다.
     */
    public String orchestrate(String userMessage) {
        log.info("사용자 요청: {}", userMessage);

        String response = chatClient.prompt()
            .user(userMessage)
            .call()
            .content();

        log.info("AI 응답: {}", response);
        return response;
    }

    /**
     * 시스템 프롬프트를 활용한 오케스트레이션
     *
     * 시스템 프롬프트로 AI에게 함수 호출 순서를 가이드할 수 있습니다.
     */
    public String orchestrateWithPrompt(String userMessage) {
        String systemPrompt = """
            당신은 도서관 도우미 AI입니다.

            ## 사용 가능한 도구
            1. searchBooks: 내부 DB와 도서관정보나루에서 도서 검색
            2. getReviews: 도서 리뷰 조회

            ## 오케스트레이션 가이드
            복잡한 요청을 처리할 때는 다음 순서를 따르세요:

            [리뷰 요청 시]
            1. 먼저 searchBooks로 책 검색 (bookId 확보)
            2. bookId로 getReviews 호출
            3. 두 결과를 종합하여 응답

            예시: "자바의 정석 어때? 리뷰도 알려줘"
            → searchBooks("자바의 정석")
            → getReviews(bookId)
            → 종합 응답

            ## 응답 스타일
            - 각 단계의 결과를 명확히 전달
            - 데이터 출처를 명시 (내부 DB vs 도서관정보나루)
            - 다음 단계 제안
            """;

        String response = chatClient.prompt()
            .system(systemPrompt)
            .user(userMessage)
            .call()
            .content();

        return response;
    }
}
```

### STEP 4: 컨트롤러

**AiOrchestrationController.java**
```java
package com.nhnacademy.library.front.web;

import com.nhnacademy.library.ai.service.AiOrchestrationService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * AI 오케스트레이션 컨트롤러 - Level 3
 */
@Controller
@RequiredArgsConstructor
public class AiOrchestrationController {

    private final AiOrchestrationService aiOrchestrationService;

    @PostMapping("/ai/orchestrate")
    @ResponseBody
    public String orchestrate(@RequestParam String message) {
        return aiOrchestrationService.orchestrateWithPrompt(message);
    }
}
```

---

## 5. 실행 흐름 상세 분석

### 5.1. 함수 체이닝 흐름 (상세)

```
사용자: "자바의 정석 책 정보랑 리뷰도 알려줘"
   ↓
┌─────────────────────────────────────────────────────────────┐
│                    AI 분석 단계                          │
├─────────────────────────────────────────────────────────────┤
│ 1. 사용자 의도 파악                                        │
│    - "책 정보 필요" + "리뷰 필요"                         │
│                                                             │
│ 2. 필요한 함수 식별                                         │
│    - searchBooks: 책 검색                                 │
│    - getReviews: 리뷰 조회                                │
│                                                             │
│ 3. 호출 순서 계획                                          │
│    - searchBooks 먼저 호출 → bookId 확보                  │
│    - getReviews(bookId) 순차 호출                          │
└─────────────────────────────────────────────────────────────┘
   ↓
┌─────────────────────────────────────────────────────────────┐
│                  함수 실행 단계                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [1단계] searchBooks 호출                                   │
│    ↓                                                        │
│  Function: searchBooks("자바의 정석")                       │
│    ↓                                                        │
│  [내부 DB 검색]                                             │
│    - 결과: 0권                                              │
│    ↓                                                        │
│  [도서관정보나루 검색] (Fallback)                           │
│    - 결과: 125권                                            │
│    ↓                                                        │
│  반환: BookSearchResult {                                   │
│    count: 125,                                              │
│    source: "도서관정보나루",                                │
│    books: [                                                 │
│      {bookId: 123, isbn: "9788960777331", ...},            │
│      ...                                                     │
│    ]                                                        │
│  }                                                          │
│                                                             │
│  [2단계] getReviews 호출 (1단계 결과 활용)                  │
│    ↓                                                        │
│  Function: getReviews(123)  ← AI가 bookId 자동 추출        │
│    ↓                                                        │
│  [내부 DB 리뷰 조회]                                         │
│    - 리뷰: 15개                                             │
│    - 평균: 4.7/5.0                                          │
│    ↓                                                        │
│  반환: ReviewResult {                                       │
│    bookId: 123,                                             │
│    count: 15,                                               │
│    reviews: [...]                                           │
│  }                                                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
   ↓
┌─────────────────────────────────────────────────────────────┐
│                  응답 생성 단계                             │
├─────────────────────────────────────────────────────────────┤
│  AI가 두 함수의 결과를 종합하여 자연어 응답 생성            │
│                                                             │
│  "도서관정보나루에서 '자바의 정석'을 찾았습니다.             │
│   - ISBN: 9788960777331                                    │
│   - 저자: 남궁성                                            │
│                                                             │
│   리뷰 요약:                                                 │
│   - 평점: 4.7/5.0 (15개 리뷰)                              │
│   - '자바 기초에 최고의 책입니다'                           │
│   - '초보자에게 강력 추천'                                 │
│                                                             │
│   이 책을 추천합니다!"                                     │
└─────────────────────────────────────────────────────────────┘
```

### 5.2. Spring AI 내부 동작 원리

```
┌───────────────────────────────────────────────────────────┐
│               Spring AI Function Calling 내부             │
├───────────────────────────────────────────────────────────┤
│                                                           │
│  1. 함수 등록 (등록 시점)                                 │
│     ┌────────────────────────────────────────┐            │
│     │ Function Registry 생성                │            │
│     │ - searchBooks()                       │            │
│     │ - getReviews()                        │            │
│     └────────────────────────────────────────┘            │
│              ↓                                              │
│     JSON Schema 생성 (각 함수에 대해)                     │
│     {                                                      │
│       "searchBooks": {                                    │
│         "parameters": {                                   │
│           "query": {"type": "string"},                    │
│           "limit": {"type": "integer"}                    │
│         }                                                  │
│       }                                                    │
│     }                                                      │
│                                                           │
│  2. 사용자 요청 처리 (실행 시점)                          │
│     사용자 메시지 + 함수 스키마 → LLM에 전송               │
│                                                           │
│  3. LLM 판단                                              │
│     - 함수 호출 필요 여부 판단                             │
│     - 필요하다면 어느 함수인지 선택                        │
│     - 파라미터 값 추출                                     │
│                                                           │
│  4. 함수 실행                                              │
│     Spring AI가 함수를 직접 호출                           │
│     결과를 JSON으로 변환하여 LLM에 반환                    │
│                                                           │
│  5. 반복 (체이닝인 경우)                                  │
│     3~4단계를 필요한 만큼 반복                             │
│                                                           │
│  6. 최종 응답 생성                                        │
│     LLM이 모든 결과를 종합하여 최종 응답 생성              │
│                                                           │
└───────────────────────────────────────────────────────────┘
```

---

## 6. 실행 예시

### 예시 1: 검색 + 리뷰

```
POST /ai/orchestrate
message: "자바의 정석 책 정보랑 리뷰도 알려줘"

AI 동작:
1. searchBooks("자바의 정석") 호출
2. ISBN 9788960777331, bookId 123 확보
3. getReviews(123) 호출
4. 종합 응답 생성

응답:
"도서관정보나루 검색 결과:
- 제목: 자바의 정석
- 저자: 남궁성
- ISBN: 9788960777331
- 출처: 도서관정보나루

리뷰 요약:
- 평점: 4.7/5.0 (15개 리뷰)
- '자바 기초 다지기에 최고'
- '초보자 강력 추천'"
```

---

## 7. Level 1-3 진화 과정

| 단계 | 함수 개수 | 패턴 | 주요 기능 | 복잡도 |
|-----|---------|-----|---------|--------|
| Level 1 | 1개 | 단일 호출 | 내부 DB 검색 | ★☆☆ |
| Level 2 | 1개 | Fallback | 내부 DB → 외부 API | ★★☆ |
| Level 3 | 2개+ | 오케스트레이션 | 함수 체이닝 | ★★★ |

### 진화 다이어그램

```
Level 1: 단일 함수
┌─────────┐
│ 사용자   │───→ ChatClient ───→ Function ───→ DB
└─────────┘

Level 2: Fallback 패턴
┌─────────┐
│ 사용자   │───→ ChatClient ───→ Function ─┬──→ 내부 DB
└─────────┘                            │
                                        └──→ 외부 API (조건부)

Level 3: 오케스트레이션
┌─────────┐
│ 사용자   │───→ ChatClient ─→ Function 1 ─┬──→ Function 2
└─────────┘                        │        │
                                   데이터    │
                                   전달     │
                                            ↓
                                     결과 종합
```

---

## 8. 실습 미션: ⭐⭐⭐ 오케스트레이션 구현

**난이도**: 중급 | **예상 시간**: 2시간

이 섹션에서 배운 오케스트레이션 패턴을 실습해 보세요.

> **📘 전체 미션 가이드**: 5단계 난이도별 미션이 준비되어 있습니다.
>
> **상세 미션**: [05.mission-scenarios.md](./05.mission-scenarios.md#-미션-3-조건부-function-호출---대출-가능-확인)

### 미션 개요

```
사용자: "자바의 정석 책 어때? 빌릴 수 있어? 리뷰도 보여줘"

AI 동작:
1. search_books Function 호출 → bookId, ISBN 확보
2. check_loan_availability Function 호출 → ISBN으로 대출 가능 확인
3. get_reviews Function 호출 → bookId로 리뷰 조회
4. 세 결과를 종합하여 사용자에게 친절하게 응답
```

### 실습 과정

#### STEP 1: 대출 가능 확인 Function 추가

먼저 대출 가능 확인을 위한 Function을 구현하세요.

```java
@Description("특정 ISBN의 도서가 전국 도서관에서 대출 가능한지 확인합니다")
public Function<LoanCheckRequest, LoanCheckResult> checkLoanAvailability() {
    return request -> {
        log.info("[Function] 대출 가능 확인: isbn={}", request.isbn());

        List<LoanItemInfo> loanItems = libraryApiClient.searchLoanItemsByIsbn(
            request.isbn(),
            request.region()  // null이면 전체 검색
        );

        return LoanCheckResult.builder()
            .isbn(request.isbn())
            .availableCount(loanItems.size())
            .libraries(loanItems.stream()
                .map(li -> LoanItem.builder()
                    .libraryName(li.libraryName())
                    .location(li.location())
                    .build())
                .toList())
            .build();
    };
}
```

#### STEP 2: 3단계 체이닝 시스템 프롬프트 작성

AI가 순서대로 함수를 호출하도록 가이드하세요.

```java
String systemPrompt = """
    당신은 도서관 도우미 AI입니다.

    ## 사용 가능한 도구
    1. searchBooks: 내부 DB와 도서관정보나루에서 도서 검색
    2. checkLoanAvailability: ISBN으로 대출 가능 도서관 확인
    3. getReviews: 도서 리뷰 조회

    ## 오케스트레이션 순서 (중요!)
    복잡한 요청을 처리할 때는 다음 순서를 따르세요:

    [책 정보 + 대출 + 리뷰 요청 시]
    1. searchBooks로 책 검색 (bookId, ISBN 확보)
    2. ISBN으로 checkLoanAvailability 호출
    3. bookId로 getReviews 호출
    4. 세 결과를 종합하여 응답

    예시: "자바의 정석 어때? 빌릴 수? 리뷰도"
    → searchBooks("자바의 정석")
    → checkLoanAvailability("9788960777331")
    → getReviews(123)
    → 종합 응답
    """;
```

#### STEP 3: 조건부 오케스트레이션 구현

상황에 따라 다른 처리를 하도록 개선해 보세요.

```java
String systemPrompt = """
    ## 조건부 처리 가이드

    if (ISBN이 제공됨) {
        → searchBooksByIsbn으로 정확한 검색
    } else if (제목만 제공됨) {
        → searchBooks로 검색 후 ISBN 확보
    }

    if (대출 가능 질문 있음) {
        → checkLoanAvailability 추가 호출
    }

    if (리뷰 요청 있음) {
        → getReviews 추가 호출
    }

    ## 응답 스타일
    - 각 단계의 결과를 명확히 전달
    - 대출 가능 도서관이 있는 경우 구체적으로 안내
    - 리뷰 평점과 주요 내용 요약
    """;
```

---

## 9. 학습 체크리스트

---

## 9. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

### 개념 이해
- [ ] 오케스트레이션이 무엇인지 안다
- [ ] 함수 체이닝 패턴을 이해한다
- [ ] 파이프라인 패턴을 이해한다
- [ ] 전략 패턴을 이해한다

### 기술 이해
- [ ] 여러 함수를 등록할 수 있다
- [ ] AI가 여러 함수를 연속해서 호출하는 것을 이해한다
- [ ] 함수 간 데이터 전달이 이루어지는 것을 안다
- [ ] 시스템 프롬프트로 호출 순서를 제어할 수 있다
- [ ] Spring AI의 Function Calling 내부 동작을 안다

### 실무 적용
- [ ] 복잡한 사용자 요청을 처리할 수 있다
- [ ] 적절한 시스템 프롬프트를 작성할 수 있다
- [ ] ⭐⭐⭐ 미션 3을 완료했다

---

## 10. 실습 안내

**⭐⭐⭐ 미션 3 실습**

이 섹션에서 학습한 오케스트레이션을 직접 실습해 보세요.

상세 가이드: **[05.mission-scenarios.md → ⭐⭐⭐ 미션 3](./05.mission-scenarios.md#-미션-3-조건부-function-호출---대출-가능-확인)**

**실습 과제:**
- [ ] 대출 가능 확인 Function 구현
- [ ] 3단계 체이닝 구현 (검색 → 대출 확인 → 리뷰)
- [ ] 조건부 오케스트레이션 시스템 프롬프트 작성
- [ ] 테스트 시나리오 작성 및 검증

---

## 11. Week 5 기본 학습 완료!

축하합니다! Level 1부터 Level 3까지 점진적으로 구현해 왔습니다.

**Week 5 성취:**

✅ **Level 1: 기초**
- 단일 Function 구현
- 내부 DB 연동
- Function Calling 기초 이해
- **관련 미션**: [⭐ 미션 1: 단일 Function 호출](./05.mission-scenarios.md#-미션-1-단일-function-调用---도서-검색)

✅ **Level 2: Fallback 패턴**
- 외부 API 연동
- 내부 DB → 외부 API 순서 검색
- 데이터 출처 추적
- 중복 제거
- **관련 미션**: [⭐⭐ 미션 2: 복수 Function 조합](./05.mission-scenarios.md#-미션-2-복수-function-조합---도서--리뷰)

✅ **Level 3: 오케스트레이션**
- 다중 함수 조합
- 함수 체이닝
- 데이터 전달 메커니즘 이해
- 복잡한 시나리오 처리
- **관련 미션**: [⭐⭐⭐ 미션 3: 조건부 Function 호출](./05.mission-scenarios.md#-미션-3-조건부-function-호출---대출-가능-확인)

**🎯 추가 도전 과제:**

실력을 더 키우고 싶다면 다음 미션들을 도전해 보세요:

- **[⭐⭐⭐⭐ 미션 4: 복잡한 워크플로우](./05.mission-scenarios.md#-미션-4-복잡한-워크플로우---대출-예약-시스템)** (3시간)
  - 예약 기능 구현
  - 재고 확인 로직
  - 4단계 이상 체이닝

- **[⭐⭐⭐⭐⭐ 미션 5: 멀티에이전트 협업](./05.mission-scenarios.md#-미션-5-멀티에이전트-협업---도서관-관리-시스템)** (4+시간)
  - 전문 에이전트 분리
  - 에이전트 간 통신
  - 복잡한 협업 시나리오

---

## 12. 다음 학습 로드맵

Week 5 기본 학습을 완료했다면 다음과 같은 주제를 학습해 보세요:

**추천 학습 주제:**

| 주제 | 설명 | 관련 문서 |
|-----|------|---------|
| ChatMemory | 대화 컨텍스트 유지 | Spring AI 공식 문서 |
| RAG (검색 증강 생성) | 벡터 DB 활용 | Week 6 예정 |
| Stream 응답 | 실시간 응답 생성 | Spring AI 공식 문서 |
| 멀티모달 | 이미지/오디오 처리 | Spring AI 공식 문서 |
| Tool Use | MCP 표준 활용 | [01.understanding-mcp.md](./01.understanding-mcp.md) |
