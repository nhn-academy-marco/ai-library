# 02. 기본 검색: LIKE 기반 동적 쿼리 구현

Week 1의 두 번째 단계로, 데이터베이스에 적재된 도서 데이터를 검색하기 위한 백엔드 로직(Repository) 구현 과정을 설명합니다.

## 1. 개요

단순히 데이터를 저장하는 것을 넘어, 사용자가 원하는 도서를 효율적으로 찾을 수 있는 검색 기능을 구현합니다. AI 기반 검색으로 나아가기 전, RDBMS에서 제공하는 가장 기본적인 검색 방식인 `LIKE` 연산의 개념을 익히고 QueryDSL을 통해 구현합니다. 계층형 아키텍처(Controller-Service-Repository)를 준수하며, DTO를 활용한 데이터 전달 방식을 학습합니다.

## 2. 주요 개념

### 2.1. LIKE 검색
- SQL의 `LIKE %keyword%` 연산을 활용하는 방식입니다.
- **특징**: 구현이 매우 간단하지만, 데이터 양이 많아질수록 성능이 급격히 저하됩니다. (중간 일치 검색 시 인덱스(Index) 활용 불가)

### 2.2. QueryDSL BooleanBuilder
- 여러 검색 조건(제목, 저자, 내용 등)을 동적으로 조합하기 위해 사용합니다.
- `or()` 연산자를 통해 다양한 필드에 대해 키워드 포함 여부를 체크하는 동적 쿼리(Dynamic Query)를 생성합니다.

### 2.3. 계층 분리 및 DTO (Data Transfer Object)
- **Controller → Service → Repository** 흐름을 유지합니다.
- 요청과 응답 데이터는 엔티티(Entity)가 아닌 별도의 DTO(`BookSearchRequest`, `BookSearchResponse`)를 정의하여 사용합니다.

## 3. 구현 가이드 (Step-by-Step)

### 3.1. DTO (Data Transfer Object) 정의
계층 간 데이터 전송을 위해 요청(`Request`)과 응답(`Response`) DTO를 각각 정의합니다.

**BookSearchRequest.java (요청 DTO)**
```java
public record BookSearchRequest(
    @Size(max = 100)
    String keyword,

    @Size(max = 20)
    String isbn,

    SearchType searchType,
    float[] vector,
    Boolean isWarmUp
) {
    // 기본값 설정 로직 등 포함
}
```

**BookSearchResponse.java (응답 DTO)**
```java
@Getter
@NoArgsConstructor
public class BookSearchResponse {
    private Long id;
    private String isbn;
    private String title;
    private String authorName;
    private String publisherName;
    // ... 기타 필드

    @QueryProjection // QueryDSL Projections를 위해 사용
    public BookSearchResponse(Long id, String isbn, String title, ...) {
        this.id = id;
        this.isbn = isbn;
        this.title = title;
        // ... 필드 초기화
    }
}
```

### 3.2. Repository 인터페이스 확장
Spring Data JPA의 기본 기능을 넘어선 커스텀 쿼리(QueryDSL)를 위해 인터페이스를 분리합니다.

**BookRepositoryCustom.java**
```java
public interface BookRepositoryCustom {
    Page<BookSearchResponse> search(Pageable pageable, BookSearchRequest request);
}
```

### 3.3. QueryDSL 구현체 작성
`BookRepositoryImpl` 클래스에서 실제 검색 로직을 작성합니다. `BooleanBuilder`를 사용하여 동적 쿼리를 구성합니다.

**BookRepositoryImpl.java**
```java
@Component
@RequiredArgsConstructor
public class BookRepositoryImpl implements BookRepositoryCustom {

    private final JPAQueryFactory queryFactory;
    QBook book = QBook.book;

    @Override
    public Page<BookSearchResponse> search(Pageable pageable, BookSearchRequest request) {
        List<BookSearchResponse> results = queryFactory
                .select(new QBookSearchResponse(
                        book.id, book.isbn, book.title, ...
                ))
                .from(book)
                .where(commonWhere(request)) // 동적 조건 적용
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .fetch();

        long total = queryFactory
                .select(book.count())
                .from(book)
                .where(commonWhere(request))
                .fetchOne();

        return new PageImpl<>(results, pageable, total);
    }

    private BooleanBuilder commonWhere(BookSearchRequest request) {
        BooleanBuilder builder = new BooleanBuilder();
        if (StringUtils.isNotEmpty(request.keyword())) {
            builder.and(book.title.containsIgnoreCase(request.keyword())
                .or(book.authorName.containsIgnoreCase(request.keyword())));
        }
        if (StringUtils.isNotEmpty(request.isbn())) {
            builder.and(book.isbn.eq(request.isbn()));
        }
        return builder;
    }
}
```

## 4. 전체 흐름 (Back-end)

1. **검색 요청 수신**: 서비스 계층에서 페이징 정보(`Pageable`)와 검색 조건(`BookSearchRequest`)을 전달받습니다.
2. **동적 쿼리 생성**: `BookRepositoryImpl`에서 `BooleanBuilder`를 사용하여 조건에 맞는 검색 필터를 구성합니다.
3. **데이터 조회**: QueryDSL을 통해 생성된 SQL이 실행되며, Projections를 통해 DTO 리스트가 반환됩니다.
4. **결과 반환**: 전체 카운트 쿼리를 포함하여 `Page<BookSearchResponse>` 형태로 결과를 서비스 계층에 반환합니다.

## 5. 학습 포인트

*   **RDBMS 검색의 기본 이해**: `LIKE` 연산의 개념을 이해하고 기본적인 검색 기능을 구현합니다.
*   **타입 세이프 쿼리**: 문자열 기반의 SQL 대신 자바 코드로 쿼리를 작성할 때의 안정성을 이해합니다.
*   **검색 로직 구현**: `BooleanBuilder`를 활용하여 여러 필드에 걸친 동적 검색 기능을 구현하는 방법을 익힙니다.

## 6. 심화 학습 (Study Topics)

백엔드 개발의 핵심인 쿼리(Query)와 데이터 전달 방식을 쉽게 이해해 봅시다.

### 6.1. 필요한 것만 골라 담기 (Projections)
식당에서 메뉴판 전체를 가져오는 대신, 내가 주문한 음식 리스트만 적힌 계산서를 받는 것과 같습니다.
- **비유**: 도서 정보가 100가지가 넘더라도 화면에는 '제목'과 '저자'만 필요하다면, 그 두 가지만 쏙 뽑아서 가져오는 것이 훨씬 빠르고 효율적입니다.

### 6.2. 자바 코드로 SQL 만들기 (QueryDSL)
복잡한 SQL 문장을 직접 타이핑하다 보면 오타가 나기 쉽습니다. QueryDSL은 자바 코드로 쿼리를 짜게 도와주어 실수를 미리 방지해 줍니다.
- **비유**: 레고 블록을 조립하듯이 쿼리 조건을 하나씩 끼워 맞추는 방식입니다. 잘못된 블록을 끼우려 하면 컴퓨터가 즉시 알려줍니다.

### 6.3. 동적 쿼리 - 상황에 따라 변하는 필터
사용자가 제목만 검색할 수도 있고, ISBN만 검색할 수도 있습니다. 이런 다양한 상황에 맞춰 쿼리가 유연하게 변하는 것을 말합니다.
- **비유**: 온라인 쇼핑몰에서 '카테고리', '가격대', '브랜드' 필터를 체크할 때마다 목록이 바뀌는 원리와 같습니다.

## 7. 참고 링크

- [QueryDSL Reference - BooleanBuilder](http://querydsl.com/static/querydsl/latest/reference/html/ch02s02.html#d0e1445)
- [QueryDSL Reference - Projections](http://querydsl.com/static/querydsl/latest/reference/html/ch03s02.html)
- [Spring Data JPA Reference - Querydsl 연동](https://docs.spring.io/spring-data/jpa/reference/repositories/core-extensions.html#core.extensions.querydsl)
