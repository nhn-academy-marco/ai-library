# 04. 성능 최적화: 인덱싱과 전문 검색(Full Text Search)

Week 1의 네 번째 단계로, 구현된 검색 기능의 성능을 분석하고 데이터베이스 인덱스(Index)를 통해 이를 최적화하는 방법과 RDBMS 기반 전문 검색(Full Text Search)의 심화 내용을 학습합니다.

## 1. 개요

데이터가 수천 건일 때는 인덱스 없이도 빠르게 검색되는 것처럼 보이지만, 수만 건, 수백만 건으로 늘어나면 검색 속도는 급격히 느려집니다. 본 문서에서는 RDBMS의 인덱스 원리를 이해하고, `LIKE` 검색 최적화 전략과 더불어 대량의 텍스트를 효율적으로 검색하기 위한 전문 검색(Full Text Search)의 이론 및 구현 방법을 배웁니다.

## 2. LIKE 검색과 인덱스 (B-Tree)

가장 일반적인 `B-Tree` 인덱스는 특정 조건에서만 `LIKE` 연산의 성능을 높여줍니다.

### 2.1. 인덱스 설정 대상 컬럼
검색 조건으로 자주 사용되는 다음 컬럼들이 인덱스 생성의 주 대상입니다:
- `isbn`: 정확한 일치(Equal) 검색에 주로 사용 (이미 유니크 인덱스(Unique Index)가 걸려 있는 경우가 많음)
- `title`: 도서 제목 검색
- `author_name`: 저자명 검색
- `publisher_name`: 출판사명 검색

### 2.2. 인덱스 생성을 위한 SQL 예시
PostgreSQL에서 각 컬럼에 대해 B-Tree 인덱스를 생성하는 명령입니다.
```sql
-- 제목 인덱스 생성
CREATE INDEX idx_book_title ON books (title);

-- 저자명 인덱스 생성
CREATE INDEX idx_book_author ON books (author_name);

-- 출판사명 인덱스 생성
CREATE INDEX idx_book_publisher ON books (publisher_name);
```

### 2.3. 인덱스를 타는 유형 (Index Scan)
- **전방 일치 (Prefix Match)**: `keyword%`
    - 예: `WHERE title LIKE '자바%'`
    - 원리: 인덱스는 정렬되어 있으므로 '자바'로 시작하는 구간만 찾으면 됩니다. 전화번호부에서 '김'씨 성을 가진 사람을 찾는 것과 같습니다.

### 2.4. 인덱스를 타지 않는 유형 (Full Table Scan)
- **후방 일치 (Suffix Match)**: `%keyword`
    - 예: `WHERE title LIKE '%프로그래밍'`
- **부분 일치 (Infix Match)**: `%keyword%`
    - 예: `WHERE title LIKE '%자바%'`
- **이유**: 문자열의 중간이나 끝이 검색어인 경우, 인덱스가 정렬되어 있어도 처음부터 끝까지 전체 테이블 스캔(Full Table Scan)을 해야 합니다. 전화번호부에서 이름에 '자'가 들어가는 사람을 찾는 것과 같습니다.

## 3. 인덱스 작동 여부 확인 방법 (EXPLAIN)

인덱스를 만들었다고 해서 항상 사용되는 것은 아닙니다. 데이터베이스 옵티마이저(Optimizer)가 실제로 인덱스를 사용하는지 확인하는 방법을 알아야 합니다.

### 3.1. EXPLAIN 명령어 활용
쿼리 앞에 `EXPLAIN` 또는 `EXPLAIN ANALYZE`를 붙여 실행 계획(Execution Plan)을 확인합니다.
```sql
-- 실행 계획만 확인
EXPLAIN SELECT * FROM books WHERE title LIKE '자바%';

-- 실제로 쿼리를 실행하고 상세 성능 지표 확인
EXPLAIN ANALYZE SELECT * FROM books WHERE title LIKE '자바%';
```

### 3.2. 결과 해석법
- **Index Scan / Index Only Scan**: 인덱스를 성공적으로 사용하고 있음을 의미합니다.
- **Seq Scan (Sequential Scan)**: 인덱스를 타지 않고 전체 테이블을 처음부터 끝까지 읽고 있음을 의미합니다. (인덱스가 없거나, `%keyword%` 형태의 검색인 경우 발생)

## 4. 전문 검색(Full Text Search) 이론

단순히 특정 문자열이 포함되어 있는지를 찾는 `LIKE`와 달리, 텍스트 전체를 분석하여 인덱싱하는 방식입니다.

### 4.1. 핵심 개념: 역색인 (Inverted Index)
- **일반 인덱스 (B-Tree)**: "ID 1번 책의 제목은 무엇인가?"를 찾는 데 유리합니다.
- **역색인 (Inverted Index)**: " '행복'이라는 단어가 포함된 책은 몇 번인가?"를 찾는 데 유리합니다. 마치 책 뒷편의 '찾아보기(색인)' 페이지처럼, 단어별로 해당 단어가 나타난 위치(문서 ID)를 미리 목록화해 두는 방식입니다.

### 4.2. 토큰화 (Tokenization) 및 형태소 분석
- 문장을 유의미한 단위(단어, 형태소)로 쪼개는 과정입니다.
- 검색 엔진은 이 토큰들을 바탕으로 인덱스를 생성합니다. (예: "학교에 가다" -> "학교", "가다")

### 4.3. PostgreSQL의 전문 검색 방식
현재 프로젝트의 데이터베이스 서버에는 전문 검색을 위해 다음 설정이 이미 완료되어 있습니다.

1.  **pg_trgm 확장 설치**: 유사도 검색 및 인덱스 성능 향상을 위해 `pg_trgm` 확장이 설치되어 있습니다.
2.  **한글 검색 설정**: `CREATE TEXT SEARCH CONFIGURATION korean ( COPY = simple );` 명령을 통해 `korean`이라는 이름의 텍스트 검색 설정이 생성되어 있습니다. 이를 통해 한글 텍스트에 대한 토큰화 및 검색이 가능합니다.

### 4.4. LIKE vs Full Text Search 비교

| 비교 항목 | LIKE %keyword% | Full Text Search |
| :--- | :--- | :--- |
| **검색 원리** | 텍스트의 처음부터 끝까지 한 글자씩 비교 (패턴 매칭) | 미리 생성된 역색인(Inverted Index)에서 단어를 찾음 |
| **용도** | 제목, 작성자 등 짧은 필드의 부분 일치 검색 | 도서 소개, 본문 등 대량의 텍스트 검색 |

## 5. Full Text Search 구현 및 최적화

부분 일치(`%keyword%`) 검색의 성능 문제를 해결하기 위해 PostgreSQL은 전문 검색 전용 인덱스와 연산자를 제공합니다.

### 5.1. 주요 메커니즘
1.  **tsvector**: 검색 대상 텍스트를 최적화된 토큰 목록으로 변환한 형태입니다.
2.  **tsquery**: 사용자의 검색어를 검색 조건(쿼리)으로 변환한 형태입니다.
3.  **@@ 연산자**: `tsvector`와 `tsquery`가 매치(Match)되는지 확인하는 연산자입니다.

### 5.2. GIN (Generalized Inverted Index)
- **특징**: 역색인(Inverted Index) 구조를 사용하여 단어(Token)가 포함된 위치를 즉시 찾아냅니다.
- **장점**: 검색 속도가 매우 빠릅니다. (대량의 텍스트 데이터에 최적)
- **단점**: 인덱스 생성 및 업데이트 비용이 높고, 용량을 많이 차지합니다.

### 5.3. 인덱스 및 SQL 쿼리 예시
```sql
-- 도서 본문(book_content)에 대해 GIN 인덱스 생성
CREATE INDEX idx_book_content_fts ON books USING GIN (to_tsvector('korean', book_content));

-- '자바'와 '프로그래밍'이 포함된 도서 내용 검색
SELECT title, book_content
FROM books
WHERE to_tsvector('korean', book_content) @@ plainto_tsquery('korean', '자바 프로그래밍');
```

### 5.4. Spring Data JPA & QueryDSL 적용

PostgreSQL의 전문 검색 기능을 QueryDSL에서 안전하게 호출하기 위해 하이버네이트 6의 `FunctionContributor`를 활용합니다.

#### 1) 커스텀 함수 등록 (`PostgreSQLFunctionContributor`)
하이버네이트가 전문 검색 연산자(`@@`)를 이해할 수 있도록 `ts_match_korean`이라는 이름으로 함수 패턴(Pattern)을 등록합니다.

```java
public class PostgreSQLFunctionContributor implements FunctionContributor {
    @Override
    public void contributeFunctions(FunctionContributions functionContributions) {
        functionContributions.getFunctionRegistry()
                .registerPattern("ts_match_korean", 
                        "to_tsvector('korean', ?1) @@ plainto_tsquery('korean', ?2)",
                        functionContributions.getTypeConfiguration().getBasicTypeRegistry().resolve(StandardBasicTypes.BOOLEAN));
    }
}
```

#### 2) SPI (Service Provider Interface) 등록
작성한 컨트리뷰터를 하이버네이트가 인식할 수 있도록 `src/main/resources/META-INF/services/org.hibernate.boot.model.FunctionContributor` 파일에 클래스 전체 경로를 기입합니다.

#### 3) QueryDSL 구현 (`BookRepositoryImpl`)
`Expressions.booleanTemplate`을 사용하여 등록된 함수를 호출합니다. 하이버네이트 6의 엄격한 타입 체크를 위해 `= true`를 명시하며, 기존 `LIKE` 검색 조건들과 `or` 연산으로 결합합니다.

```java
private BooleanBuilder commonWhere(BookSearchRequest request) {
    BooleanBuilder builder = new BooleanBuilder();

    if (StringUtils.isNotEmpty(request.keyword())) {
        String keyword = request.keyword();

        // 1. LIKE 검색 (제목, 저자, 출판사 등 주요 필드)
        builder.or(book.title.contains(keyword))
                .or(book.authorName.contains(keyword))
                .or(book.publisherName.contains(keyword))
                .or(book.subtitle.contains(keyword))
                .or(book.volumeTitle.contains(keyword));

        // 2. 전문 검색(Full Text Search) (PostgreSQL 전용)
        // book_content 필드에 대해 전문 검색 적용
        BooleanExpression fts = Expressions.booleanTemplate(
                "function('ts_match_korean', {0}, {1}) = true",
                book.bookContent,
                keyword
        );
        builder.or(fts);
    }

    if (StringUtils.isNotEmpty(request.isbn())) {
        builder.and(book.isbn.eq(request.isbn()));
    }

    return builder;
}
```

## 6. 학습 포인트

*   **실행 계획(Explain) 확인**: 실제 쿼리가 인덱스를 타고 있는지 `EXPLAIN ANALYZE` 명령어를 통해 확인하는 습관을 기릅니다.
*   **인덱스의 트레이드 오프**: 인덱스는 조회 속도를 높여주지만, 저장(Insert/Update/Delete) 속도와 저장 공간을 희생한다는 점을 이해합니다.
*   **적절한 도구 선택**: 제목처럼 짧은 필드는 `LIKE` 전방 일치를, 본문처럼 긴 텍스트는 `Full Text Search` 인덱스를 사용하는 전략을 세웁니다.

## 7. 심화 학습 (Study Topics)

검색 성능을 마법처럼 높여주는 기술들을 쉽게 이해해 봅시다.

### 7.1. 인덱스(Index) - 책의 '찾아보기'
수만 페이지의 책에서 특정 단어를 찾을 때, 첫 페이지부터 넘기면 한 세월이 걸립니다. 하지만 맨 뒷장의 '찾아보기'를 보면 단번에 페이지를 찾을 수 있죠.
- **비유**: 도서관 사서가 책의 위치를 미리 가나다순으로 정리해둔 목록표와 같습니다. 목록표만 보면 서가 어디에 책이 있는지 바로 알 수 있습니다.

### 7.2. 역색인(Inverted Index) - 단어로 문서 찾기
보통 "이 책에는 무슨 단어가 있지?"라고 묻지만, 역색인은 "이 단어는 어느 책들에 나오지?"라고 묻는 방식입니다.
- **비유**: 신문 기사들 중에서 'AI'라는 단어가 들어간 기사들만 모아둔 스크랩북과 같습니다. 단어 하나만 찾으면 관련 기사 리스트가 주르륵 나옵니다.

### 7.3. 실행 계획(Explain) - 데이터베이스의 생각 읽기
DB에게 "이 쿼리 어떻게 실행할 거야?"라고 물어보는 기능입니다. 우리가 만든 인덱스를 잘 쓰고 있는지 검사하는 성적표와 같습니다.
- **비유**: 목적지까지 갈 때 지도를 보고 '지하철을 탈지, 버스를 탈지' 미리 경로를 짜보는 것과 같습니다. 가장 빠른 길로 가고 있는지 확인하는 과정입니다.

## 8. 참고 링크

- [PostgreSQL Index Types](https://www.postgresql.org/docs/current/indexes-types.html)
- [PostgreSQL Full Text Search Guide](https://www.postgresql.org/docs/current/textsearch.html)
- [PostgreSQL Full Text Search Indexing](https://www.postgresql.org/docs/current/textsearch-indexes.html)
- [Spring Data JPA Pagination](https://docs.spring.io/spring-data/jpa/reference/repositories/query-methods-details.html#repositories.special-parameters)
- [Baeldung - Guide to Full-Text Search in Hibernate](https://www.baeldung.com/hibernate-search)
- [Baeldung - PostgreSQL Full-Text Search with Spring Data JPA](https://www.baeldung.com/spring-data-jpa-postgresql-full-text-search)
- [PostgreSQL pg_trgm extension](https://www.postgresql.org/docs/current/pgtrgm.html)
