# 04. 성능 최적화: 인덱싱과 전문 검색(Full Text Search)

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- SQL 기초 (SELECT, WHERE, LIKE)
- 데이터베이스 인덱스 개념
- Week 1의 02, 03 문서 내용 (검색 구현, UI 구현)

---

## 1. 개요

검색 기능을 구현했지만, 데이터가 많아지면 속도가 느려질 수 있습니다.

**이 문서에서 배울 내용:**
- 인덱스(Index)가 무엇이고 왜 필요한지
- LIKE 검색의 성능 한계 이해하기
- 인덱스를 타는 검색과 타지 않는 검색의 차이
- 전문 검색(Full Text Search)이 무엇인지
- GIN 인덱스로 대량 텍스트 검색 최적화하기

> **중요: 왜 성능 최적화가 중요할까요?**
>
> 데이터가 1,000권일 때는 빠르지만, 100만권이 되면 어떨까요?
>
> - 인덱스 없음: 1초 → 10분으로 느려짐
> - 인덱스 있음: 1초 → 1초로 유지
>
> 사용자는 10초만 기다려도 지루해합니다!

---

## 2. 핵심 개념 이해

### 2.1. 인덱스(Index)란?

**인덱스**는 데이터를 빠르게 찾기 위한 색인입니다.

**비유로 이해하기:**
```
도서관에서 책을 찾는 상황을 상상해 보세요.

[인덱스 없이]
- 책장을 처음부터 끝까지 한 권씩 다 뒤져봐야 함
- 10만 권이면 평균 5만 권을 뒤져야 찾음

[인덱스 있이]
- 도서 목록(카드ATALOG)에서 원하는 책을 찾음
- 목록에는 책 위치가 적혀 있음
- 바로 해당 위치로 감
```

**인덱스의 장점:**
- 검색 속도가 매우 빨라집니다
- 정렬된 데이터를 빠르게 가져올 수 있습니다

**인덱스의 단점:**
- 저장 공간을 추가로 사용합니다
- 데이터를 추가/수정/삭제할 때 느려집니다
- 인덱스 관리가 필요합니다

### 2.2. B-Tree 인덱스란?

**B-Tree**는 가장 널리 사용되는 인덱스 구조입니다.

**비유로 이해하기:**
```
이진 탐색(Binary Search) 트리를 상상해 보세요.

[전화번호부]
- 가나다순으로 정렬되어 있음
- '김'씨를 찾으면 → '가~너' 구간은 스킵
- '하'씨를 찾으면 → '사~아' 구간은 스킵
```

**B-Tree의 특징:**
- 데이터가 정렬되어 저장됩니다
- 균형 잡힌 트리 구조입니다
- 범위 검색에 효율적입니다

### 2.3. LIKE 검색의 문제점

`LIKE '%키워드%'` 형태의 검색은 인덱스를 활용하지 못합니다.

**비유로 이해하기:**
```
[전방 일치: '자바%']
- "자바"로 시작하는 단어 찾기
- 전화번호부에서 '김'씨 찾기와 같음
- 인덱스 활용 가능

[후방 일치: '%프로그래밍']
- "프로그래밍"으로 끝나는 단어 찾기
- 전화번호부에서 '민'으로 끝나는 이름 찾기
- 인덱스 활용 불가

[부분 일치: '%자바%']
- "자바"가 포함된 단어 찾기
- 전화번호부에서 '철수'가 들어가는 이름 찾기
- 인덱스 활용 불가
```

### 2.4. 전문 검색(Full Text Search)이란?

**전문 검색**은 텍스트 전체를 분석하여 검색하는 방식입니다.

**비유로 이해하기:**
```
책의 '찾아보기(색인)'를 상상해 보세요.

[일반 검색]
- 책 한 페이지씩 넘기며 '행복'이라는 단어 찾기
- 느림

[전문 검색]
- 책 뒤의 색인 페이지를 보면 '행복'이 있는 페이지 목록
- 바로 해당 페이지로 이동
- 빠름!
```

**전문 검색의 핵심 기술:**

1. **토큰화(Tokenization)**
   - 문장을 단어 단위로 쪼개는 과정
   - 예: "학교에 가다" → ["학교", "가다"]

2. **역색인(Inverted Index)**
   - 단어별로 문서 위치를 저장
   - 예: "자바" → [책1, 책5, 책10]

### 2.5. GIN 인덱스란?

**GIN**은 Generalized Inverted Index의 약자입니다.

**특징:**
- 전문 검색을 위한 인덱스 타입
- 대량 텍스트 검색에 최적화
- 배열 타입 검색에도 사용

**비교:**
| 인덱스 타입 | 용도 | 예시 |
|------------|------|------|
| B-Tree | 정확한 일치, 범위 검색 | ID, 날짜 |
| GIN | 전문 검색, 배열 검색 | 본문, 태그 |

---

## 3. 인덱스 작동 원리

### 3.1. 인덱스를 타는 검색

```sql
-- 전방 일치 (인덱스 사용)
SELECT * FROM books WHERE title LIKE '자바%';
```

**작동 과정:**
```
[B-Tree 인덱스]
  가 ~ 다: 책 1,000권
  라 ~ 마: 책 800권
  바 ~ 사: 책 1,200권  ← 여기만 검색
  아 ~ 자: 책 900권
  차 ~ 하: 책 1,100권

"자바"로 시작하면 '바~사' 구간만 찾음
→ 전체 5,000권 중 1,200권만 검색
```

### 3.2. 인덱스를 타지 않는 검색

```sql
-- 부분 일치 (인덱스 미사용)
SELECT * FROM books WHERE title LIKE '%자바%';
```

**작동 과정:**
```
[Full Table Scan]
책 1: "Java의 정석" → 찾음! ✅
책 2: "파이썬 기초" → 없음
책 3: "이것이 자바다" → 찾음! ✅
...
책 5000: "C++ 프로그래밍" → 없음

전체 5,000권을 하나씩 다 확인해야 함
```

---

## 4. 전문 검색 구현

### 4.1. PostgreSQL 전문 검색 설정

PostgreSQL은 한글 전문 검색을 위한 설정이 필요합니다.

**한글 형태소 분석 설정:**
```sql
-- 한글 텍스트 검색 설정 생성
CREATE TEXT SEARCH CONFIGURATION korean (COPY = simple);
```

### 4.2. GIN 인덱스 생성

도서 내용 필드에 전문 검색 인덱스를 만듭니다.

**인덱스 생성 SQL:**
```sql
-- book_content 필드에 GIN 인덱스 생성
CREATE INDEX idx_book_content_fts
ON books
USING GIN (to_tsvector('korean', book_content));
```

**설명:**
- `to_tsvector('korean', book_content)`: 텍스트를 토큰화하여 벡터로 변환
- `USING GIN`: GIN 인덱스 타입 사용

### 4.3. 전문 검색 쿼리

전문 검색 연산자 `@@`를 사용합니다.

**기본 쿼리:**
```sql
-- '자바 프로그래밍' 검색
SELECT title, book_content
FROM books
WHERE to_tsvector('korean', book_content)
      @@ plainto_tsquery('korean', '자바 프로그래밍');
```

**설명:**
- `to_tsvector`: 텍스트를 검색 가능한 벡터로 변환
- `plainto_tsquery`: 검색어를 쿼리로 변환
- `@@`: 일치하는지 확인하는 연산자

---

## 5. Spring Data JPA 적용

### 5.1. Hibernate 커스텀 함수 등록

PostgreSQL 전문 검색 함수를 Hibernate에 등록합니다.

**PostgreSQLFunctionContributor.java**
```java
package com.nhnacademy.library.core.config;

import org.hibernate.boot.model.FunctionContributor;
import org.hibernate.boot.model.FunctionContributions;
import org.hibernate.type.StandardBasicTypes;

/**
 * PostgreSQL 커스텀 함수 등록
 *
 * 전문 검색 함수를 Hibernate에서 사용할 수 있도록 등록합니다.
 */
public class PostgreSQLFunctionContributor implements FunctionContributor {

    @Override
    public void contributeFunctions(FunctionContributions functionContributions) {
        // ts_match_korean 함수 패턴 등록
        functionContributions.getFunctionRegistry()
                .registerPattern(
                        "ts_match_korean",
                        "to_tsvector('korean', ?1) @@ plainto_tsquery('korean', ?2)",
                        functionContributions.getTypeConfiguration()
                                .getBasicTypeRegistry()
                                .resolve(StandardBasicTypes.BOOLEAN)
                );
    }
}
```

### 5.2. SPI 등록

Hibernate가 함수를 인식할 수 있도록 등록합니다.

**파일:** `src/main/resources/META-INF/services/org.hibernate.boot.model.FunctionContributor`
```
com.nhnacademy.library.core.config.PostgreSQLFunctionContributor
```

### 5.3. QueryDSL 적용

전문 검색을 동적 쿼리에 적용합니다.

**BookRepositoryImpl.java**
```java
private BooleanBuilder commonWhere(BookSearchRequest request) {
    BooleanBuilder builder = new BooleanBuilder();

    if (StringUtils.isNotEmpty(request.keyword())) {
        String keyword = request.keyword();

        // 1. LIKE 검색 (제목, 저자 등 짧은 필드)
        builder.or(book.title.containsIgnoreCase(keyword))
                .or(book.authorName.containsIgnoreCase(keyword))
                .or(book.publisherName.containsIgnoreCase(keyword));

        // 2. 전문 검색 (본문 긴 텍스트)
        BooleanExpression fts = Expressions.booleanTemplate(
                "function('ts_match_korean', {0}, {1}) = true",
                book.bookContent,  // 검색 대상 필드
                keyword           // 검색어
        );
        builder.or(fts);
    }

    return builder;
}
```

---

## 6. 성능 비교

### 6.1. 인덱스 유무에 따른 성능 차이

| 데이터 수 | 인덱스 없음 | B-Tree 인덱스 | GIN 인덱스 |
|-----------|------------|---------------|-----------|
| 1,000건 | 10ms | 1ms | 1ms |
| 10,000건 | 100ms | 2ms | 2ms |
| 100,000건 | 1,000ms | 5ms | 5ms |
| 1,000,000건 | 10,000ms | 10ms | 10ms |

### 6.2. 검색 방법 비교

| 검색 방법 | 속도 | 정확도 | 용도 |
|-----------|------|--------|------|
| LIKE 전방 일치 | 빠름 | 높음 | 제목 검색 |
| LIKE 부분 일치 | 느림 | 높음 | - |
| 전문 검색 | 매빠름 | 중간 | 본문 검색 |

---

## 7. 실습 미션

### 미션 1: EXPLAIN으로 실행 계획 확인

```sql
-- 실행 계획 확인
EXPLAIN ANALYZE
SELECT * FROM books
WHERE title LIKE '자바%';
```

### 미션 2: 인덱스 생성前后 비교

```sql
-- 인덱스 생성 전
EXPLAIN ANALYZE SELECT * FROM books WHERE title LIKE '자바%';

-- 인덱스 생성
CREATE INDEX idx_book_title ON books(title);

-- 인덱스 생성 후
EXPLAIN ANALYZE SELECT * FROM books WHERE title LIKE '자바%';
```

### 미션 3: 전문 검색 테스트

```sql
-- 전문 검색 인덱스 생성
CREATE INDEX idx_book_content_fts
ON books USING GIN (to_tsvector('korean', book_content));

-- 전문 검색 실행
SELECT title
FROM books
WHERE to_tsvector('korean', book_content)
      @@ plainto_tsquery('korean', '데이터 구조');
```

---

## 8. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

- [ ] 인덱스가 무엇이고 왜 필요한지 설명할 수 있다
- [ ] B-Tree와 GIN 인덱스의 차이를 안다
- [ ] LIKE 검색이 언제 인덱스를 타는지 이해한다
- [ ] 전문 검색(Full Text Search)의 원리를 안다
- [ ] 역색인(Inverted Index)이 무엇인지 설명할 수 있다
- [ ] EXPLAIN으로 실행 계획을 확인할 수 있다
- [ ] PostgreSQL 전문 검색을 구현할 수 있다

---

## 9. Week 1 정리

이번 주차에 배운 내용을 복습해 보세요:

### 1단계: 데이터 적재
- CSV 파일을 읽어서 DB에 저장
- 배치 처리로 대량 데이터를 효율적으로 적재
- 이벤트 기반 아키텍처로 코드 분리

### 2단계: 기본 검색
- LIKE 검색으로 도서 찾기
- QueryDSL로 동적 쿼리 생성
- DTO로 검색 결과 전달

### 3단계: UI 구현
- Thymeleaf로 HTML 템플릿 만들기
- Bootstrap으로 예쁜 UI 구현
- Controller와 View의 데이터 흐름 이해

### 4단계: 성능 최적화
- 인덱스로 검색 속도 높이기
- 전문 검색으로 대량 텍스트 검색
- EXPLAIN으로 실행 계획 확인

---

## 10. 다음 단계

다음 주차에서는 **벡터 검색**을 배웁니다:
- 임베딩(Embedding)이 무엇인지
- 벡터 검색의 원리
- pgvector로 벡터 검색 구현하기

[다음: Week 2 - 벡터 검색 →](../week-2/01.search-quality-limitations.md)
