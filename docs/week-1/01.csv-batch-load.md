# 01. 데이터 적재: 공공 도서 CSV Batch Load

## 학습 전제조건

이 문서를 학습하기 전에 다음 내용을 알고 있으면 도움이 됩니다:
- Java 기초 문법 (클래스, 인터페이스, 리스트)
- Spring Boot 기초 (@Component, @Service 어노테이션)
- 데이터베이스 기초 (INSERT, 트랜잭션 개념)

---

## 1. 개요

외부 공공 도서 데이터(CSV)를 데이터베이스에 대량으로 저장하는 배치(Batch) 처리를 구현해 봅니다.

**이 문서에서 배울 내용:**
- 배치(Batch) 처리가 무엇이고 왜 필요한지
- 이벤트 기반 아키텍처로 코드를 분리하는 방법
- 대량 데이터를 효율적으로 저장하는 방법
- CSV 파일을 읽어서 DB에 저장하는 전체 과정

> **중요: 왜 배치 처리가 중요할까요?**
>
> 도서관에 새로 책 10만 권이 들어왔다고 상상해 보세요.
>
> - **하나씩 저장**: 1권씩 도서관에 가져가면 10만 번 왔다 갔다 해야 합니다.
> - **배치 처리**: 1,000권씩 박스에 담아서 가져가면 100번만 오면 됩니다!
>
> 이것이 배치 처리의 핵심입니다. **모아서 한 번에 처리**하는 것이죠.

---

## 2. 핵심 개념 이해

### 2.1. 배치(Batch) 처리란?

**배치(Batch)**는 대량의 데이터를 모아서 한 번에 처리하는 방식입니다.

**비유로 이해하기:**
```
편지 100통을 보내는 상황을 상상해 보세요.

하나씩 보내기:
- 편지 1통 쓰기 → 우체국 가기 → 발송
- 편지 1통 쓰기 → 우체국 가기 → 발송
... (100번 반복)

배치 처리:
- 편지 100통 쓰기 → 한 번에 우체국 가기 → 발송

어떤 방법이 더 효율적일까요?
당연히 배치 처리입니다!
```

**배치 처리의 특징:**
- 대량 데이터를 빠르게 처리할 수 있습니다
- 네트워크/DB 연결 횟수를 줄입니다
- 트랜잭션 관리가 쉽습니다
- 실시간 처리는 어렵습니다

### 2.2. CSV 파일이란?

**CSV**는 Comma-Separated Values의 약자로, 쉼표(,)로 구분된 텍스트 파일입니다.

**예시:**
```csv
ISBN,TITLE,AUTHOR_NAME,PUBLISHER_NAME
9791165930377,Java의정석,남궁성,도우출판
9791162233968,자바코딩의법칙,김동현,길벗
```

> **참고: 왜 CSV인가요?**
>
> CSV는 데이터를 주고받는 가장 기본적인 형식입니다.
> - 엑셀에서 열 수 있습니다
> - 메모장에서 편집할 수 있습니다
> - 모든 프로그래밍 언어가 지원합니다

### 2.3. 이벤트 기반 아키텍처란?

**이벤트(Event)**는 "무언가 일어났음"을 알리는 신호입니다.

**비유로 이해하기:**
```
식당을 상상해 보세요.

[손님] --"주문해요"--> [종업원] --"주문서 전달"--> [주방]

이 과정에서:
- 손님과 주방은 서로 직접 대화하지 않습니다
- 종업원이 중간에서 연결해 줍니다
- 주문서(이벤트)로 정보를 전달합니다

이것이 이벤트 기반 아키텍처의 핵심입니다!
```

**이벤트 기반 아키텍처의 장점:**
- **분리**: 코드끼리 서로를 몰라도 됩니다
- **확장**: 새로운 기능을 쉽게 추가할 수 있습니다
- **유지보수**: 한 부분을 고쳐도 다른 부분에 영향이 없습니다

### 2.4. 트랜잭션(Transaction)이란?

**트랜잭션**은 "모두 성공하거나, 모두 실패하거나"를 보장하는 기능입니다.

**비유로 이해하기:**
```
은행 이체를 상상해 보세요.

1. 내 계정에서 10,000원 출금 (성공)
2. 상대방 계정으로 10,000원 입금 (실패!)

여기서 문제가 발생합니다:
- 내 돈은 빠졌는데
- 상대방에게는 안 들어갔습니다

트랜잭션은 이런 상황을 방지합니다:
"2번 과정이 실패하면, 1번도 취소해!"
```

### 2.5. 엔티티(Entity) vs DTO

**엔티티(Entity)**: 데이터베이스 테이블과 1:1로 매핑되는 클래스

**DTO (Data Transfer Object)**: 데이터를 전달하기 위한 클래스

**비유로 이해하기:**
```
도서관 시스템을 상상해 보세요.

[실제 책 (Entity)]
- 도서관의 책장에 꽂힌 진짜 책
- ISBN, 제목, 저자 등이 적힌 도서 카드
- 데이터베이스에 저장되는 실제 데이터

[주문서 (DTO)]
- 책을 주문할 때 작성하는 종이
- 주문할 책의 ISBN과 수량이 적혀 있음
- 데이터를 전달하는 용도로만 사용

CSV에서 읽은 데이터는 주문서(DTO)와 같고,
이를 실제 책(Entity)으로 변환해서 저장합니다.
```

---

## 3. 전체 시스템 구조

### 3.1. 컴포넌트 구조

```
CSV 파일
   ↓
[CSV Parser]      ← 파일을 읽어서 파싱
   ↓ (이벤트 발행)
[Event Listener]  ← 이벤트를 받아서 버퍼에 저장
   ↓
[Batch Service]   ← 배치 단위로 DB에 저장
   ↓
  Database
```

### 3.2. 이벤트 흐름 다이어그램

```
[CSV 파일]
    │
    │  1. 파일 열기
    ↓
[CsvBookParser]
    │
    │  2. 한 줄씩 읽기
    ├─────────────────────────────┐
    │                             │
    ↓                             ↓
[BookParsedEvent]            [다음 줄 읽기]
    │                             │
    │  3. 이벤트 발행              │
    ↓                             │
[BookParsingEventListener]         │
    │                             │
    │  4. 버퍼에 저장              │
    ↓                             │
 [버퍼(List)]                      │
    │                             │
    │                        (반복)
    ↓
[파싱 완료]
    │
    │  5. BookParsingCompleteEvent 발행
    ↓
[BookBatchService]
    │
    │  6. 배치 단위로 DB 저장
    ↓
[Database]
```

---

## 4. 구현 가이드 (Step-by-Step)

### STEP 1: 이벤트 정의하기

먼저 시스템에서 사용할 이벤트를 정의합니다.

**BookParsedEvent.java** (책 한 권 파싱 완료)
```java
package com.nhnacademy.library.batch.init.event;

import com.nhnacademy.library.batch.init.dto.BookRawData;
import lombok.Getter;

/**
 * 도서 파싱 완료 이벤트
 *
 * CSV 파일에서 한 권의 도서를 파싱할 때마다 발행됩니다.
 */
@Getter
public class BookParsedEvent {

    /** 파싱된 도서 데이터 */
    private final BookRawData bookRawData;

    public BookParsedEvent(BookRawData bookRawData) {
        this.bookRawData = bookRawData;
    }
}
```

**BookParsingCompleteEvent.java** (파싱 전체 완료)
```java
package com.nhnacademy.library.batch.init.event;

/**
 * 도서 파싱 전체 완료 이벤트
 *
 * CSV 파일의 모든 도서를 파싱하면 발행됩니다.
 */
public class BookParsingCompleteEvent {
    // 별도의 데이터는 필요 없음
    // 이벤트 발행 자체로 "완료"를 의미
}
```

---

### STEP 2: DTO 정의하기

CSV 데이터를 담을 DTO를 만듭니다.

**BookRawData.java** (CSV 데이터용 DTO)
```java
package com.nhnacademy.library.batch.init.dto;

import lombok.Data;

/**
 * CSV 파일에서 읽은 원본 도서 데이터
 *
 * 엔티티가 아닌 DTO로 정의하여
 * CSV 구조와 DB 구조의 분리를 유지합니다.
 */
@Data
public class BookRawData {

    /** 도서 ID */
    private Long id;

    /** ISBN (고유번호) */
    private String isbn;

    /** 도서 제목 */
    private String title;

    /** 저자명 */
    private String authorName;

    /** 출판사명 */
    private String publisherName;

    /** 출판일 */
    private String publishDate;

    /** 도서 내용 미리보기 */
    private String bookContent;

    /** 표지 이미지 URL */
    private String imageUrl;

    // ... 기타 필드
}
```

---

### STEP 3: CSV 파서 구현하기

Apache Commons CSV 라이브러리를 사용하여 CSV 파일을 읽습니다.

**CsvBookParser.java**
```java
package com.nhnacademy.library.batch.init.parser;

import com.nhnacademy.library.batch.init.dto.BookRawData;
import com.nhnacademy.library.batch.init.event.BookParsedEvent;
import com.nhnacademy.library.batch.init.event.BookParsingCompleteEvent;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;

/**
 * CSV 도서 파서
 *
 * CSV 파일을 읽어서 각 레코드별로 이벤트를 발행합니다.
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class CsvBookParser {

    private final ApplicationEventPublisher eventPublisher;

    /**
     * CSV 파일을 파싱합니다
     *
     * @param filePath CSV 파일 경로
     * @throws IOException 파일 읽기 실패
     */
    public void parse(String filePath) throws IOException {
        log.info("CSV 파싱 시작: {}", filePath);

        // ClassPath에서 파일 읽기
        ClassPathResource resource = new ClassPathResource(filePath);

        try (InputStreamReader reader = new InputStreamReader(
                resource.getInputStream(), StandardCharsets.UTF_8);
             CSVParser parser = CSVFormat.DEFAULT
                     .withHeader()           // 첫 줄은 헤더로 처리
                     .withSkipHeaderRecord()  // 헤더 건너뜀기
                     .withIgnoreEmptyLines()  // 빈 줄 무시
                     .parse(reader)) {

            int count = 0;

            // 각 레코드 순회
            for (CSVRecord record : parser) {
                BookRawData book = mapToBookRawData(record);

                // 파싱 완료 이벤트 발행
                eventPublisher.publishEvent(new BookParsedEvent(book));

                count++;

                // 1000권마다 로그 출력
                if (count % 1000 == 0) {
                    log.info("{}권 파싱 완료", count);
                }
            }

            log.info("총 {}권 파싱 완료", count);

            // 파싱 전체 완료 이벤트 발행
            eventPublisher.publishEvent(new BookParsingCompleteEvent());
        }
    }

    /**
     * CSV 레코드를 BookRawData로 변환
     *
     * @param record CSV 레코드
     * @return BookRawData 객체
     */
    private BookRawData mapToBookRawData(CSVRecord record) {
        BookRawData book = new BookRawData();

        try {
            book.setId(Long.valueOf(record.get("ID")));
        } catch (IllegalArgumentException e) {
            book.setId(null);  // ID가 없으면 null 설정
        }

        book.setIsbn(record.get("ISBN"));
        book.setTitle(record.get("TITLE_NM"));
        book.setAuthorName(record.get("AUTHOR_NM"));
        book.setPublisherName(record.get("PUBLISHER_NM"));
        // ... 기타 필드 매핑

        return book;
    }
}
```

---

### STEP 4: 이벤트 리스너 구현하기

발행된 이벤트를 받아서 데이터를 수집하고, 배치 저장을 호출합니다.

**BookParsingEventListener.java**
```java
package com.nhnacademy.library.batch.init.listener;

import com.nhnacademy.library.batch.init.dto.BookRawData;
import com.nhnacademy.library.batch.init.event.BookParsedEvent;
import com.nhnacademy.library.batch.init.event.BookParsingCompleteEvent;
import com.nhnacademy.library.batch.init.service.BookBatchService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

/**
 * 도서 파싱 이벤트 리스너
 *
 * 파싱된 도서 데이터를 버퍼에 모았다가
 * 파싱 완료 시 배치 저장 서비스를 호출합니다.
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class BookParsingEventListener {

    /** 파싱된 도서를 임시로 저장할 버퍼 */
    private final List<BookRawData> buffer = new ArrayList<>();

    private final BookBatchService batchService;

    /**
     * 도서 파싱 완료 이벤트 처리
     *
     * @param event 도서 파싱 완료 이벤트
     */
    @EventListener
    public void onBookParsed(BookParsedEvent event) {
        // 버퍼에 추가
        buffer.add(event.bookRawData());
    }

    /**
     * 파싱 전체 완료 이벤트 처리
     *
     * @param event 파싱 완료 이벤트
     */
    @EventListener
    public void onParsingCompleted(BookParsingCompleteEvent event) {
        log.info("파싱 완료, 도서 {}권 저장 시작", buffer.size());

        // 배치 저장 서비스 호출
        batchService.initializeBooks(buffer);

        // 버퍼 비우기
        buffer.clear();

        log.info("도서 저장 완료");
    }
}
```

---

### STEP 5: 배치 저장 서비스 구현하기

모아둔 데이터를 배치 단위로 DB에 저장합니다.

**BookBatchService.java**
```java
package com.nhnacademy.library.batch.init.service;

import com.nhnacademy.library.batch.init.dto.BookRawData;
import com.nhnacademy.library.core.book.domain.Book;
import com.nhnacademy.library.core.book.repository.BookRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;

/**
 * 도서 배치 저장 서비스
 *
 * 대량의 도서 데이터를 배치 단위로 DB에 저장합니다.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class BookBatchService {

    private final BookRepository bookRepository;

    /**
     * 도서 목록을 배치 단위로 저장
     *
     * @param bookRawDataList 저장할 도서 목록
     */
    @Transactional
    public void initializeBooks(List<BookRawData> bookRawDataList) {
        int batchSize = 1000;  // 한 번에 저장할 개수
        int total = bookRawDataList.size();

        log.info("도서 {}권을 배치 크기 {}로 저장 시작", total, batchSize);

        // 배치 단위로 나누어 저장
        for (int i = 0; i < total; i += batchSize) {

            // 현재 배치의 끝 인덱스 계산
            int end = Math.min(i + batchSize, total);

            // 서브 리스트 추출
            List<BookRawData> subList = bookRawDataList.subList(i, end);

            // DTO를 엔티티로 변환
            List<Book> books = convertToEntities(subList);

            // 배치 저장
            bookRepository.saveAll(books);

            log.info("{} / {} 저장 완료", end, total);
        }

        log.info("모든 도서 저장 완료");
    }

    /**
     * BookRawData를 Book 엔티티로 변환
     *
     * @param rawDataList BookRawData 목록
     * @return Book 엔티티 목록
     */
    private List<Book> convertToEntities(List<BookRawData> rawDataList) {
        List<Book> books = new ArrayList<>();

        for (BookRawData rawData : rawDataList) {
            Book book = new Book(
                rawData.getIsbn(),
                rawData.getTitle(),
                rawData.getAuthorName(),
                rawData.getPublisherName(),
                // ... 기타 필드
                rawData.getBookContent()
            );
            books.add(book);
        }

        return books;
    }
}
```

---

### STEP 6: 실행 설정

**application.properties**
```properties
# 초기화 설정
init.enable=true              # 초기화 실행 여부 (1회 실행 후 false 권장)
init.book_file=data/init/BOOK_DB_202112.csv  # CSV 파일 경로
init.batch_size=1000         # 배치 크기
```

---

## 5. 핵심 기술 상세 설명

### 5.1. Apache Commons CSV

CSV 파일을 쉽게 읽을 수 있는 라이브러리입니다.

**장점:**
- 따옴표, 쉼표, 개행 문자 등을 자동으로 처리
- 다양한 CSV 형식 지원
- 간편한 API 제공

**pom.xml 의존성:**
```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-csv</artifactId>
    <version>1.13.0</version>
</dependency>
```

### 5.2. @EventListener

Spring의 이벤트 리스너 어노테이션입니다.

**사용법:**
```java
@Component
public class MyListener {

    @EventListener
    public void handleEvent(MyEvent event) {
        // 이벤트 처리 로직
    }
}
```

**특징:**
- 메서드 이름은 자유롭게 지정
- 파라미터로 받을 이벤트 타입 지정
- 한 개의 리스너가 여러 이벤트를 처리할 수 있음

### 5.3. saveAll() vs save()

| 메서드 | 설명 | 성능 |
|--------|------|------|
| save() | 데이터 1개 저장 | 느림 (N번 DB 연결) |
| saveAll() | 데이터 여러 개 한 번에 저장 | 빠름 (1번 DB 연결) |

**예시:**
```java
// 느린 방식
for (Book book : books) {
    repository.save(book);  // 1000번 DB 연결
}

// 빠른 방식
repository.saveAll(books);  // 1번 DB 연결
```

---

## 6. 실습 미션

### 미션 1: 직접 CSV 파일 만들어보기

다음 내용을 `test.csv`로 저장해 보세요:
```csv
ISBN,TITLE,AUTHOR
9791165930377,Java의정석,남궁성
9791162233968,자바코딩의법칙,김동현
```

### 미션 2: 배치 크기 변경해보기

`batchSize`를 100, 500, 1000으로 변경하며 실행 시간을 측정해 보세요.

### 미션 3: 로그 레벨 조정

`application.properties`에 다음을 추가하고 로그를 확인해 보세요:
```properties
logging.level.com.nhnacademy.library.batch=DEBUG
```

---

## 7. 학습 체크리스트

다음 내용을 이해했는지 확인해 보세요:

- [ ] 배치 처리가 무엇이고 왜 필요한지 설명할 수 있다
- [ ] CSV 파일 구조를 이해한다
- [ ] 이벤트 기반 아키텍처의 장점을 안다
- [ ] 트랜잭션의 개념을 이해한다
- [ ] 엔티티와 DTO의 차이를 설명할 수 있다
- [ ] Apache Commons CSV를 사용할 수 있다
- [ ] @EventListener를 사용할 수 있다
- [ ] saveAll()로 배치 저장을 할 수 있다

---

## 8. 다음 단계

다음 문서에서는 **기본 검색 기능**을 구현합니다:
- LIKE 검색으로 도서 찾기
- QueryDSL로 동적 쿼리 만들기
- DTO로 검색 결과 전달하기

[다음: 02. 기본 검색 구현 →](02.book-search-implementation.md)
